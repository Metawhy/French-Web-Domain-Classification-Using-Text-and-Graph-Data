   [Docs] [txt|pdf] [draft-irtf-cfrg...] [Tracker] [Diff1] [Diff2]
   [Errata]
   INFORMATIONAL
   Errata Exist
Internet Research Task Force (IRTF)                         S. Josefsson
Request for Comments: 8032                                        SJD AB
Category: Informational                                     I. Liusvaara
ISSN: 2070-1721                                              Independent
                                                            January 2017


           Edwards-Curve Digital Signature Algorithm (EdDSA)

Abstract

   This document describes elliptic curve signature scheme Edwards-curve
   Digital Signature Algorithm (EdDSA).  The algorithm is instantiated
   with recommended parameters for the edwards25519 and edwards448
   curves.  An example implementation and test vectors are provided.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Research Task Force
   (IRTF).  The IRTF publishes the results of Internet-related research
   and development activities.  These results might not be suitable for
   deployment.  This RFC represents the consensus of the Crypto Forum
   Research Group of the Internet Research Task Force (IRTF).  Documents
   approved for publication by the IRSG are not a candidate for any
   level of Internet Standard; see Section 2 of RFC 7841.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc8032.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.







Josefsson & Liusvaara         Informational                     [Page 1]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Notation and Conventions  . . . . . . . . . . . . . . . . . .   4
   3.  EdDSA Algorithm . . . . . . . . . . . . . . . . . . . . . . .   5
     3.1.  Encoding  . . . . . . . . . . . . . . . . . . . . . . . .   7
     3.2.  Keys  . . . . . . . . . . . . . . . . . . . . . . . . . .   7
     3.3.  Sign  . . . . . . . . . . . . . . . . . . . . . . . . . .   8
     3.4.  Verify  . . . . . . . . . . . . . . . . . . . . . . . . .   8
   4.  PureEdDSA, HashEdDSA, and Naming  . . . . . . . . . . . . . .   8
   5.  EdDSA Instances . . . . . . . . . . . . . . . . . . . . . . .   9
     5.1.  Ed25519ph, Ed25519ctx, and Ed25519  . . . . . . . . . . .   9
       5.1.1.  Modular Arithmetic  . . . . . . . . . . . . . . . . .  10
       5.1.2.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  10
       5.1.3.  Decoding  . . . . . . . . . . . . . . . . . . . . . .  11
       5.1.4.  Point Addition  . . . . . . . . . . . . . . . . . . .  11
       5.1.5.  Key Generation  . . . . . . . . . . . . . . . . . . .  13
       5.1.6.  Sign  . . . . . . . . . . . . . . . . . . . . . . . .  13
       5.1.7.  Verify  . . . . . . . . . . . . . . . . . . . . . . .  14
     5.2.  Ed448ph and Ed448 . . . . . . . . . . . . . . . . . . . .  15
       5.2.1.  Modular Arithmetic  . . . . . . . . . . . . . . . . .  16
       5.2.2.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  16
       5.2.3.  Decoding  . . . . . . . . . . . . . . . . . . . . . .  16
       5.2.4.  Point Addition  . . . . . . . . . . . . . . . . . . .  17
       5.2.5.  Key Generation  . . . . . . . . . . . . . . . . . . .  18
       5.2.6.  Sign  . . . . . . . . . . . . . . . . . . . . . . . .  19
       5.2.7.  Verify  . . . . . . . . . . . . . . . . . . . . . . .  19
   6.  Ed25519 Python Illustration . . . . . . . . . . . . . . . . .  20
   7.  Test Vectors  . . . . . . . . . . . . . . . . . . . . . . . .  23
     7.1.  Test Vectors for Ed25519  . . . . . . . . . . . . . . . .  24
     7.2.  Test Vectors for Ed25519ctx . . . . . . . . . . . . . . .  27
     7.3.  Test Vectors for Ed25519ph  . . . . . . . . . . . . . . .  30
     7.4.  Test Vectors for Ed448  . . . . . . . . . . . . . . . . .  30
     7.5.  Test Vectors for Ed448ph  . . . . . . . . . . . . . . . .  38
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  40
     8.1.  Side-Channel Leaks  . . . . . . . . . . . . . . . . . . .  40
     8.2.  Randomness Considerations . . . . . . . . . . . . . . . .  40
     8.3.  Use of Contexts . . . . . . . . . . . . . . . . . . . . .  41
     8.4.  Signature Malleability  . . . . . . . . . . . . . . . . .  41
     8.5.  Choice of Signature Primitive . . . . . . . . . . . . . .  41
     8.6.  Mixing Different Prehashes  . . . . . . . . . . . . . . .  42
     8.7.  Signing Large Amounts of Data at Once . . . . . . . . . .  42
     8.8.  Multiplication by Cofactor in Verification  . . . . . . .  43
     8.9.  Use of SHAKE256 as a Hash Function  . . . . . . . . . . .  43
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  43
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  43
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  44




Josefsson & Liusvaara         Informational                     [Page 2]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   Appendix A.  Ed25519/Ed448 Python Library . . . . . . . . . . . .  46
   Appendix B.  Library Driver . . . . . . . . . . . . . . . . . . .  58
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  60
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  60

1.  Introduction

   The Edwards-curve Digital Signature Algorithm (EdDSA) is a variant of
   Schnorr's signature system with (possibly twisted) Edwards curves.
   EdDSA needs to be instantiated with certain parameters, and this
   document describes some recommended variants.

   To facilitate adoption of EdDSA in the Internet community, this
   document describes the signature scheme in an implementation-oriented
   way and provides sample code and test vectors.

   The advantages with EdDSA are as follows:

   1.  EdDSA provides high performance on a variety of platforms;

   2.  The use of a unique random number for each signature is not
       required;

   3.  It is more resilient to side-channel attacks;

   4.  EdDSA uses small public keys (32 or 57 bytes) and signatures (64
       or 114 bytes) for Ed25519 and Ed448, respectively;

   5.  The formulas are "complete", i.e., they are valid for all points
       on the curve, with no exceptions.  This obviates the need for
       EdDSA to perform expensive point validation on untrusted public
       values; and

   6.  EdDSA provides collision resilience, meaning that hash-function
       collisions do not break this system (only holds for PureEdDSA).

   The original EdDSA paper [EDDSA] and the generalized version
   described in "EdDSA for more curves" [EDDSA2] provide further
   background.  RFC 7748 [RFC7748] discusses specific curves, including
   Curve25519 [CURVE25519] and Ed448-Goldilocks [ED448].

   Ed25519 is intended to operate at around the 128-bit security level
   and Ed448 at around the 224-bit security level.  A sufficiently large
   quantum computer would be able to break both.  Reasonable projections
   of the abilities of classical computers conclude that Ed25519 is
   perfectly safe.  Ed448 is provided for those applications with
   relaxed performance requirements and where there is a desire to hedge
   against analytical attacks on elliptic curves.



Josefsson & Liusvaara         Informational                     [Page 3]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


2.  Notation and Conventions

   The following notation is used throughout the document:

   p              Denotes the prime number defining the underlying field

   GF(p)          Finite field with p elements

   x^y            x multiplied by itself y times

   B              Generator of the group or subgroup of interest

   [n]X           X added to itself n times

   h[i]           The i'th octet of octet string

   h_i            The i'th bit of h

   a || b         (bit-)string a concatenated with (bit-)string b

   a <= b         a is less than or equal to b

   a >= b         a is greater than or equal to b

   i+j            Sum of i and j

   i*j            Multiplication of i and j

   i-j            Subtraction of j from i

   i/j            Division of i by j

   i x j          Cartesian product of i and j

   (u,v)          Elliptic curve point with x-coordinate u and
                  y-coordinate v

   SHAKE256(x, y) The y first octets of SHAKE256 [FIPS202] output for
                  input x

   OCTET(x)       The octet with value x

   OLEN(x)        The number of octets in string x








Josefsson & Liusvaara         Informational                     [Page 4]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   dom2(x, y)     The blank octet string when signing or verifying
                  Ed25519.  Otherwise, the octet string: "SigEd25519 no
                  Ed25519 collisions" || octet(x) || octet(OLEN(y)) ||
                  y, where x is in range 0-255 and y is an octet string
                  of at most 255 octets.  "SigEd25519 no Ed25519
                  collisions" is in ASCII (32 octets).

   dom4(x, y)     The octet string "SigEd448" || octet(x) ||
                  octet(OLEN(y)) || y, where x is in range 0-255 and y
                  is an octet string of at most 255 octets.  "SigEd448"
                  is in ASCII (8 octets).

   Parentheses (i.e., '(' and ')') are used to group expressions, in
   order to avoid having the description depend on a binding order
   between operators.

   Bit strings are converted to octet strings by taking bits from left
   to right, packing those from the least significant bit of each octet
   to the most significant bit, and moving to the next octet when each
   octet fills up.  The conversion from octet string to bit string is
   the reverse of this process; for example, the 16-bit bit string

             b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15

   is converted into two octets x0 and x1 (in this order) as

             x0 = b7*128+b6*64+b5*32+b4*16+b3*8+b2*4+b1*2+b0
             x1 = b15*128+b14*64+b13*32+b12*16+b11*8+b10*4+b9*2+b8

   Little-endian encoding into bits places bits from left to right and
   from least significant to most significant.  If combined with
   bit-string-to-octet-string conversion defined above, this results in
   little-endian encoding into octets (if length is not a multiple of 8,
   the most significant bits of the last octet remain unused).

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

3.  EdDSA Algorithm

   EdDSA is a digital signature system with 11 parameters.

   The generic EdDSA digital signature system with its 11 input
   parameters is not intended to be implemented directly.  Choosing
   parameters is critical for secure and efficient operation.  Instead,
   you would implement a particular parameter choice for EdDSA (such as




Josefsson & Liusvaara         Informational                     [Page 5]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   Ed25519 or Ed448), sometimes slightly generalized to achieve code
   reuse to cover Ed25519 and Ed448.

   Therefore, a precise explanation of the generic EdDSA is thus not
   particularly useful for implementers.  For background and
   completeness, a succinct description of the generic EdDSA algorithm
   is given here.

   The definition of some parameters, such as n and c, may help to
   explain some steps of the algorithm that are not intuitive.

   This description closely follows [EDDSA2].

   EdDSA has 11 parameters:

   1.   An odd prime power p.  EdDSA uses an elliptic curve over the
        finite field GF(p).

   2.   An integer b with 2^(b-1) > p.  EdDSA public keys have exactly b
        bits, and EdDSA signatures have exactly 2*b bits.  b is
        recommended to be a multiple of 8, so public key and signature
        lengths are an integral number of octets.

   3.   A (b-1)-bit encoding of elements of the finite field GF(p).

   4.   A cryptographic hash function H producing 2*b-bit output.
        Conservative hash functions (i.e., hash functions where it is
        infeasible to create collisions) are recommended and do not have
        much impact on the total cost of EdDSA.

   5.   An integer c that is 2 or 3.  Secret EdDSA scalars are multiples
        of 2^c.  The integer c is the base-2 logarithm of the so-called
        cofactor.

   6.   An integer n with c <= n < b.  Secret EdDSA scalars have exactly
        n + 1 bits, with the top bit (the 2^n position) always set and
        the bottom c bits always cleared.

   7.   A non-square element d of GF(p).  The usual recommendation is to
        take it as the value nearest to zero that gives an acceptable
        curve.

   8.   A non-zero square element a of GF(p).  The usual recommendation
        for best performance is a = -1 if p mod 4 = 1, and a = 1 if
        p mod 4 = 3.

   9.   An element B != (0,1) of the set E = { (x,y) is a member of
        GF(p) x GF(p) such that a * x^2 + y^2 = 1 + d * x^2 * y^2 }.



Josefsson & Liusvaara         Informational                     [Page 6]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   10.  An odd prime L such that [L]B = 0 and 2^c * L = #E.  The number
        #E (the number of points on the curve) is part of the standard
        data provided for an elliptic curve E, or it can be computed as
        cofactor * order.

   11.  A "prehash" function PH.  PureEdDSA means EdDSA where PH is the
        identity function, i.e., PH(M) = M.  HashEdDSA means EdDSA where
        PH generates a short output, no matter how long the message is;
        for example, PH(M) = SHA-512(M).

   Points on the curve form a group under addition, (x3, y3) = (x1, y1)
   + (x2, y2), with the formulas

             x1 * y2 + x2 * y1                y1 * y2 - a * x1 * x2
   x3 = --------------------------,   y3 = ---------------------------
         1 + d * x1 * x2 * y1 * y2          1 - d * x1 * x2 * y1 * y2

   The neutral element in the group is (0,1).

   Unlike many other curves used for cryptographic applications, these
   formulas are "complete"; they are valid for all points on the curve,
   with no exceptions.  In particular, the denominators are non-zero for
   all input points.

   There are more efficient formulas, which are still complete, that use
   homogeneous coordinates to avoid the expensive modulo p inversions.
   See [Faster-ECC] and [Edwards-revisited].

3.1.  Encoding

   An integer 0 < S < L - 1 is encoded in little-endian form as a b-bit
   string ENC(S).

   An element (x,y) of E is encoded as a b-bit string called ENC(x,y),
   which is the (b-1)-bit encoding of y concatenated with one bit that
   is 1 if x is negative and 0 if x is not negative.

   The encoding of GF(p) is used to define "negative" elements of GF(p):
   specifically, x is negative if the (b-1)-bit encoding of x is
   lexicographically larger than the (b-1)-bit encoding of -x.

3.2.  Keys

   An EdDSA private key is a b-bit string k.  Let the hash H(k) =
   (h_0, h_1, ..., h_(2b-1)) determine an integer s, which is 2^n plus
   the sum of m = 2^i * h_i for all integer i, c <= i < n.  Let s
   determine the multiple A = [s]B.  The EdDSA public key is ENC(A).
   The bits h_b, ..., h_(2b-1) are used below during signing.



Josefsson & Liusvaara         Informational                     [Page 7]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


3.3.  Sign

   The EdDSA signature of a message M under a private key k is defined
   as the PureEdDSA signature of PH(M).  In other words, EdDSA simply
   uses PureEdDSA to sign PH(M).

   The PureEdDSA signature of a message M under a private key k is the
   2*b-bit string ENC(R) || ENC(S).  R and S are derived as follows.
   First define r = H(h_b || ... || h_(2b-1) || M) interpreting 2*b-bit
   strings in little-endian form as integers in {0, 1, ..., 2^(2*b) -
   1}.  Let R = [r]B and S = (r + H(ENC(R) || ENC(A) || PH(M)) * s) mod
   L.  The s used here is from the previous section.

3.4.  Verify

   To verify a PureEdDSA signature ENC(R) || ENC(S) on a message M under
   a public key ENC(A), proceed as follows.  Parse the inputs so that A
   and R are elements of E, and S is a member of the set {0, 1, ...,
   L-1}.  Compute h = H(ENC(R) || ENC(A) || M), and check the group
   equation [2^c * S] B = 2^c * R + [2^c * h] A in E.  The signature is
   rejected if parsing fails (including S being out of range) or if the
   group equation does not hold.

   EdDSA verification for a message M is defined as PureEdDSA
   verification for PH(M).

4.  PureEdDSA, HashEdDSA, and Naming

   One of the parameters of the EdDSA algorithm is the "prehash"
   function.  This may be the identity function, resulting in an
   algorithm called PureEdDSA, or a collision-resistant hash function
   such as SHA-512, resulting in an algorithm called HashEdDSA.

   Choosing which variant to use depends on which property is deemed to
   be more important between 1) collision resilience and 2) a single-
   pass interface for creating signatures.  The collision resilience
   property means EdDSA is secure even if it is feasible to compute
   collisions for the hash function.  The single-pass interface property
   means that only one pass over the input message is required to create
   a signature.  PureEdDSA requires two passes over the input.  Many
   existing APIs, protocols, and environments assume digital signature
   algorithms only need one pass over the input and may have API or
   bandwidth concerns supporting anything else.

   Note that single-pass verification is not possible with most uses of
   signatures, no matter which signature algorithm is chosen.  This is
   because most of the time, one can't process the message until the
   signature is validated, which needs a pass on the entire message.



Josefsson & Liusvaara         Informational                     [Page 8]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   This document specifies parameters resulting in the HashEdDSA
   variants Ed25519ph and Ed448ph and the PureEdDSA variants Ed25519 and
   Ed448.

5.  EdDSA Instances

   This section instantiates the general EdDSA algorithm for the
   edwards25519 and edwards448 curves, each for the PureEdDSA and
   HashEdDSA variants (plus a contextualized extension of the Ed25519
   scheme).  Thus, five different parameter sets are described.

5.1.  Ed25519ph, Ed25519ctx, and Ed25519

   Ed25519 is EdDSA instantiated with:

   +-----------+-------------------------------------------------------+
   | Parameter | Value                                                 |
   +-----------+-------------------------------------------------------+
   |     p     | p of edwards25519 in [RFC7748] (i.e., 2^255 - 19)     |
   |     b     | 256                                                   |
   |  encoding | 255-bit little-endian encoding of {0, 1, ..., p-1}    |
   |  of GF(p) |                                                       |
   |    H(x)   | SHA-512(dom2(phflag,context)||x) [RFC6234]            |
   |     c     | base 2 logarithm of cofactor of edwards25519 in       |
   |           | [RFC7748] (i.e., 3)                                   |
   |     n     | 254                                                   |
   |     d     | d of edwards25519 in [RFC7748] (i.e., -121665/121666  |
   |           | = 370957059346694393431380835087545651895421138798432 |
   |           | 19016388785533085940283555)                           |
   |     a     | -1                                                    |
   |     B     | (X(P),Y(P)) of edwards25519 in [RFC7748] (i.e., (1511 |
   |           | 22213495354007725011514095885315114540126930418572060 |
   |           | 46113283949847762202, 4631683569492647816942839400347 |
   |           | 5163141307993866256225615783033603165251855960))      |
   |     L     | order of edwards25519 in [RFC7748] (i.e.,             |
   |           | 2^252+27742317777372353535851937790883648493).        |
   |   PH(x)   | x (i.e., the identity function)                       |
   +-----------+-------------------------------------------------------+

                      Table 1: Parameters of Ed25519

   For Ed25519, dom2(f,c) is the empty string.  The phflag value is
   irrelevant.  The context (if present at all) MUST be empty.  This
   causes the scheme to be one and the same with the Ed25519 scheme
   published earlier.

   For Ed25519ctx, phflag=0.  The context input SHOULD NOT be empty.




Josefsson & Liusvaara         Informational                     [Page 9]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   For Ed25519ph, phflag=1 and PH is SHA512 instead.  That is, the input
   is hashed using SHA-512 before signing with Ed25519.

   Value of context is set by the signer and verifier (maximum of 255
   octets; the default is empty string, except for Ed25519, which can't
   have context) and has to match octet by octet for verification to be
   successful.

   The curve used is equivalent to Curve25519 [CURVE25519], under a
   change of coordinates, which means that the difficulty of the
   discrete logarithm problem is the same as for Curve25519.

5.1.1.  Modular Arithmetic

   For advice on how to implement arithmetic modulo p = 2^255 - 19
   efficiently and securely, see Curve25519 [CURVE25519].  For inversion
   modulo p, it is recommended to use the identity x^-1 = x^(p-2) (mod
   p).  Inverting zero should never happen, as it would require invalid
   input, which would have been detected before, or would be a
   calculation error.

   For point decoding or "decompression", square roots modulo p are
   needed.  They can be computed using the Tonelli-Shanks algorithm or
   the special case for p = 5 (mod 8).  To find a square root of a,
   first compute the candidate root x = a^((p+3)/8) (mod p).  Then there
   are three cases:

      x^2 = a (mod p).  Then x is a square root.

      x^2 = -a (mod p).  Then 2^((p-1)/4) * x is a square root.

      a is not a square modulo p.

5.1.2.  Encoding

   All values are coded as octet strings, and integers are coded using
   little-endian convention, i.e., a 32-octet string h h[0],...h[31]
   represents the integer h[0] + 2^8 * h[1] + ... + 2^248 * h[31].

   A curve point (x,y), with coordinates in the range 0 <= x,y < p, is
   coded as follows.  First, encode the y-coordinate as a little-endian
   string of 32 octets.  The most significant bit of the final octet is
   always zero.  To form the encoding of the point, copy the least
   significant bit of the x-coordinate to the most significant bit of
   the final octet.






Josefsson & Liusvaara         Informational                    [Page 10]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


5.1.3.  Decoding

   Decoding a point, given as a 32-octet string, is a little more
   complicated.

   1.  First, interpret the string as an integer in little-endian
       representation.  Bit 255 of this number is the least significant
       bit of the x-coordinate and denote this value x_0.  The
       y-coordinate is recovered simply by clearing this bit.  If the
       resulting value is >= p, decoding fails.

   2.  To recover the x-coordinate, the curve equation implies
       x^2 = (y^2 - 1) / (d y^2 + 1) (mod p).  The denominator is always
       non-zero mod p.  Let u = y^2 - 1 and v = d y^2 + 1.  To compute
       the square root of (u/v), the first step is to compute the
       candidate root x = (u/v)^((p+3)/8).  This can be done with the
       following trick, using a single modular powering for both the
       inversion of v and the square root:

                          (p+3)/8      3        (p-5)/8
                 x = (u/v)        = u v  (u v^7)         (mod p)

   3.  Again, there are three cases:

       1.  If v x^2 = u (mod p), x is a square root.

       2.  If v x^2 = -u (mod p), set x <-- x * 2^((p-1)/4), which is a
           square root.

       3.  Otherwise, no square root exists for modulo p, and decoding
           fails.

   4.  Finally, use the x_0 bit to select the right square root.  If
       x = 0, and x_0 = 1, decoding fails.  Otherwise, if x_0 != x mod
       2, set x <-- p - x.  Return the decoded point (x,y).

5.1.4.  Point Addition

   For point addition, the following method is recommended.  A point
   (x,y) is represented in extended homogeneous coordinates (X, Y, Z,
   T), with x = X/Z, y = Y/Z, x * y = T/Z.

   The neutral point is (0,1), or equivalently in extended homogeneous
   coordinates (0, Z, Z, 0) for any non-zero Z.







Josefsson & Liusvaara         Informational                    [Page 11]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   The following formulas for adding two points, (x3,y3) =
   (x1,y1)+(x2,y2), on twisted Edwards curves with a=-1, square a, and
   non-square d are described in Section 3.1 of [Edwards-revisited] and
   in [EFD-TWISTED-ADD].  They are complete, i.e., they work for any
   pair of valid input points.

                 A = (Y1-X1)*(Y2-X2)
                 B = (Y1+X1)*(Y2+X2)
                 C = T1*2*d*T2
                 D = Z1*2*Z2
                 E = B-A
                 F = D-C
                 G = D+C
                 H = B+A
                 X3 = E*F
                 Y3 = G*H
                 T3 = E*H
                 Z3 = F*G

   For point doubling, (x3,y3) = (x1,y1)+(x1,y1), one could just
   substitute equal points in the above (because of completeness, such
   substitution is valid) and observe that four multiplications turn
   into squares.  However, using the formulas described in Section 3.2
   of [Edwards-revisited] and in [EFD-TWISTED-DBL] saves a few smaller
   operations.

                 A = X1^2
                 B = Y1^2
                 C = 2*Z1^2
                 H = A+B
                 E = H-(X1+Y1)^2
                 G = A-B
                 F = C+G
                 X3 = E*F
                 Y3 = G*H
                 T3 = E*H
                 Z3 = F*G














Josefsson & Liusvaara         Informational                    [Page 12]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


5.1.5.  Key Generation

   The private key is 32 octets (256 bits, corresponding to b) of
   cryptographically secure random data.  See [RFC4086] for a discussion
   about randomness.

   The 32-byte public key is generated by the following steps.

   1.  Hash the 32-byte private key using SHA-512, storing the digest in
       a 64-octet large buffer, denoted h.  Only the lower 32 bytes are
       used for generating the public key.

   2.  Prune the buffer: The lowest three bits of the first octet are
       cleared, the highest bit of the last octet is cleared, and the
       second highest bit of the last octet is set.

   3.  Interpret the buffer as the little-endian integer, forming a
       secret scalar s.  Perform a fixed-base scalar multiplication
       [s]B.

   4.  The public key A is the encoding of the point [s]B.  First,
       encode the y-coordinate (in the range 0 <= y < p) as a little-
       endian string of 32 octets.  The most significant bit of the
       final octet is always zero.  To form the encoding of the point
       [s]B, copy the least significant bit of the x coordinate to the
       most significant bit of the final octet.  The result is the
       public key.

5.1.6.  Sign

   The inputs to the signing procedure is the private key, a 32-octet
   string, and a message M of arbitrary size.  For Ed25519ctx and
   Ed25519ph, there is additionally a context C of at most 255 octets
   and a flag F, 0 for Ed25519ctx and 1 for Ed25519ph.

   1.  Hash the private key, 32 octets, using SHA-512.  Let h denote the
       resulting digest.  Construct the secret scalar s from the first
       half of the digest, and the corresponding public key A, as
       described in the previous section.  Let prefix denote the second
       half of the hash digest, h[32],...,h[63].

   2.  Compute SHA-512(dom2(F, C) || prefix || PH(M)), where M is the
       message to be signed.  Interpret the 64-octet digest as a little-
       endian integer r.

   3.  Compute the point [r]B.  For efficiency, do this by first
       reducing r modulo L, the group order of B.  Let the string R be
       the encoding of this point.



Josefsson & Liusvaara         Informational                    [Page 13]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   4.  Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the
       64-octet digest as a little-endian integer k.

   5.  Compute S = (r + k * s) mod L.  For efficiency, again reduce k
       modulo L first.

   6.  Form the signature of the concatenation of R (32 octets) and the
       little-endian encoding of S (32 octets; the three most
       significant bits of the final octet are always zero).

5.1.7.  Verify

   1.  To verify a signature on a message M using public key A, with F
       being 0 for Ed25519ctx, 1 for Ed25519ph, and if Ed25519ctx or
       Ed25519ph is being used, C being the context, first split the
       signature into two 32-octet halves.  Decode the first half as a
       point R, and the second half as an integer S, in the range
       0 <= s < L.  Decode the public key A as point A'.  If any of the
       decodings fail (including S being out of range), the signature is
       invalid.

   2.  Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the
       64-octet digest as a little-endian integer k.

   3.  Check the group equation [8][S]B = [8]R + [8][k]A'.  It's
       sufficient, but not required, to instead check [S]B = R + [k]A'.

























Josefsson & Liusvaara         Informational                    [Page 14]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


5.2.  Ed448ph and Ed448

   Ed448 is EdDSA instantiated with:

   +-----------+-------------------------------------------------------+
   | Parameter | Value                                                 |
   +-----------+-------------------------------------------------------+
   |     p     | p of edwards448 in [RFC7748] (i.e., 2^448 - 2^224 -   |
   |           | 1)                                                    |
   |     b     | 456                                                   |
   |  encoding | 455-bit little-endian encoding of {0, 1, ..., p-1}    |
   |  of GF(p) |                                                       |
   |    H(x)   | SHAKE256(dom4(phflag,context)||x, 114)                |
   |   phflag  | 0                                                     |
   |     c     | base 2 logarithm of cofactor of edwards448 in         |
   |           | [RFC7748] (i.e., 2)                                   |
   |     n     | 447                                                   |
   |     d     | d of edwards448 in [RFC7748] (i.e., -39081)           |
   |     a     | 1                                                     |
   |     B     | (X(P),Y(P)) of edwards448 in [RFC7748] (i.e., (224580 |
   |           | 04029592430018760433409989603624678964163256413424612 |
   |           | 54616869504154674060329090291928693579532825780320751 |
   |           | 46446173674602635247710, 2988192100784814926760179304 |
   |           | 43930673437544040154080242095928241372331506189835876 |
   |           | 00353687865541878473398230323350346250053154506283266 |
   |           | 0))                                                   |
   |     L     | order of edwards448 in [RFC7748] (i.e., 2^446 - 13818 |
   |           | 06680989511535200738674851542688033669247488217860989 |
   |           | 4547503885).                                          |
   |   PH(x)   | x (i.e., the identity function)                       |
   +-----------+-------------------------------------------------------+

                       Table 2: Parameters of Ed448

   Ed448ph is the same but with PH being SHAKE256(x, 64) and phflag
   being 1, i.e., the input is hashed before signing with Ed448 with a
   hash constant modified.

   Value of context is set by signer and verifier (maximum of 255
   octets; the default is empty string) and has to match octet by octet
   for verification to be successful.

   The curve is equivalent to Ed448-Goldilocks under change of the
   basepoint, which preserves difficulty of the discrete logarithm.







Josefsson & Liusvaara         Informational                    [Page 15]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


5.2.1.  Modular Arithmetic

   For advice on how to implement arithmetic modulo p = 2^448 - 2^224 -
   1 efficiently and securely, see [ED448].  For inversion modulo p, it
   is recommended to use the identity x^-1 = x^(p-2) (mod p).  Inverting
   zero should never happen, as it would require invalid input, which
   would have been detected before, or would be a calculation error.

   For point decoding or "decompression", square roots modulo p are
   needed.  They can be computed by first computing candidate root
   x = a ^ (p+1)/4 (mod p) and then checking if x^2 = a.  If it is, then
   x is the square root of a; if it isn't, then a does not have a square
   root.

5.2.2.  Encoding

   All values are coded as octet strings, and integers are coded using
   little-endian convention, i.e., a 57-octet string h h[0],...h[56]
   represents the integer h[0] + 2^8 * h[1] + ... + 2^448 * h[56].

   A curve point (x,y), with coordinates in the range 0 <= x,y < p, is
   coded as follows.  First, encode the y-coordinate as a little-endian
   string of 57 octets.  The final octet is always zero.  To form the
   encoding of the point, copy the least significant bit of the
   x-coordinate to the most significant bit of the final octet.

5.2.3.  Decoding

   Decoding a point, given as a 57-octet string, is a little more
   complicated.

   1.  First, interpret the string as an integer in little-endian
       representation.  Bit 455 of this number is the least significant
       bit of the x-coordinate, and denote this value x_0.  The
       y-coordinate is recovered simply by clearing this bit.  If the
       resulting value is >= p, decoding fails.

   2.  To recover the x-coordinate, the curve equation implies
       x^2 = (y^2 - 1) / (d y^2 - 1) (mod p).  The denominator is always
       non-zero mod p.  Let u = y^2 - 1 and v = d y^2 - 1.  To compute
       the square root of (u/v), the first step is to compute the
       candidate root x = (u/v)^((p+1)/4).  This can be done using the
       following trick, to use a single modular powering for both the
       inversion of v and the square root:

                          (p+1)/4    3            (p-3)/4
                 x = (u/v)        = u  v (u^5 v^3)         (mod p)




Josefsson & Liusvaara         Informational                    [Page 16]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   3.  If v * x^2 = u, the recovered x-coordinate is x.  Otherwise, no
       square root exists, and the decoding fails.

   4.  Finally, use the x_0 bit to select the right square root.  If
       x = 0, and x_0 = 1, decoding fails.  Otherwise, if x_0 != x mod
       2, set x <-- p - x.  Return the decoded point (x,y).

5.2.4.  Point Addition

   For point addition, the following method is recommended.  A point
   (x,y) is represented in projective coordinates (X, Y, Z), with
   x = X/Z, y = Y/Z.

   The neutral point is (0,1), or equivalently in projective coordinates
   (0, Z, Z) for any non-zero Z.

   The following formulas for adding two points, (x3,y3) =
   (x1,y1)+(x2,y2) on untwisted Edwards curve (i.e., a=1) with non-
   square d, are described in Section 4 of [Faster-ECC] and in
   [EFD-ADD].  They are complete, i.e., they work for any pair of valid
   input points.

                 A = Z1*Z2
                 B = A^2
                 C = X1*X2
                 D = Y1*Y2
                 E = d*C*D
                 F = B-E
                 G = B+E
                 H = (X1+Y1)*(X2+Y2)
                 X3 = A*F*(H-C-D)
                 Y3 = A*G*(D-C)
                 Z3 = F*G


















Josefsson & Liusvaara         Informational                    [Page 17]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   Again, similar to the other curve, doubling formulas can be obtained
   by substituting equal points, turning four multiplications into
   squares.  However, this is not even nearly optimal; the following
   formulas described in Section 4 of [Faster-ECC] and in [EFD-DBL] save
   multiple multiplications.

                 B = (X1+Y1)^2
                 C = X1^2
                 D = Y1^2
                 E = C+D
                 H = Z1^2
                 J = E-2*H
                 X3 = (B-E)*J
                 Y3 = E*(C-D)
                 Z3 = E*J

5.2.5.  Key Generation

   The private key is 57 octets (456 bits, corresponding to b) of
   cryptographically secure random data.  See [RFC4086] for a discussion
   about randomness.

   The 57-byte public key is generated by the following steps:

   1.  Hash the 57-byte private key using SHAKE256(x, 114), storing the
       digest in a 114-octet large buffer, denoted h.  Only the lower 57
       bytes are used for generating the public key.

   2.  Prune the buffer: The two least significant bits of the first
       octet are cleared, all eight bits the last octet are cleared, and
       the highest bit of the second to last octet is set.

   3.  Interpret the buffer as the little-endian integer, forming a
       secret scalar s.  Perform a known-base-point scalar
       multiplication [s]B.

   4.  The public key A is the encoding of the point [s]B.  First encode
       the y-coordinate (in the range 0 <= y < p) as a little-endian
       string of 57 octets.  The most significant bit of the final octet
       is always zero.  To form the encoding of the point [s]B, copy the
       least significant bit of the x coordinate to the most significant
       bit of the final octet.  The result is the public key.









Josefsson & Liusvaara         Informational                    [Page 18]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


5.2.6.  Sign

   The inputs to the signing procedure is the private key, a 57-octet
   string, a flag F, which is 0 for Ed448, 1 for Ed448ph, context C of
   at most 255 octets, and a message M of arbitrary size.

   1.  Hash the private key, 57 octets, using SHAKE256(x, 114).  Let h
       denote the resulting digest.  Construct the secret scalar s from
       the first half of the digest, and the corresponding public key A,
       as described in the previous section.  Let prefix denote the
       second half of the hash digest, h[57],...,h[113].

   2.  Compute SHAKE256(dom4(F, C) || prefix || PH(M), 114), where M is
       the message to be signed, F is 1 for Ed448ph, 0 for Ed448, and C
       is the context to use.  Interpret the 114-octet digest as a
       little-endian integer r.

   3.  Compute the point [r]B.  For efficiency, do this by first
       reducing r modulo L, the group order of B.  Let the string R be
       the encoding of this point.

   4.  Compute SHAKE256(dom4(F, C) || R || A || PH(M), 114), and
       interpret the 114-octet digest as a little-endian integer k.

   5.  Compute S = (r + k * s) mod L.  For efficiency, again reduce k
       modulo L first.

   6.  Form the signature of the concatenation of R (57 octets) and the
       little-endian encoding of S (57 octets; the ten most significant
       bits of the final octets are always zero).

5.2.7.  Verify

   1.  To verify a signature on a message M using context C and public
       key A, with F being 0 for Ed448 and 1 for Ed448ph, first split
       the signature into two 57-octet halves.  Decode the first half as
       a point R, and the second half as an integer S, in the range 0 <=
       s < L.  Decode the public key A as point A'.  If any of the
       decodings fail (including S being out of range), the signature is
       invalid.

   2.  Compute SHAKE256(dom4(F, C) || R || A || PH(M), 114), and
       interpret the 114-octet digest as a little-endian integer k.

   3.  Check the group equation [4][S]B = [4]R + [4][k]A'.  It's
       sufficient, but not required, to instead check [S]B = R + [k]A'.





Josefsson & Liusvaara         Informational                    [Page 19]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


6.  Ed25519 Python Illustration

   The rest of this section describes how Ed25519 can be implemented in
   Python (version 3.2 or later) for illustration.  See Appendix A for
   the complete implementation and Appendix B for a test-driver to run
   it through some test vectors.

   Note that this code is not intended for production as it is not
   proven to be correct for all inputs, nor does it protect against
   side-channel attacks.  The purpose is to illustrate the algorithm to
   help implementers with their own implementation.

## First, some preliminaries that will be needed.

import hashlib

def sha512(s):
    return hashlib.sha512(s).digest()

# Base field Z_p
p = 2**255 - 19

def modp_inv(x):
    return pow(x, p-2, p)

# Curve constant
d = -121665 * modp_inv(121666) % p

# Group order
q = 2**252 + 27742317777372353535851937790883648493

def sha512_modq(s):
    return int.from_bytes(sha512(s), "little") % q

## Then follows functions to perform point operations.

# Points are represented as tuples (X, Y, Z, T) of extended
# coordinates, with x = X/Z, y = Y/Z, x*y = T/Z

def point_add(P, Q):
    A, B = (P[1]-P[0]) * (Q[1]-Q[0]) % p, (P[1]+P[0]) * (Q[1]+Q[0]) % p;
    C, D = 2 * P[3] * Q[3] * d % p, 2 * P[2] * Q[2] % p;
    E, F, G, H = B-A, D-C, D+C, B+A;
    return (E*F, G*H, F*G, E*H);







Josefsson & Liusvaara         Informational                    [Page 20]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


# Computes Q = s * Q
def point_mul(s, P):
    Q = (0, 1, 1, 0)  # Neutral element
    while s > 0:
        if s & 1:
            Q = point_add(Q, P)
        P = point_add(P, P)
        s >>= 1
    return Q

def point_equal(P, Q):
    # x1 / z1 == x2 / z2  <==>  x1 * z2 == x2 * z1
    if (P[0] * Q[2] - Q[0] * P[2]) % p != 0:
        return False
    if (P[1] * Q[2] - Q[1] * P[2]) % p != 0:
        return False
    return True

## Now follows functions for point compression.

# Square root of -1
modp_sqrt_m1 = pow(2, (p-1) // 4, p)

# Compute corresponding x-coordinate, with low bit corresponding to
# sign, or return None on failure
def recover_x(y, sign):
    if y >= p:
        return None
    x2 = (y*y-1) * modp_inv(d*y*y+1)
    if x2 == 0:
        if sign:
            return None
        else:
            return 0

    # Compute square root of x2
    x = pow(x2, (p+3) // 8, p)
    if (x*x - x2) % p != 0:
        x = x * modp_sqrt_m1 % p
    if (x*x - x2) % p != 0:
        return None

    if (x & 1) != sign:
        x = p - x
    return x






Josefsson & Liusvaara         Informational                    [Page 21]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


# Base point
g_y = 4 * modp_inv(5) % p
g_x = recover_x(g_y, 0)
G = (g_x, g_y, 1, g_x * g_y % p)

def point_compress(P):
    zinv = modp_inv(P[2])
    x = P[0] * zinv % p
    y = P[1] * zinv % p
    return int.to_bytes(y | ((x & 1) << 255), 32, "little")

def point_decompress(s):
    if len(s) != 32:
        raise Exception("Invalid input length for decompression")
    y = int.from_bytes(s, "little")
    sign = y >> 255
    y &= (1 << 255) - 1

    x = recover_x(y, sign)
    if x is None:
        return None
    else:
        return (x, y, 1, x*y % p)

## These are functions for manipulating the private key.

def secret_expand(secret):
    if len(secret) != 32:
        raise Exception("Bad size of private key")
    h = sha512(secret)
    a = int.from_bytes(h[:32], "little")
    a &= (1 << 254) - 8
    a |= (1 << 254)
    return (a, h[32:])

def secret_to_public(secret):
    (a, dummy) = secret_expand(secret)
    return point_compress(point_mul(a, G))













Josefsson & Liusvaara         Informational                    [Page 22]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


## The signature function works as below.

def sign(secret, msg):
    a, prefix = secret_expand(secret)
    A = point_compress(point_mul(a, G))
    r = sha512_modq(prefix + msg)
    R = point_mul(r, G)
    Rs = point_compress(R)
    h = sha512_modq(Rs + A + msg)
    s = (r + h * a) % q
    return Rs + int.to_bytes(s, 32, "little")

## And finally the verification function.

def verify(public, msg, signature):
    if len(public) != 32:
        raise Exception("Bad public key length")
    if len(signature) != 64:
        Exception("Bad signature length")
    A = point_decompress(public)
    if not A:
        return False
    Rs = signature[:32]
    R = point_decompress(Rs)
    if not R:
        return False
    s = int.from_bytes(signature[32:], "little")
    if s >= q: return False
    h = sha512_modq(Rs + public + msg)
    sB = point_mul(s, G)
    hA = point_mul(h, A)
    return point_equal(sB, point_add(R, hA))

7.  Test Vectors

   This section contains test vectors for Ed25519ph, Ed25519ctx,
   Ed448ph, Ed25519, and Ed448.

   Each section contains a sequence of test vectors.  The octets are hex
   encoded, and whitespace is inserted for readability.  Ed25519,
   Ed25519ctx, and Ed25519ph private and public keys are 32 octets;
   signatures are 64 octets.  Ed448 and Ed448ph private and public keys
   are 57 octets; signatures are 114 octets.  Messages are of arbitrary
   length.  If the context is non-empty, it is given as 1-255 octets.







Josefsson & Liusvaara         Informational                    [Page 23]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


7.1.  Test Vectors for Ed25519

   These test vectors are taken from [ED25519-TEST-VECTORS] (but we
   removed the public key as a suffix of the private key and removed the
   message from the signature) and [ED25519-LIBGCRYPT-TEST-VECTORS].

   -----TEST 1

   ALGORITHM:
   Ed25519

   SECRET KEY:
   9d61b19deffd5a60ba844af492ec2cc4
   4449c5697b326919703bac031cae7f60

   PUBLIC KEY:
   d75a980182b10ab7d54bfed3c964073a
   0ee172f3daa62325af021a68f707511a

   MESSAGE (length 0 bytes):

   SIGNATURE:
   e5564300c360ac729086e2cc806e828a
   84877f1eb8e5d974d873e06522490155
   5fb8821590a33bacc61e39701cf9b46b
   d25bf5f0595bbe24655141438e7a100b

   -----TEST 2

   ALGORITHM:
   Ed25519

   SECRET KEY:
   4ccd089b28ff96da9db6c346ec114e0f
   5b8a319f35aba624da8cf6ed4fb8a6fb

   PUBLIC KEY:
   3d4017c3e843895a92b70aa74d1b7ebc
   9c982ccf2ec4968cc0cd55f12af4660c

   MESSAGE (length 1 byte):
   72

   SIGNATURE:
   92a009a9f0d4cab8720e820b5f642540
   a2b27b5416503f8fb3762223ebdb69da
   085ac1e43e15996e458f3613d0f11d8c
   387b2eaeb4302aeeb00d291612bb0c00



Josefsson & Liusvaara         Informational                    [Page 24]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   -----TEST 3

   ALGORITHM:
   Ed25519

   SECRET KEY:
   c5aa8df43f9f837bedb7442f31dcb7b1
   66d38535076f094b85ce3a2e0b4458f7

   PUBLIC KEY:
   fc51cd8e6218a1a38da47ed00230f058
   0816ed13ba3303ac5deb911548908025

   MESSAGE (length 2 bytes):
   af82

   SIGNATURE:
   6291d657deec24024827e69c3abe01a3
   0ce548a284743a445e3680d7db5ac3ac
   18ff9b538d16f290ae67f760984dc659
   4a7c15e9716ed28dc027beceea1ec40a

   -----TEST 1024

   ALGORITHM:
   Ed25519

   SECRET KEY:
   f5e5767cf153319517630f226876b86c
   8160cc583bc013744c6bf255f5cc0ee5

   PUBLIC KEY:
   278117fc144c72340f67d0f2316e8386
   ceffbf2b2428c9c51fef7c597f1d426e

   MESSAGE (length 1023 bytes):
   08b8b2b733424243760fe426a4b54908
   632110a66c2f6591eabd3345e3e4eb98
   fa6e264bf09efe12ee50f8f54e9f77b1
   e355f6c50544e23fb1433ddf73be84d8
   79de7c0046dc4996d9e773f4bc9efe57
   38829adb26c81b37c93a1b270b20329d
   658675fc6ea534e0810a4432826bf58c
   941efb65d57a338bbd2e26640f89ffbc
   1a858efcb8550ee3a5e1998bd177e93a
   7363c344fe6b199ee5d02e82d522c4fe
   ba15452f80288a821a579116ec6dad2b
   3b310da903401aa62100ab5d1a36553e



Josefsson & Liusvaara         Informational                    [Page 25]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   06203b33890cc9b832f79ef80560ccb9
   a39ce767967ed628c6ad573cb116dbef
   efd75499da96bd68a8a97b928a8bbc10
   3b6621fcde2beca1231d206be6cd9ec7
   aff6f6c94fcd7204ed3455c68c83f4a4
   1da4af2b74ef5c53f1d8ac70bdcb7ed1
   85ce81bd84359d44254d95629e9855a9
   4a7c1958d1f8ada5d0532ed8a5aa3fb2
   d17ba70eb6248e594e1a2297acbbb39d
   502f1a8c6eb6f1ce22b3de1a1f40cc24
   554119a831a9aad6079cad88425de6bd
   e1a9187ebb6092cf67bf2b13fd65f270
   88d78b7e883c8759d2c4f5c65adb7553
   878ad575f9fad878e80a0c9ba63bcbcc
   2732e69485bbc9c90bfbd62481d9089b
   eccf80cfe2df16a2cf65bd92dd597b07
   07e0917af48bbb75fed413d238f5555a
   7a569d80c3414a8d0859dc65a46128ba
   b27af87a71314f318c782b23ebfe808b
   82b0ce26401d2e22f04d83d1255dc51a
   ddd3b75a2b1ae0784504df543af8969b
   e3ea7082ff7fc9888c144da2af58429e
   c96031dbcad3dad9af0dcbaaaf268cb8
   fcffead94f3c7ca495e056a9b47acdb7
   51fb73e666c6c655ade8297297d07ad1
   ba5e43f1bca32301651339e22904cc8c
   42f58c30c04aafdb038dda0847dd988d
   cda6f3bfd15c4b4c4525004aa06eeff8
   ca61783aacec57fb3d1f92b0fe2fd1a8
   5f6724517b65e614ad6808d6f6ee34df
   f7310fdc82aebfd904b01e1dc54b2927
   094b2db68d6f903b68401adebf5a7e08
   d78ff4ef5d63653a65040cf9bfd4aca7
   984a74d37145986780fc0b16ac451649
   de6188a7dbdf191f64b5fc5e2ab47b57
   f7f7276cd419c17a3ca8e1b939ae49e4
   88acba6b965610b5480109c8b17b80e1
   b7b750dfc7598d5d5011fd2dcc5600a3
   2ef5b52a1ecc820e308aa342721aac09
   43bf6686b64b2579376504ccc493d97e
   6aed3fb0f9cd71a43dd497f01f17c0e2
   cb3797aa2a2f256656168e6c496afc5f
   b93246f6b1116398a346f1a641f3b041
   e989f7914f90cc2c7fff357876e506b5
   0d334ba77c225bc307ba537152f3f161
   0e4eafe595f6d9d90d11faa933a15ef1
   369546868a7f3a45a96768d40fd9d034
   12c091c6315cf4fde7cb68606937380d



Josefsson & Liusvaara         Informational                    [Page 26]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   b2eaaa707b4c4185c32eddcdd306705e
   4dc1ffc872eeee475a64dfac86aba41c
   0618983f8741c5ef68d3a101e8a3b8ca
   c60c905c15fc910840b94c00a0b9d0

   SIGNATURE:
   0aab4c900501b3e24d7cdf4663326a3a
   87df5e4843b2cbdb67cbf6e460fec350
   aa5371b1508f9f4528ecea23c436d94b
   5e8fcd4f681e30a6ac00a9704a188a03

   -----TEST SHA(abc)

   ALGORITHM:
   Ed25519

   SECRET KEY:
   833fe62409237b9d62ec77587520911e
   9a759cec1d19755b7da901b96dca3d42

   PUBLIC KEY:
   ec172b93ad5e563bf4932c70e1245034
   c35467ef2efd4d64ebf819683467e2bf

   MESSAGE (length 64 bytes):
   ddaf35a193617abacc417349ae204131
   12e6fa4e89a97ea20a9eeee64b55d39a
   2192992a274fc1a836ba3c23a3feebbd
   454d4423643ce80e2a9ac94fa54ca49f

   SIGNATURE:
   dc2a4459e7369633a52b1bf277839a00
   201009a3efbf3ecb69bea2186c26b589
   09351fc9ac90b3ecfdfbc7c66431e030
   3dca179c138ac17ad9bef1177331a704
   -----

7.2.  Test Vectors for Ed25519ctx

   -----foo

   ALGORITHM:
   Ed25519ctx

   SECRET KEY:
   0305334e381af78f141cb666f6199f57
   bc3495335a256a95bd2a55bf546663f6




Josefsson & Liusvaara         Informational                    [Page 27]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   PUBLIC KEY:
   dfc9425e4f968f7f0c29f0259cf5f9ae
   d6851c2bb4ad8bfb860cfee0ab248292

   MESSAGE (length 16 bytes):
   f726936d19c800494e3fdaff20b276a8

   CONTEXT:
   666f6f

   SIGNATURE:
   55a4cc2f70a54e04288c5f4cd1e45a7b
   b520b36292911876cada7323198dd87a
   8b36950b95130022907a7fb7c4e9b2d5
   f6cca685a587b4b21f4b888e4e7edb0d

   -----bar

   ALGORITHM:
   Ed25519ctx

   SECRET KEY:
   0305334e381af78f141cb666f6199f57
   bc3495335a256a95bd2a55bf546663f6

   PUBLIC KEY:
   dfc9425e4f968f7f0c29f0259cf5f9ae
   d6851c2bb4ad8bfb860cfee0ab248292

   MESSAGE (length 16 bytes):
   f726936d19c800494e3fdaff20b276a8

   CONTEXT:
   626172

   SIGNATURE:
   fc60d5872fc46b3aa69f8b5b4351d580
   8f92bcc044606db097abab6dbcb1aee3
   216c48e8b3b66431b5b186d1d28f8ee1
   5a5ca2df6668346291c2043d4eb3e90d

   -----foo2

   ALGORITHM:
   Ed25519ctx






Josefsson & Liusvaara         Informational                    [Page 28]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SECRET KEY:
   0305334e381af78f141cb666f6199f57
   bc3495335a256a95bd2a55bf546663f6

   PUBLIC KEY:
   dfc9425e4f968f7f0c29f0259cf5f9ae
   d6851c2bb4ad8bfb860cfee0ab248292

   MESSAGE (length 16 bytes):
   508e9e6882b979fea900f62adceaca35

   CONTEXT:
   666f6f

   SIGNATURE:
   8b70c1cc8310e1de20ac53ce28ae6e72
   07f33c3295e03bb5c0732a1d20dc6490
   8922a8b052cf99b7c4fe107a5abb5b2c
   4085ae75890d02df26269d8945f84b0b

   -----foo3

   ALGORITHM:
   Ed25519ctx

   SECRET KEY:
   ab9c2853ce297ddab85c993b3ae14bca
   d39b2c682beabc27d6d4eb20711d6560

   PUBLIC KEY:
   0f1d1274943b91415889152e893d80e9
   3275a1fc0b65fd71b4b0dda10ad7d772

   MESSAGE (length 16 bytes):
   f726936d19c800494e3fdaff20b276a8

   CONTEXT:
   666f6f

   SIGNATURE:
   21655b5f1aa965996b3f97b3c849eafb
   a922a0a62992f73b3d1b73106a84ad85
   e9b86a7b6005ea868337ff2d20a7f5fb
   d4cd10b0be49a68da2b2e0dc0ad8960f
   -----






Josefsson & Liusvaara         Informational                    [Page 29]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


7.3.  Test Vectors for Ed25519ph

   -----TEST abc

   ALGORITHM:
   Ed25519ph

   SECRET KEY:
   833fe62409237b9d62ec77587520911e
   9a759cec1d19755b7da901b96dca3d42

   PUBLIC KEY:
   ec172b93ad5e563bf4932c70e1245034
   c35467ef2efd4d64ebf819683467e2bf

   MESSAGE (length 3 bytes):
   616263

   SIGNATURE:
   98a70222f0b8121aa9d30f813d683f80
   9e462b469c7ff87639499bb94e6dae41
   31f85042463c2a355a2003d062adf5aa
   a10b8c61e636062aaad11c2a26083406
   -----

7.4.  Test Vectors for Ed448

   -----Blank

   ALGORITHM:
   Ed448

   SECRET KEY:
   6c82a562cb808d10d632be89c8513ebf
   6c929f34ddfa8c9f63c9960ef6e348a3
   528c8a3fcc2f044e39a3fc5b94492f8f
   032e7549a20098f95b

   PUBLIC KEY:
   5fd7449b59b461fd2ce787ec616ad46a
   1da1342485a70e1f8a0ea75d80e96778
   edf124769b46c7061bd6783df1e50f6c
   d1fa1abeafe8256180

   MESSAGE (length 0 bytes):






Josefsson & Liusvaara         Informational                    [Page 30]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SIGNATURE:
   533a37f6bbe457251f023c0d88f976ae
   2dfb504a843e34d2074fd823d41a591f
   2b233f034f628281f2fd7a22ddd47d78
   28c59bd0a21bfd3980ff0d2028d4b18a
   9df63e006c5d1c2d345b925d8dc00b41
   04852db99ac5c7cdda8530a113a0f4db
   b61149f05a7363268c71d95808ff2e65
   2600

   -----1 octet

   ALGORITHM:
   Ed448

   SECRET KEY:
   c4eab05d357007c632f3dbb48489924d
   552b08fe0c353a0d4a1f00acda2c463a
   fbea67c5e8d2877c5e3bc397a659949e
   f8021e954e0a12274e

   PUBLIC KEY:
   43ba28f430cdff456ae531545f7ecd0a
   c834a55d9358c0372bfa0c6c6798c086
   6aea01eb00742802b8438ea4cb82169c
   235160627b4c3a9480

   MESSAGE (length 1 byte):
   03

   SIGNATURE:
   26b8f91727bd62897af15e41eb43c377
   efb9c610d48f2335cb0bd0087810f435
   2541b143c4b981b7e18f62de8ccdf633
   fc1bf037ab7cd779805e0dbcc0aae1cb
   cee1afb2e027df36bc04dcecbf154336
   c19f0af7e0a6472905e799f1953d2a0f
   f3348ab21aa4adafd1d234441cf807c0
   3a00

   -----1 octet (with context)

   ALGORITHM:
   Ed448







Josefsson & Liusvaara         Informational                    [Page 31]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SECRET KEY:
   c4eab05d357007c632f3dbb48489924d
   552b08fe0c353a0d4a1f00acda2c463a
   fbea67c5e8d2877c5e3bc397a659949e
   f8021e954e0a12274e

   PUBLIC KEY:
   43ba28f430cdff456ae531545f7ecd0a
   c834a55d9358c0372bfa0c6c6798c086
   6aea01eb00742802b8438ea4cb82169c
   235160627b4c3a9480

   MESSAGE (length 1 byte):
   03

   CONTEXT:
   666f6f

   SIGNATURE:
   d4f8f6131770dd46f40867d6fd5d5055
   de43541f8c5e35abbcd001b32a89f7d2
   151f7647f11d8ca2ae279fb842d60721
   7fce6e042f6815ea000c85741de5c8da
   1144a6a1aba7f96de42505d7a7298524
   fda538fccbbb754f578c1cad10d54d0d
   5428407e85dcbc98a49155c13764e66c
   3c00

   -----11 octets

   ALGORITHM:
   Ed448

   SECRET KEY:
   cd23d24f714274e744343237b93290f5
   11f6425f98e64459ff203e8985083ffd
   f60500553abc0e05cd02184bdb89c4cc
   d67e187951267eb328

   PUBLIC KEY:
   dcea9e78f35a1bf3499a831b10b86c90
   aac01cd84b67a0109b55a36e9328b1e3
   65fce161d71ce7131a543ea4cb5f7e9f
   1d8b00696447001400

   MESSAGE (length 11 bytes):
   0c3e544074ec63b0265e0c




Josefsson & Liusvaara         Informational                    [Page 32]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SIGNATURE:
   1f0a8888ce25e8d458a21130879b840a
   9089d999aaba039eaf3e3afa090a09d3
   89dba82c4ff2ae8ac5cdfb7c55e94d5d
   961a29fe0109941e00b8dbdeea6d3b05
   1068df7254c0cdc129cbe62db2dc957d
   bb47b51fd3f213fb8698f064774250a5
   028961c9bf8ffd973fe5d5c206492b14
   0e00

   -----12 octets

   ALGORITHM:
   Ed448

   SECRET KEY:
   258cdd4ada32ed9c9ff54e63756ae582
   fb8fab2ac721f2c8e676a72768513d93
   9f63dddb55609133f29adf86ec9929dc
   cb52c1c5fd2ff7e21b

   PUBLIC KEY:
   3ba16da0c6f2cc1f30187740756f5e79
   8d6bc5fc015d7c63cc9510ee3fd44adc
   24d8e968b6e46e6f94d19b945361726b
   d75e149ef09817f580

   MESSAGE (length 12 bytes):
   64a65f3cdedcdd66811e2915

   SIGNATURE:
   7eeeab7c4e50fb799b418ee5e3197ff6
   bf15d43a14c34389b59dd1a7b1b85b4a
   e90438aca634bea45e3a2695f1270f07
   fdcdf7c62b8efeaf00b45c2c96ba457e
   b1a8bf075a3db28e5c24f6b923ed4ad7
   47c3c9e03c7079efb87cb110d3a99861
   e72003cbae6d6b8b827e4e6c143064ff
   3c00

   -----13 octets

   ALGORITHM:
   Ed448







Josefsson & Liusvaara         Informational                    [Page 33]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SECRET KEY:
   7ef4e84544236752fbb56b8f31a23a10
   e42814f5f55ca037cdcc11c64c9a3b29
   49c1bb60700314611732a6c2fea98eeb
   c0266a11a93970100e

   PUBLIC KEY:
   b3da079b0aa493a5772029f0467baebe
   e5a8112d9d3a22532361da294f7bb381
   5c5dc59e176b4d9f381ca0938e13c6c0
   7b174be65dfa578e80

   MESSAGE (length 13 bytes):
   64a65f3cdedcdd66811e2915e7

   SIGNATURE:
   6a12066f55331b6c22acd5d5bfc5d712
   28fbda80ae8dec26bdd306743c5027cb
   4890810c162c027468675ecf645a8317
   6c0d7323a2ccde2d80efe5a1268e8aca
   1d6fbc194d3f77c44986eb4ab4177919
   ad8bec33eb47bbb5fc6e28196fd1caf5
   6b4e7e0ba5519234d047155ac727a105
   3100

   -----64 octets

   ALGORITHM:
   Ed448

   SECRET KEY:
   d65df341ad13e008567688baedda8e9d
   cdc17dc024974ea5b4227b6530e339bf
   f21f99e68ca6968f3cca6dfe0fb9f4fa
   b4fa135d5542ea3f01

   PUBLIC KEY:
   df9705f58edbab802c7f8363cfe5560a
   b1c6132c20a9f1dd163483a26f8ac53a
   39d6808bf4a1dfbd261b099bb03b3fb5
   0906cb28bd8a081f00

   MESSAGE (length 64 bytes):
   bd0f6a3747cd561bdddf4640a332461a
   4a30a12a434cd0bf40d766d9c6d458e5
   512204a30c17d1f50b5079631f64eb31
   12182da3005835461113718d1a5ef944




Josefsson & Liusvaara         Informational                    [Page 34]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SIGNATURE:
   554bc2480860b49eab8532d2a533b7d5
   78ef473eeb58c98bb2d0e1ce488a98b1
   8dfde9b9b90775e67f47d4a1c3482058
   efc9f40d2ca033a0801b63d45b3b722e
   f552bad3b4ccb667da350192b61c508c
   f7b6b5adadc2c8d9a446ef003fb05cba
   5f30e88e36ec2703b349ca229c267083
   3900

   -----256 octets

   ALGORITHM:
   Ed448

   SECRET KEY:
   2ec5fe3c17045abdb136a5e6a913e32a
   b75ae68b53d2fc149b77e504132d3756
   9b7e766ba74a19bd6162343a21c8590a
   a9cebca9014c636df5

   PUBLIC KEY:
   79756f014dcfe2079f5dd9e718be4171
   e2ef2486a08f25186f6bff43a9936b9b
   fe12402b08ae65798a3d81e22e9ec80e
   7690862ef3d4ed3a00

   MESSAGE (length 256 bytes):
   15777532b0bdd0d1389f636c5f6b9ba7
   34c90af572877e2d272dd078aa1e567c
   fa80e12928bb542330e8409f31745041
   07ecd5efac61ae7504dabe2a602ede89
   e5cca6257a7c77e27a702b3ae39fc769
   fc54f2395ae6a1178cab4738e543072f
   c1c177fe71e92e25bf03e4ecb72f47b6
   4d0465aaea4c7fad372536c8ba516a60
   39c3c2a39f0e4d832be432dfa9a706a6
   e5c7e19f397964ca4258002f7c0541b5
   90316dbc5622b6b2a6fe7a4abffd9610
   5eca76ea7b98816af0748c10df048ce0
   12d901015a51f189f3888145c03650aa
   23ce894c3bd889e030d565071c59f409
   a9981b51878fd6fc110624dcbcde0bf7
   a69ccce38fabdf86f3bef6044819de11







Josefsson & Liusvaara         Informational                    [Page 35]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SIGNATURE:
   c650ddbb0601c19ca11439e1640dd931
   f43c518ea5bea70d3dcde5f4191fe53f
   00cf966546b72bcc7d58be2b9badef28
   743954e3a44a23f880e8d4f1cfce2d7a
   61452d26da05896f0a50da66a239a8a1
   88b6d825b3305ad77b73fbac0836ecc6
   0987fd08527c1a8e80d5823e65cafe2a
   3d00

   -----1023 octets

   ALGORITHM:
   Ed448

   SECRET KEY:
   872d093780f5d3730df7c212664b37b8
   a0f24f56810daa8382cd4fa3f77634ec
   44dc54f1c2ed9bea86fafb7632d8be19
   9ea165f5ad55dd9ce8

   PUBLIC KEY:
   a81b2e8a70a5ac94ffdbcc9badfc3feb
   0801f258578bb114ad44ece1ec0e799d
   a08effb81c5d685c0c56f64eecaef8cd
   f11cc38737838cf400

   MESSAGE (length 1023 bytes):
   6ddf802e1aae4986935f7f981ba3f035
   1d6273c0a0c22c9c0e8339168e675412
   a3debfaf435ed651558007db4384b650
   fcc07e3b586a27a4f7a00ac8a6fec2cd
   86ae4bf1570c41e6a40c931db27b2faa
   15a8cedd52cff7362c4e6e23daec0fbc
   3a79b6806e316efcc7b68119bf46bc76
   a26067a53f296dafdbdc11c77f7777e9
   72660cf4b6a9b369a6665f02e0cc9b6e
   dfad136b4fabe723d2813db3136cfde9
   b6d044322fee2947952e031b73ab5c60
   3349b307bdc27bc6cb8b8bbd7bd32321
   9b8033a581b59eadebb09b3c4f3d2277
   d4f0343624acc817804728b25ab79717
   2b4c5c21a22f9c7839d64300232eb66e
   53f31c723fa37fe387c7d3e50bdf9813
   a30e5bb12cf4cd930c40cfb4e1fc6225
   92a49588794494d56d24ea4b40c89fc0
   596cc9ebb961c8cb10adde976a5d602b
   1c3f85b9b9a001ed3c6a4d3b1437f520



Josefsson & Liusvaara         Informational                    [Page 36]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   96cd1956d042a597d561a596ecd3d173
   5a8d570ea0ec27225a2c4aaff26306d1
   526c1af3ca6d9cf5a2c98f47e1c46db9
   a33234cfd4d81f2c98538a09ebe76998
   d0d8fd25997c7d255c6d66ece6fa56f1
   1144950f027795e653008f4bd7ca2dee
   85d8e90f3dc315130ce2a00375a318c7
   c3d97be2c8ce5b6db41a6254ff264fa6
   155baee3b0773c0f497c573f19bb4f42
   40281f0b1f4f7be857a4e59d416c06b4
   c50fa09e1810ddc6b1467baeac5a3668
   d11b6ecaa901440016f389f80acc4db9
   77025e7f5924388c7e340a732e554440
   e76570f8dd71b7d640b3450d1fd5f041
   0a18f9a3494f707c717b79b4bf75c984
   00b096b21653b5d217cf3565c9597456
   f70703497a078763829bc01bb1cbc8fa
   04eadc9a6e3f6699587a9e75c94e5bab
   0036e0b2e711392cff0047d0d6b05bd2
   a588bc109718954259f1d86678a579a3
   120f19cfb2963f177aeb70f2d4844826
   262e51b80271272068ef5b3856fa8535
   aa2a88b2d41f2a0e2fda7624c2850272
   ac4a2f561f8f2f7a318bfd5caf969614
   9e4ac824ad3460538fdc25421beec2cc
   6818162d06bbed0c40a387192349db67
   a118bada6cd5ab0140ee273204f628aa
   d1c135f770279a651e24d8c14d75a605
   9d76b96a6fd857def5e0b354b27ab937
   a5815d16b5fae407ff18222c6d1ed263
   be68c95f32d908bd895cd76207ae7264
   87567f9a67dad79abec316f683b17f2d
   02bf07e0ac8b5bc6162cf94697b3c27c
   d1fea49b27f23ba2901871962506520c
   392da8b6ad0d99f7013fbc06c2c17a56
   9500c8a7696481c1cd33e9b14e40b82e
   79a5f5db82571ba97bae3ad3e0479515
   bb0e2b0f3bfcd1fd33034efc6245eddd
   7ee2086ddae2600d8ca73e214e8c2b0b
   db2b047c6a464a562ed77b73d2d841c4
   b34973551257713b753632efba348169
   abc90a68f42611a40126d7cb21b58695
   568186f7e569d2ff0f9e745d0487dd2e
   b997cafc5abf9dd102e62ff66cba87







Josefsson & Liusvaara         Informational                    [Page 37]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SIGNATURE:
   e301345a41a39a4d72fff8df69c98075
   a0cc082b802fc9b2b6bc503f926b65bd
   df7f4c8f1cb49f6396afc8a70abe6d8a
   ef0db478d4c6b2970076c6a0484fe76d
   76b3a97625d79f1ce240e7c576750d29
   5528286f719b413de9ada3e8eb78ed57
   3603ce30d8bb761785dc30dbc320869e
   1a00
   -----

7.5.  Test Vectors for Ed448ph

   -----TEST abc

   ALGORITHM:
   Ed448ph

   SECRET KEY:
   833fe62409237b9d62ec77587520911e
   9a759cec1d19755b7da901b96dca3d42
   ef7822e0d5104127dc05d6dbefde69e3
   ab2cec7c867c6e2c49

   PUBLIC KEY:
   259b71c19f83ef77a7abd26524cbdb31
   61b590a48f7d17de3ee0ba9c52beb743
   c09428a131d6b1b57303d90d8132c276
   d5ed3d5d01c0f53880

   MESSAGE (length 3 bytes):
   616263

   SIGNATURE:
   822f6901f7480f3d5f562c592994d969
   3602875614483256505600bbc281ae38
   1f54d6bce2ea911574932f52a4e6cadd
   78769375ec3ffd1b801a0d9b3f4030cd
   433964b6457ea39476511214f97469b5
   7dd32dbc560a9a94d00bff07620464a3
   ad203df7dc7ce360c3cd3696d9d9fab9
   0f00









Josefsson & Liusvaara         Informational                    [Page 38]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   -----TEST abc (with context)

   ALGORITHM:
   Ed448ph

   SECRET KEY:
   833fe62409237b9d62ec77587520911e
   9a759cec1d19755b7da901b96dca3d42
   ef7822e0d5104127dc05d6dbefde69e3
   ab2cec7c867c6e2c49

   PUBLIC KEY:
   259b71c19f83ef77a7abd26524cbdb31
   61b590a48f7d17de3ee0ba9c52beb743
   c09428a131d6b1b57303d90d8132c276
   d5ed3d5d01c0f53880

   MESSAGE (length 3 bytes):
   616263

   CONTEXT:
   666f6f

   SIGNATURE:
   c32299d46ec8ff02b54540982814dce9
   a05812f81962b649d528095916a2aa48
   1065b1580423ef927ecf0af5888f90da
   0f6a9a85ad5dc3f280d91224ba9911a3
   653d00e484e2ce232521481c8658df30
   4bb7745a73514cdb9bf3e15784ab7128
   4f8d0704a608c54a6b62d97beb511d13
   2100
   -----


















Josefsson & Liusvaara         Informational                    [Page 39]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


8.  Security Considerations

8.1.  Side-Channel Leaks

   For implementations performing signatures, secrecy of the private key
   is fundamental.  It is possible to protect against some side-channel
   attacks by ensuring that the implementation executes exactly the same
   sequence of instructions and performs exactly the same memory
   accesses, for any value of the private key.

   To make an implementation side-channel silent in this way, the modulo
   p arithmetic must not use any data-dependent branches, e.g., related
   to carry propagation.  Side-channel silent point addition is
   straightforward, thanks to the unified formulas.

   Scalar multiplication, multiplying a point by an integer, needs some
   additional effort to implement in a side-channel silent manner.  One
   simple approach is to implement a side-channel silent conditional
   assignment, and use it together with the binary algorithm to examine
   one bit of the integer at a time.

   Compared to other signature schemes, avoiding data-dependent branches
   is easier due to side-channel silent modulo p arithmetic being easier
   (with recommended curves) and having complete addition formulas
   instead of having a number of special cases.

   Note that the example implementations in this document do not attempt
   to be side-channel silent.

8.2.  Randomness Considerations

   EdDSA signatures are deterministic.  This protects against attacks
   arising from signing with bad randomness; the effects of which can,
   depending on the algorithm, range up to full private key compromise.
   It can be surprisingly hard to ensure good-quality random numbers,
   and there have been numerous security failures relating to this.

   Obviously, private key generation requires randomness, but due to the
   fact that the private key is hashed before use, a few missing bits of
   entropy doesn't constitute a disaster.

   The basic signature verification is also deterministic.  However,
   some speedups by verifying multiple signatures at once do require
   random numbers.







Josefsson & Liusvaara         Informational                    [Page 40]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


8.3.  Use of Contexts

   Contexts can be used to separate uses of the protocol between
   different protocols (which is very hard to reliably do otherwise) and
   between different uses within the same protocol.  However, the
   following SHOULD be kept in mind when using this facility:

      The context SHOULD be a constant string specified by the protocol
      using it.  It SHOULD NOT incorporate variable elements from the
      message itself.

      Contexts SHOULD NOT be used opportunistically, as that kind of use
      is very error prone.  If contexts are used, one SHOULD require all
      signature schemes available for use in that purpose support
      contexts.

      Contexts are an extra input, which percolate out of APIs; as such,
      even if the signature scheme supports contexts, those may not be
      available for use.  This problem is compounded by the fact that
      many times the application is not invoking the signing and
      verification functions directly but via some other protocol.

8.4.  Signature Malleability

   Some systems assume signatures are not malleable: that is, given a
   valid signature for some message under some key, the attacker can't
   produce another valid signature for the same message and key.

   Ed25519 and Ed448 signatures are not malleable due to the
   verification check that decoded S is smaller than l.  Without this
   check, one can add a multiple of l into a scalar part and still pass
   signature verification, resulting in malleable signatures.

8.5.  Choice of Signature Primitive

   Ed25519 and Ed25519ph have a nominal strength of 128 bits, whereas
   Ed448 and Ed448ph have the strength of 224.  While the lower strength
   is sufficient for the foreseeable future, the higher level brings
   some defense against possible future cryptographic advances.  Both
   are demolished by quantum computers just about the same.

   The Ed25519ph and Ed448ph variants are prehashed.  This is mainly
   useful for interoperation with legacy APIs, since in most of the
   cases, either the amount of data signed is not large or the protocol
   is in the position to do digesting in ways better than just
   prehashing (e.g., tree hashing or splitting the data).  The





Josefsson & Liusvaara         Informational                    [Page 41]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   prehashing also makes the functions greatly more vulnerable to
   weaknesses in hash functions used.  These variants SHOULD NOT be
   used.

   Ed25519ctx and Ed448 have contexts.  However, this is balanced by the
   problems noted in Section 8.3 about contexts.

   On the implementation front, Ed25519 is widely implemented and has
   many high-quality implementations.  The others have much worse
   support.

   In summary, if a high 128-bit security level is enough, use of
   Ed25519 is RECOMMENDED; otherwise, Ed448 is RECOMMENDED.

8.6.  Mixing Different Prehashes

   The schemes described in this document are designed to be resistant
   to mixing prehashes.  That is, it is infeasible to find a message
   that verifies using the same signature under another scheme, even if
   the original signed message was chosen.  Thus, one can use the same
   key pair for Ed25519, Ed25519ctx, and Ed25519ph and correspondingly
   with Ed448 and Ed448ph.

   The "SigEd25519 no Ed25519 collisions" constant is chosen to be a
   textual string such that it does not decode as a point.  Because the
   inner hash input in the Ed25519 signature always starts with a valid
   point, there is no way trivial collision can be constructed.  In the
   case of seed hash, trivial collisions are so unlikely, even with an
   attacker choosing all inputs, that it is much more probable that
   something else goes catastrophically wrong.

8.7.  Signing Large Amounts of Data at Once

   Avoid signing large amounts of data at once (where "large" depends on
   the expected verifier).  In particular, unless the underlying
   protocol does not require it, the receiver MUST buffer the entire
   message (or enough information to reconstruct it, e.g., compressed or
   encrypted version) to be verified.

   This is needed because most of the time, it is unsafe to process
   unverified data, and verifying the signature makes a pass through the
   whole message, causing ultimately at least two passes through.

   As an API consideration, this means that any Initialize Update
   Finalize (IFU) verification interface is prone to misuse.






Josefsson & Liusvaara         Informational                    [Page 42]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   It is a bad idea to modify Ed25519 or Ed448 signing to be able to
   create valid Ed25519/Ed448 signatures using an IUF interface with
   only constant buffering.  Pretty much any error in such would cause
   catastrophic security failure.

8.8.  Multiplication by Cofactor in Verification

   The given verification formulas for both Ed25519 and Ed448 multiply
   points by the cofactor.  While this is not strictly necessary for
   security (in fact, any signature that meets the non-multiplied
   equation will satisfy the multiplied one), in some applications it is
   undesirable for implementations to disagree about the exact set of
   valid signatures.  Such disagreements could open up, e.g.,
   fingerprinting attacks.

8.9.  Use of SHAKE256 as a Hash Function

   Ed448 uses SHAKE256 as a hash function, even if SHAKE256 is
   specifically defined not to be a hash function.

   The first potentially troublesome property is that shorter outputs
   are prefixes of longer ones.  This is acceptable because output
   lengths are fixed.

   The second potentially troublesome property is failing to meet
   standard hash security notions (especially with preimages).  However,
   the estimated 256-bit security level against collisions and preimages
   is sufficient to pair with a 224-bit level elliptic curve.

9.  References

9.1.  Normative References

   [FIPS202]  National Institute of Standards and Technology, "SHA-3
              Standard: Permutation-Based Hash and Extendable-Output
              Functions", FIPS PUB 202, August 2015,
              <http://dx.doi.org/10.6028/NIST.FIPS.202>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, DOI
              10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <http://www.rfc-editor.org/info/rfc6234>.




Josefsson & Liusvaara         Informational                    [Page 43]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <http://www.rfc-editor.org/info/rfc7748>.

9.2.  Informative References

   [CURVE25519]
              Bernstein, D., "Curve25519: new Diffie-Hellman speed
              records", DOI 10.1007/11745853_14, February 2006,
              <http://cr.yp.to/ecdh.html>.

   [ED25519-LIBGCRYPT-TEST-VECTORS]
              Koch, W., "Ed25519 Libgcrypt test vectors", July 2014,
              <http://git.gnupg.org/cgi-bin/
              gitweb.cgi?p=libgcrypt.git;a=blob;f=tests/t-ed25519.inp;
              h=e13566f826321eece65e02c593bc7d885b3dbe23;hb=refs/
              heads/master>.

   [ED25519-TEST-VECTORS]
              Bernstein, D., Duif, N., Lange, T., Schwabe, P., and B.
              Yang, "Ed25519 test vectors", July 2011,
              <http://ed25519.cr.yp.to/python/sign.input>.

   [ED448]    Hamburg, M., "Ed448-Goldilocks, a new elliptic curve",
              June 2015, <http://eprint.iacr.org/2015/625>.

   [EDDSA]    Bernstein, D., Duif, N., Lange, T., Schwabe, P., and B.
              Yang, "High-speed high-security signatures",
              DOI 10.1007/978-3-642-23951-9_9, September 2011,
              <http://ed25519.cr.yp.to/ed25519-20110926.pdf>.

   [EDDSA2]   Bernstein, D., Josefsson, S., Lange, T., Schwabe, P., and
              B. Yang, "EdDSA for more curves", July 2015,
              <http://ed25519.cr.yp.to/eddsa-20150704.pdf>.

   [Edwards-revisited]
              Hisil, H., Wong, K., Carter, G., and E. Dawson, "Twisted
              Edwards Curves Revisited",
              DOI 10.1007/978-3-540-89255-7_20, December 2008,
              <http://eprint.iacr.org/2008/522>.

   [EFD-ADD]  Bernstein, D. and T. Lange, "Projective coordinates for
              Edwards curves", The 'add-2007-bl' addition formulas,
              2007, <http://www.hyperelliptic.org/EFD/g1p/
              auto-edwards-projective.html#addition-add-2007-bl>.






Josefsson & Liusvaara         Informational                    [Page 44]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   [EFD-DBL]  Bernstein, D. and T. Lange, "Projective coordinates for
              Edwards curves", The 'dbl-2007-bl' doubling formulas,
              2007, <http://www.hyperelliptic.org/EFD/g1p/
              auto-edwards-projective.html#doubling-dbl-2007-bl>.

   [EFD-TWISTED-ADD]
              Hisil, H., Wong, K., Carter, G., and E. Dawson, "Extended
              coordinates with a=-1 for twisted Edwards curves", The
              'add-2008-hwcd-3' addition formulas, December 2008,
              <http://www.hyperelliptic.org/EFD/g1p/
              auto-twisted-extended-1.html#addition-add-2008-hwcd-3>.

   [EFD-TWISTED-DBL]
              Hisil, H., Wong, K., Carter, G., and E. Dawson, "Extended
              coordinates with a=-1 for twisted Edwards curves", The
              'dbl-2008-hwcd' doubling formulas, December 2008,
              <http://www.hyperelliptic.org/EFD/g1p/
              auto-twisted-extended-1.html#doubling-dbl-2008-hwcd>.

   [Faster-ECC]
              Bernstein, D. and T. Lange, "Faster addition and doubling
              on elliptic curves", DOI 10.1007/978-3-540-76900-2_3,
              July 2007, <http://eprint.iacr.org/2007/286>.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <http://www.rfc-editor.org/info/rfc4086>.























Josefsson & Liusvaara         Informational                    [Page 45]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


Appendix A.  Ed25519/Ed448 Python Library

   Below is an example implementation of Ed25519/Ed448 written in
   Python; version 3.2 or higher is required.

   Note: This code is not intended for production.  Although it should
   produce correct results for every input, it is slow and makes no
   attempt to avoid side-channel attacks.

import hashlib;
import os;

#Compute candidate square root of x modulo p, with p = 3 (mod 4).
def sqrt4k3(x,p): return pow(x,(p + 1)//4,p)

#Compute candidate square root of x modulo p, with p = 5 (mod 8).
def sqrt8k5(x,p):
    y = pow(x,(p+3)//8,p)
    #If the square root exists, it is either y or y*2^(p-1)/4.
    if (y * y) % p == x % p: return y
    else:
        z = pow(2,(p - 1)//4,p)
        return (y * z) % p

#Decode a hexadecimal string representation of the integer.
def hexi(s): return int.from_bytes(bytes.fromhex(s),byteorder="big")

#Rotate a word x by b places to the left.
def rol(x,b): return ((x << b) | (x >> (64 - b))) & (2**64-1)

#From little endian.
def from_le(s): return int.from_bytes(s, byteorder="little")

#Do the SHA-3 state transform on state s.
def sha3_transform(s):
    ROTATIONS = [0,1,62,28,27,36,44,6,55,20,3,10,43,25,39,41,45,15,\
                 21,8,18,2,61,56,14]
    PERMUTATION = [1,6,9,22,14,20,2,12,13,19,23,15,4,24,21,8,16,5,3,\
                   18,17,11,7,10]
    RC = [0x0000000000000001,0x0000000000008082,0x800000000000808a,\
          0x8000000080008000,0x000000000000808b,0x0000000080000001,\
          0x8000000080008081,0x8000000000008009,0x000000000000008a,\
          0x0000000000000088,0x0000000080008009,0x000000008000000a,\
          0x000000008000808b,0x800000000000008b,0x8000000000008089,\
          0x8000000000008003,0x8000000000008002,0x8000000000000080,\
          0x000000000000800a,0x800000008000000a,0x8000000080008081,\
          0x8000000000008080,0x0000000080000001,0x8000000080008008]




Josefsson & Liusvaara         Informational                    [Page 46]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    for rnd in range(0,24):
        #AddColumnParity (Theta)
        c = [0]*5;
        d = [0]*5;
        for i in range(0,25): c[i%5]^=s[i]
        for i in range(0,5): d[i]=c[(i+4)%5]^rol(c[(i+1)%5],1)
        for i in range(0,25): s[i]^=d[i%5]
        #RotateWords (Rho)
        for i in range(0,25): s[i]=rol(s[i],ROTATIONS[i])
        #PermuteWords (Pi)
        t = s[PERMUTATION[0]]
        for i in range(0,len(PERMUTATION)-1):
            s[PERMUTATION[i]]=s[PERMUTATION[i+1]]
        s[PERMUTATION[-1]]=t;
        #NonlinearMixRows (Chi)
        for i in range(0,25,5):
            t=[s[i],s[i+1],s[i+2],s[i+3],s[i+4],s[i],s[i+1]]
            for j in range(0,5): s[i+j]=t[j]^((~t[j+1])&(t[j+2]))
        #AddRoundConstant (Iota)
        s[0]^=RC[rnd]

#Reinterpret octet array b to word array and XOR it to state s.
def reinterpret_to_words_and_xor(s,b):
    for j in range(0,len(b)//8):
        s[j]^=from_le(b[8*j:][:8])

#Reinterpret word array w to octet array and return it.
def reinterpret_to_octets(w):
    mp=bytearray()
    for j in range(0,len(w)):
        mp+=w[j].to_bytes(8,byteorder="little")
    return mp



















Josefsson & Liusvaara         Informational                    [Page 47]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


#(semi-)generic SHA-3 implementation
def sha3_raw(msg,r_w,o_p,e_b):
    r_b=8*r_w
    s=[0]*25
    #Handle whole blocks.
    idx=0
    blocks=len(msg)//r_b
    for i in range(0,blocks):
        reinterpret_to_words_and_xor(s,msg[idx:][:r_b])
        idx+=r_b
        sha3_transform(s)
    #Handle last block padding.
    m=bytearray(msg[idx:])
    m.append(o_p)
    while len(m) < r_b: m.append(0)
    m[len(m)-1]|=128
    #Handle padded last block.
    reinterpret_to_words_and_xor(s,m)
    sha3_transform(s)
    #Output.
    out = bytearray()
    while len(out)<e_b:
        out+=reinterpret_to_octets(s[:r_w])
        sha3_transform(s)
    return out[:e_b]

#Implementation of SHAKE256 functions.
def shake256(msg,olen): return sha3_raw(msg,17,31,olen)























Josefsson & Liusvaara         Informational                    [Page 48]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


#A (prime) field element.
class Field:
    #Construct number x (mod p).
    def __init__(self,x,p):
        self.__x=x%p
        self.__p=p
    #Check that fields of self and y are the same.
    def __check_fields(self,y):
        if type(y) is not Field or self.__p!=y.__p:
            raise ValueError("Fields don't match")
    #Field addition.  The fields must match.
    def __add__(self,y):
        self.__check_fields(y)
        return Field(self.__x+y.__x,self.__p)
    #Field subtraction.  The fields must match.
    def __sub__(self,y):
        self.__check_fields(y)
        return Field(self.__p+self.__x-y.__x,self.__p)
    #Field negation.
    def __neg__(self):
        return Field(self.__p-self.__x,self.__p)
    #Field multiplication.  The fields must match.
    def __mul__(self,y):
        self.__check_fields(y)
        return Field(self.__x*y.__x,self.__p)
    #Field division.  The fields must match.
    def __truediv__(self,y):
        return self*y.inv()
    #Field inverse (inverse of 0 is 0).
    def inv(self):
        return Field(pow(self.__x,self.__p-2,self.__p),self.__p)
    #Field square root.  Returns none if square root does not exist.
    #Note: not presently implemented for p mod 8 = 1 case.
    def sqrt(self):
        #Compute candidate square root.
        if self.__p%4==3: y=sqrt4k3(self.__x,self.__p)
        elif self.__p%8==5: y=sqrt8k5(self.__x,self.__p)
        else: raise NotImplementedError("sqrt(_,8k+1)")
        _y=Field(y,self.__p);
        #Check square root candidate valid.
        return _y if _y*_y==self else None
    #Make the field element with the same field as this, but
    #with a different value.
    def make(self,ival): return Field(ival,self.__p)
    #Is the field element the additive identity?
    def iszero(self): return self.__x==0
    #Are field elements equal?
    def __eq__(self,y): return self.__x==y.__x and self.__p==y.__p



Josefsson & Liusvaara         Informational                    [Page 49]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    #Are field elements not equal?
    def __ne__(self,y): return not (self==y)
    #Serialize number to b-1 bits.
    def tobytes(self,b):
        return self.__x.to_bytes(b//8,byteorder="little")
    #Unserialize number from bits.
    def frombytes(self,x,b):
        rv=from_le(x)%(2**(b-1))
        return Field(rv,self.__p) if rv<self.__p else None
    #Compute sign of number, 0 or 1.  The sign function
    #has the following property:
    #sign(x) = 1 - sign(-x) if x != 0.
    def sign(self): return self.__x%2

#A point on (twisted) Edwards curve.
class EdwardsPoint:
    #base_field = None
    #x = None
    #y = None
    #z = None
    def initpoint(self, x, y):
        self.x=x
        self.y=y
        self.z=self.base_field.make(1)
    def decode_base(self,s,b):
        #Check that point encoding is the correct length.
        if len(s)!=b//8: return (None,None)
        #Extract signbit.
        xs=s[(b-1)//8]>>((b-1)&7)
        #Decode y.  If this fails, fail.
        y = self.base_field.frombytes(s,b)
        if y is None: return (None,None)
        #Try to recover x.  If it does not exist, or if zero and xs
        #are wrong, fail.
        x=self.solve_x2(y).sqrt()
        if x is None or (x.iszero() and xs!=x.sign()):
            return (None,None)
        #If sign of x isn't correct, flip it.
        if x.sign()!=xs: x=-x
        # Return the constructed point.
        return (x,y)
    def encode_base(self,b):
        xp,yp=self.x/self.z,self.y/self.z
        #Encode y.
        s=bytearray(yp.tobytes(b))
        #Add sign bit of x to encoding.
        if xp.sign()!=0: s[(b-1)//8]|=1<<(b-1)%8
        return s



Josefsson & Liusvaara         Informational                    [Page 50]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    def __mul__(self,x):
        r=self.zero_elem()
        s=self
        while x > 0:
            if (x%2)>0:
                r=r+s
            s=s.double()
            x=x//2
        return r
    #Check that two points are equal.
    def __eq__(self,y):
        #Need to check x1/z1 == x2/z2 and similarly for y, so cross
        #multiply to eliminate divisions.
        xn1=self.x*y.z
        xn2=y.x*self.z
        yn1=self.y*y.z
        yn2=y.y*self.z
        return xn1==xn2 and yn1==yn2
    #Check if two points are not equal.
    def __ne__(self,y): return not (self==y)

#A point on Edwards25519.
class Edwards25519Point(EdwardsPoint):
    #Create a new point on the curve.
    base_field=Field(1,2**255-19)
    d=-base_field.make(121665)/base_field.make(121666)
    f0=base_field.make(0)
    f1=base_field.make(1)
    xb=base_field.make(hexi("216936D3CD6E53FEC0A4E231FDD6DC5C692CC76"+\
        "09525A7B2C9562D608F25D51A"))
    yb=base_field.make(hexi("666666666666666666666666666666666666666"+\
        "6666666666666666666666658"))
    #The standard base point.
    @staticmethod
    def stdbase():
        return Edwards25519Point(Edwards25519Point.xb,\
            Edwards25519Point.yb)
    def __init__(self,x,y):
        #Check the point is actually on the curve.
        if y*y-x*x!=self.f1+self.d*x*x*y*y:
            raise ValueError("Invalid point")
        self.initpoint(x, y)
        self.t=x*y
    #Decode a point representation.
    def decode(self,s):
        x,y=self.decode_base(s,256);
        return Edwards25519Point(x, y) if x is not None else None




Josefsson & Liusvaara         Informational                    [Page 51]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    #Encode a point representation.
    def encode(self):
        return self.encode_base(256)
    #Construct a neutral point on this curve.
    def zero_elem(self):
        return Edwards25519Point(self.f0,self.f1)
    #Solve for x^2.
    def solve_x2(self,y):
        return ((y*y-self.f1)/(self.d*y*y+self.f1))
    #Point addition.
    def __add__(self,y):
        #The formulas are from EFD.
        tmp=self.zero_elem()
        zcp=self.z*y.z
        A=(self.y-self.x)*(y.y-y.x)
        B=(self.y+self.x)*(y.y+y.x)
        C=(self.d+self.d)*self.t*y.t
        D=zcp+zcp
        E,H=B-A,B+A
        F,G=D-C,D+C
        tmp.x,tmp.y,tmp.z,tmp.t=E*F,G*H,F*G,E*H
        return tmp
    #Point doubling.
    def double(self):
        #The formulas are from EFD (with assumption a=-1 propagated).
        tmp=self.zero_elem()
        A=self.x*self.x
        B=self.y*self.y
        Ch=self.z*self.z
        C=Ch+Ch
        H=A+B
        xys=self.x+self.y
        E=H-xys*xys
        G=A-B
        F=C+G
        tmp.x,tmp.y,tmp.z,tmp.t=E*F,G*H,F*G,E*H
        return tmp
    #Order of basepoint.
    def l(self):
        return hexi("1000000000000000000000000000000014def9dea2f79cd"+\
            "65812631a5cf5d3ed")
    #The logarithm of cofactor.
    def c(self): return 3
    #The highest set bit
    def n(self): return 254
    #The coding length
    def b(self): return 256




Josefsson & Liusvaara         Informational                    [Page 52]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    #Validity check (for debugging)
    def is_valid_point(self):
        x,y,z,t=self.x,self.y,self.z,self.t
        x2=x*x
        y2=y*y
        z2=z*z
        lhs=(y2-x2)*z2
        rhs=z2*z2+self.d*x2*y2
        assert(lhs == rhs)
        assert(t*z == x*y)

#A point on Edwards448.
class Edwards448Point(EdwardsPoint):
    #Create a new point on the curve.
    base_field=Field(1,2**448-2**224-1)
    d=base_field.make(-39081)
    f0=base_field.make(0)
    f1=base_field.make(1)
    xb=base_field.make(hexi("4F1970C66BED0DED221D15A622BF36DA9E14657"+\
        "0470F1767EA6DE324A3D3A46412AE1AF72AB66511433B80E18B00938E26"+\
        "26A82BC70CC05E"))
    yb=base_field.make(hexi("693F46716EB6BC248876203756C9C7624BEA737"+\
        "36CA3984087789C1E05A0C2D73AD3FF1CE67C39C4FDBD132C4ED7C8AD98"+\
        "08795BF230FA14"))
    #The standard base point.
    @staticmethod
    def stdbase():
        return Edwards448Point(Edwards448Point.xb,Edwards448Point.yb)
    def __init__(self,x,y):
        #Check that the point is actually on the curve.
        if y*y+x*x!=self.f1+self.d*x*x*y*y:
            raise ValueError("Invalid point")
        self.initpoint(x, y)
    #Decode a point representation.
    def decode(self,s):
        x,y=self.decode_base(s,456);
        return Edwards448Point(x, y) if x is not None else None
    #Encode a point representation.
    def encode(self):
        return self.encode_base(456)
    #Construct a neutral point on this curve.
    def zero_elem(self):
        return Edwards448Point(self.f0,self.f1)
    #Solve for x^2.
    def solve_x2(self,y):
        return ((y*y-self.f1)/(self.d*y*y-self.f1))





Josefsson & Liusvaara         Informational                    [Page 53]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    #Point addition.
    def __add__(self,y):
        #The formulas are from EFD.
        tmp=self.zero_elem()
        xcp,ycp,zcp=self.x*y.x,self.y*y.y,self.z*y.z
        B=zcp*zcp
        E=self.d*xcp*ycp
        F,G=B-E,B+E
        tmp.x=zcp*F*((self.x+self.y)*(y.x+y.y)-xcp-ycp)
        tmp.y,tmp.z=zcp*G*(ycp-xcp),F*G
        return tmp
    #Point doubling.
    def double(self):
        #The formulas are from EFD.
        tmp=self.zero_elem()
        x1s,y1s,z1s=self.x*self.x,self.y*self.y,self.z*self.z
        xys=self.x+self.y
        F=x1s+y1s
        J=F-(z1s+z1s)
        tmp.x,tmp.y,tmp.z=(xys*xys-x1s-y1s)*J,F*(x1s-y1s),F*J
        return tmp
    #Order of basepoint.
    def l(self):
        return hexi("3ffffffffffffffffffffffffffffffffffffffffffffff"+\
            "fffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c2"+\
            "92ab5844f3")
    #The logarithm of cofactor.
    def c(self): return 2
    #The highest set bit.
    def n(self): return 447
    #The coding length.
    def b(self): return 456
    #Validity check (for debugging).
    def is_valid_point(self):
        x,y,z=self.x,self.y,self.z
        x2=x*x
        y2=y*y
        z2=z*z
        lhs=(x2+y2)*z2
        rhs=z2*z2+self.d*x2*y2
        assert(lhs == rhs)










Josefsson & Liusvaara         Informational                    [Page 54]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


#Simple self-check.
def curve_self_check(point):
    p=point
    q=point.zero_elem()
    z=q
    l=p.l()+1
    p.is_valid_point()
    q.is_valid_point()
    for i in range(0,point.b()):
        if (l>>i)&1 != 0:
            q=q+p
            q.is_valid_point()
        p=p.double()
        p.is_valid_point()
    assert q.encode() == point.encode()
    assert q.encode() != p.encode()
    assert q.encode() != z.encode()

#Simple self-check.
def self_check_curves():
    curve_self_check(Edwards25519Point.stdbase())
    curve_self_check(Edwards448Point.stdbase())

#PureEdDSA scheme.
#Limitation: only b mod 8 = 0 is handled.
class PureEdDSA:
    #Create a new object.
    def __init__(self,properties):
        self.B=properties["B"]
        self.H=properties["H"]
        self.l=self.B.l()
        self.n=self.B.n()
        self.b=self.B.b()
        self.c=self.B.c()
    #Clamp a private scalar.
    def __clamp(self,a):
        _a = bytearray(a)
        for i in range(0,self.c): _a[i//8]&=~(1<<(i%8))
        _a[self.n//8]|=1<<(self.n%8)
        for i in range(self.n+1,self.b): _a[i//8]&=~(1<<(i%8))
        return _a
    #Generate a key.  If privkey is None, a random one is generated.
    #In any case, the (privkey, pubkey) pair is returned.
    def keygen(self,privkey):
        #If no private key data is given, generate random.
        if privkey is None: privkey=os.urandom(self.b//8)





Josefsson & Liusvaara         Informational                    [Page 55]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


        #Expand key.
        khash=self.H(privkey,None,None)
        a=from_le(self.__clamp(khash[:self.b//8]))
        #Return the key pair (public key is A=Enc(aB).
        return privkey,(self.B*a).encode()
    #Sign with key pair.
    def sign(self,privkey,pubkey,msg,ctx,hflag):
        #Expand key.
        khash=self.H(privkey,None,None)
        a=from_le(self.__clamp(khash[:self.b//8]))
        seed=khash[self.b//8:]
        #Calculate r and R (R only used in encoded form).
        r=from_le(self.H(seed+msg,ctx,hflag))%self.l
        R=(self.B*r).encode()
        #Calculate h.
        h=from_le(self.H(R+pubkey+msg,ctx,hflag))%self.l
        #Calculate s.
        S=((r+h*a)%self.l).to_bytes(self.b//8,byteorder="little")
        #The final signature is a concatenation of R and S.
        return R+S
    #Verify signature with public key.
    def verify(self,pubkey,msg,sig,ctx,hflag):
        #Sanity-check sizes.
        if len(sig)!=self.b//4: return False
        if len(pubkey)!=self.b//8: return False
        #Split signature into R and S, and parse.
        Rraw,Sraw=sig[:self.b//8],sig[self.b//8:]
        R,S=self.B.decode(Rraw),from_le(Sraw)
        #Parse public key.
        A=self.B.decode(pubkey)
        #Check parse results.
        if (R is None) or (A is None) or S>=self.l: return False
        #Calculate h.
        h=from_le(self.H(Rraw+pubkey+msg,ctx,hflag))%self.l
        #Calculate left and right sides of check eq.
        rhs=R+(A*h)
        lhs=self.B*S
        for i in range(0, self.c):
            lhs = lhs.double()
            rhs = rhs.double()
        #Check eq. holds?
        return lhs==rhs

def Ed25519_inthash(data,ctx,hflag):
    if (ctx is not None and len(ctx) > 0) or hflag:
        raise ValueError("Contexts/hashes not supported")
    return hashlib.sha512(data).digest()




Josefsson & Liusvaara         Informational                    [Page 56]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


#The base PureEdDSA schemes.
pEd25519=PureEdDSA({\
    "B":Edwards25519Point.stdbase(),\
    "H":Ed25519_inthash\
})

def Ed25519ctx_inthash(data,ctx,hflag):
    dompfx = b""
    PREFIX=b"SigEd25519 no Ed25519 collisions"
    if ctx is not None:
        if len(ctx) > 255: raise ValueError("Context too big")
        dompfx=PREFIX+bytes([1 if hflag else 0,len(ctx)])+ctx
    return hashlib.sha512(dompfx+data).digest()

pEd25519ctx=PureEdDSA({\
    "B":Edwards25519Point.stdbase(),\
    "H":Ed25519ctx_inthash\
})

def Ed448_inthash(data,ctx,hflag):
    dompfx = b""
    if ctx is not None:
        if len(ctx) > 255: raise ValueError("Context too big")
        dompfx=b"SigEd448"+bytes([1 if hflag else 0,len(ctx)])+ctx
    return shake256(dompfx+data,114)

pEd448 = PureEdDSA({\
    "B":Edwards448Point.stdbase(),\
    "H":Ed448_inthash\
})

#EdDSA scheme.
class EdDSA:
    #Create a new scheme object, with the specified PureEdDSA base
    #scheme and specified prehash.
    def __init__(self,pure_scheme,prehash):
        self.__pflag = True
        self.__pure=pure_scheme
        self.__prehash=prehash
        if self.__prehash is None:
            self.__prehash = lambda x,y:x
            self.__pflag = False
    # Generate a key.  If privkey is none, it generates a random
    # privkey key, otherwise it uses a specified private key.
    # Returns pair (privkey, pubkey).
    def keygen(self,privkey): return self.__pure.keygen(privkey)





Josefsson & Liusvaara         Informational                    [Page 57]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    # Sign message msg using specified key pair.
    def sign(self,privkey,pubkey,msg,ctx=None):
        if ctx is None: ctx=b"";
        return self.__pure.sign(privkey,pubkey,self.__prehash(msg,ctx),\
            ctx,self.__pflag)
    # Verify signature sig on message msg using public key pubkey.
    def verify(self,pubkey,msg,sig,ctx=None):
        if ctx is None: ctx=b"";
        return self.__pure.verify(pubkey,self.__prehash(msg,ctx),sig,\
            ctx,self.__pflag)

def Ed448ph_prehash(data,ctx):
    return shake256(data,64)

#Our signature schemes.
Ed25519 = EdDSA(pEd25519,None)
Ed25519ctx = EdDSA(pEd25519ctx,None)
Ed25519ph = EdDSA(pEd25519ctx,lambda x,y:hashlib.sha512(x).digest())
Ed448 = EdDSA(pEd448,None)
Ed448ph = EdDSA(pEd448,Ed448ph_prehash)

def eddsa_obj(name):
    if name == "Ed25519": return Ed25519
    if name == "Ed25519ctx": return Ed25519ctx
    if name == "Ed25519ph": return Ed25519ph
    if name == "Ed448": return Ed448
    if name == "Ed448ph": return Ed448ph
    raise NotImplementedError("Algorithm not implemented")

Appendix B.  Library Driver

   Below is a command-line tool that uses the library above to perform
   computations for interactive use or for self-checking.

import sys
import binascii

from eddsa2 import Ed25519


def munge_string(s, pos, change):
    return (s[:pos] +
            int.to_bytes(s[pos] ^ change, 1, "little") +
            s[pos+1:])







Josefsson & Liusvaara         Informational                    [Page 58]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


# Read a file in the format of
# http://ed25519.cr.yp.to/python/sign.input
lineno = 0
while True:
    line = sys.stdin.readline()
    if not line:
        break
    lineno = lineno + 1
    print(lineno)
    fields = line.split(":")
    secret = (binascii.unhexlify(fields[0]))[:32]
    public = binascii.unhexlify(fields[1])
    msg = binascii.unhexlify(fields[2])
    signature = binascii.unhexlify(fields[3])[:64]

    privkey,pubkey = Ed25519.keygen(secret)
    assert public == pubkey
    assert signature == Ed25519.sign(privkey, pubkey, msg)
    assert Ed25519.verify(public, msg, signature)
    if len(msg) == 0:
        bad_msg = b"x"
    else:
        bad_msg = munge_string(msg, len(msg) // 3, 4)
    assert not Ed25519.verify(public,bad_msg,signature)
    assert not Ed25519.verify(public, msg, munge_string(signature,20,8))
    assert not Ed25519.verify(public,msg,munge_string(signature,40,16))

























Josefsson & Liusvaara         Informational                    [Page 59]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


Acknowledgements

   EdDSA and Ed25519 were initially described in a paper due to Daniel
   J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin
   Yang.  The Ed448 curve is due to Mike Hamburg.

   An earlier draft version of this document was coauthored by Niels
   Moeller.

   Feedback on this document was received from Werner Koch, Damien
   Miller, Bob Bradley, Franck Rondepierre, Alexey Melnikov, Kenny
   Paterson, and Robert Edmonds.

   The Ed25519 test vectors were double checked by Bob Bradley using
   three separate implementations (one based on TweetNaCl and two
   different implementations based on code from SUPERCOP).

Authors' Addresses

   Simon Josefsson
   SJD AB

   Email: simon@josefsson.org
   URI:   http://josefsson.org/


   Ilari Liusvaara
   Independent

   Email: ilariliusvaara@welho.com





















Josefsson & Liusvaara         Informational                    [Page 60]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-iab-sec-cons] [Tracker] [Diff1] [Diff2]
   [Errata]
   BEST CURRENT PRACTICE
   Errata Exist
Network Working Group                                        E. Rescorla
Request for Comments: 3552                                    RTFM, Inc.
BCP: 72                                                        B. Korver
Category: Best Current Practice                          Xythos Software
                                             Internet Architecture Board
                                                                     IAB
                                                               July 2003


       Guidelines for Writing RFC Text on Security Considerations

Status of this Memo

   This document specifies an Internet Best Current Practices for the
   Internet Community, and requests discussion and suggestions for
   improvements.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

Abstract

   All RFCs are required to have a Security Considerations section.
   Historically, such sections have been relatively weak.  This document
   provides guidelines to RFC authors on how to write a good Security
   Considerations section.

Table of Contents

   1. Introduction . . . . . . . . . . . . . . . . . . . . . . .   3
      1.1. Requirements. . . . . . . . . . . . . . . . . . . . .   3
   2. The Goals of Security. . . . . . . . . . . . . . . . . . .   3
      2.1. Communication Security. . . . . . . . . . . . . . . .   3
           2.1.1. Confidentiality. . . . . . . . . . . . . . . .   4
           2.1.2. Data Integrity . . . . . . . . . . . . . . . .   4
           2.1.3. Peer Entity authentication . . . . . . . . . .   4
      2.2. Non-Repudiation . . . . . . . . . . . . . . . . . . .   5
      2.3. Systems Security. . . . . . . . . . . . . . . . . . .   5
           2.3.1. Unauthorized Usage . . . . . . . . . . . . . .   6
           2.3.2. Inappropriate Usage. . . . . . . . . . . . . .   6
           2.3.3. Denial of Service. . . . . . . . . . . . . . .   6
   3. The Internet Threat Model. . . . . . . . . . . . . . . . .   6
      3.1. Limited Threat Models . . . . . . . . . . . . . . . .   7
      3.2. Passive Attacks . . . . . . . . . . . . . . . . . . .   7
           3.2.1. Confidentiality Violations . . . . . . . . . .   8
           3.2.2. Password Sniffing. . . . . . . . . . . . . . .   8
           3.2.3. Offline Cryptographic Attacks. . . . . . . . .   9



Rescorla & Korver        Best Current Practice                  [Page 1]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


      3.3. Active Attacks. . . . . . . . . . . . . . . . . . . .   9
           3.3.1. Replay Attacks . . . . . . . . . . . . . . . .  10
           3.3.2. Message Insertion. . . . . . . . . . . . . . .  10
           3.3.3. Message Deletion . . . . . . . . . . . . . . .  11
           3.3.4. Message Modification . . . . . . . . . . . . .  11
           3.3.5. Man-In-The-Middle. . . . . . . . . . . . . . .  12
      3.4. Topological Issues. . . . . . . . . . . . . . . . . .  12
      3.5. On-path versus off-path . . . . . . . . . . . . . . .  13
      3.6. Link-local. . . . . . . . . . . . . . . . . . . . . .  13
   4. Common Issues. . . . . . . . . . . . . . . . . . . . . . .  13
      4.1. User Authentication . . . . . . . . . . . . . . . . .  14
           4.1.1. Username/Password. . . . . . . . . . . . . . .  14
           4.1.2. Challenge Response and One Time Passwords. . .  14
           4.1.3. Shared Keys. . . . . . . . . . . . . . . . . .  15
           4.1.4. Key Distribution Centers . . . . . . . . . . .  15
           4.1.5. Certificates . . . . . . . . . . . . . . . . .  15
           4.1.6. Some Uncommon Systems. . . . . . . . . . . . .  15
           4.1.7. Host Authentication. . . . . . . . . . . . . .  16
      4.2. Generic Security Frameworks . . . . . . . . . . . . .  16
      4.3. Non-repudiation . . . . . . . . . . . . . . . . . . .  17
      4.4. Authorization vs. Authentication. . . . . . . . . . .  18
           4.4.1. Access Control Lists . . . . . . . . . . . . .  18
           4.4.2. Certificate Based Systems. . . . . . . . . . .  18
      4.5. Providing Traffic Security. . . . . . . . . . . . . .  19
           4.5.1. IPsec. . . . . . . . . . . . . . . . . . . . .  19
           4.5.2. SSL/TLS. . . . . . . . . . . . . . . . . . . .  20
           4.5.3. Remote Login . . . . . . . . . . . . . . . . .  22
      4.6. Denial of Service Attacks and Countermeasures . . . .  22
           4.6.1. Blind Denial of Service. . . . . . . . . . . .  23
           4.6.2. Distributed Denial of Service. . . . . . . . .  23
           4.6.3. Avoiding Denial of Service . . . . . . . . . .  24
           4.6.4. Example: TCP SYN Floods. . . . . . . . . . . .  24
           4.6.5. Example: Photuris. . . . . . . . . . . . . . .  25
      4.7. Object vs. Channel Security . . . . . . . . . . . . .  25
      4.8. Firewalls and Network Topology. . . . . . . . . . . .  26
   5. Writing Security Considerations Sections . . . . . . . . .  26
   6. Examples . . . . . . . . . . . . . . . . . . . . . . . . .  28
      6.1. SMTP. . . . . . . . . . . . . . . . . . . . . . . . .  29
           6.1.1. Security Considerations. . . . . . . . . . . .  29
           6.1.2. Communications security issues . . . . . . . .  34
           6.1.3. Denial of Service. . . . . . . . . . . . . . .  36
      6.2. VRRP. . . . . . . . . . . . . . . . . . . . . . . . . .36
           6.2.1. Security Considerations. . . . . . . . . . . .  36
   7. Acknowledgments. . . . . . . . . . . . . . . . . . . . . .  38
   8. Normative References . . . . . . . . . . . . . . . . . . .  39
   9. Informative References . . . . . . . . . . . . . . . . . .  41
   10.Security Considerations. . . . . . . . . . . . . . . . . .  42
   Appendix A. . . . . . . . . . . . . . . . . . . . . . . . . .  43



Rescorla & Korver        Best Current Practice                  [Page 2]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Authors' Addresses. . . . . . . . . . . . . . . . . . . . . .  43
   Full Copyright Statement. . . . . . . . . . . . . . . . . . .  44

1. Introduction

   All RFCs are required by RFC 2223 to contain a Security
   Considerations section.  The purpose of this is both to encourage
   document authors to consider security in their designs and to inform
   the reader of relevant security issues.  This memo is intended to
   provide guidance to RFC authors in service of both ends.

   This document is structured in three parts.  The first is a
   combination security tutorial and definition of common terms; the
   second is a series of guidelines for writing Security Considerations;
   the third is a series of examples.

1.1. Requirements

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in BCP 14, RFC 2119
   [KEYWORDS].

2. The Goals of Security

   Most people speak of security as if it were a single monolithic
   property of a protocol or system, however, upon reflection, one
   realizes that it is clearly not true.  Rather, security is a series
   of related but somewhat independent properties.  Not all of these
   properties are required for every application.

   We can loosely divide security goals into those related to protecting
   communications (COMMUNICATION SECURITY, also known as COMSEC) and
   those relating to protecting systems (ADMINISTRATIVE SECURITY or
   SYSTEM SECURITY).  Since communications are carried out by systems
   and access to systems is through communications channels, these goals
   obviously interlock, but they can also be independently provided.

2.1. Communication Security

   Different authors partition the goals of communication security
   differently.  The partitioning we've found most useful is to divide
   them into three major categories: CONFIDENTIALITY, DATA INTEGRITY and
   PEER ENTITY AUTHENTICATION.







Rescorla & Korver        Best Current Practice                  [Page 3]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


2.1.1. Confidentiality

   When most people think of security, they think of CONFIDENTIALITY.
   Confidentiality means that your data is kept secret from unintended
   listeners.  Usually, these listeners are simply eavesdroppers.  When
   an adversary taps your phone, it poses a risk to your
   confidentiality.

   Obviously, if you have secrets, then you are probably concerned about
   others discovering them.  Thus, at the very least, you want to
   maintain confidentiality.  When you see spies in the movies go into
   the bathroom and turn on all the water to foil bugging, the property
   they're looking for is confidentiality.

2.1.2. Data Integrity

   The second primary goal is DATA INTEGRITY.  The basic idea here is
   that we want to make sure that the data we receive is the same data
   that the sender has sent.  In paper-based systems, some data
   integrity comes automatically.  When you receive a letter written in
   pen you can be fairly certain that no words have been removed by an
   attacker because pen marks are difficult to remove from paper.
   However, an attacker could have easily added some marks to the paper
   and completely changed the meaning of the message.  Similarly, it's
   easy to shorten the page to truncate the message.

   On the other hand, in the electronic world, since all bits look
   alike, it's trivial to tamper with messages in transit.  You simply
   remove the message from the wire, copy out the parts you like, add
   whatever data you want, and generate a new message of your choosing,
   and the recipient is no wiser.  This is the moral equivalent of the
   attacker taking a letter you wrote, buying some new paper and
   recopying the message, changing it as he does it.  It's just a lot
   easier to do electronically since all bits look alike.

2.1.3. Peer Entity authentication

   The third property we're concerned with is PEER ENTITY
   AUTHENTICATION.  What we mean by this is that we know that one of the
   endpoints in the communication is the one we intended.  Without peer
   entity authentication, it's very difficult to provide either
   confidentiality or data integrity.  For instance, if we receive a
   message from Alice, the property of data integrity doesn't do us much
   good unless we know that it was in fact sent by Alice and not the
   attacker.  Similarly, if we want to send a confidential message to
   Bob, it's not of much value to us if we're actually sending a
   confidential message to the attacker.




Rescorla & Korver        Best Current Practice                  [Page 4]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Note that peer entity authentication can be provided asymmetrically.
   When you call someone on the phone, you can be fairly certain that
   you have the right person -- or at least that you got a person who's
   actually at the phone number you called.  On the other hand, if they
   don't have caller ID, then the receiver of a phone call has no idea
   who's calling them.  Calling someone on the phone is an example of
   recipient authentication, since you know who the recipient of the
   call is, but they don't know anything about the sender.

   In messaging situations, you often wish to use peer entity
   authentication to establish the identity of the sender of a certain
   message.  In such contexts, this property is called DATA ORIGIN
   AUTHENTICATION.

2.2. Non-Repudiation

   A system that provides endpoint authentication allows one party to be
   certain of the identity of someone with whom he is communicating.
   When the system provides data integrity a receiver can be sure of
   both the sender's identity and that he is receiving the data that
   that sender meant to send.  However, he cannot necessarily
   demonstrate this fact to a third party.  The ability to make this
   demonstration is called NON-REPUDIATION.

   There are many situations in which non-repudiation is desirable.
   Consider the situation in which two parties have signed a contract
   which one party wishes to unilaterally abrogate.  He might simply
   claim that he had never signed it in the first place.  Non-
   repudiation prevents him from doing so, thus protecting the
   counterparty.

   Unfortunately, non-repudiation can be very difficult to achieve in
   practice and naive approaches are generally inadequate.  Section 4.3
   describes some of the difficulties, which generally stem from the
   fact that the interests of the two parties are not aligned -- one
   party wishes to prove something that the other party wishes to deny.

2.3. Systems Security

   In general, systems security is concerned with protecting one's
   machines and data.  The intent is that machines should be used only
   by authorized users and for the purposes that the owners intend.
   Furthermore, they should be available for those purposes.  Attackers
   should not be able to deprive legitimate users of resources.







Rescorla & Korver        Best Current Practice                  [Page 5]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


2.3.1. Unauthorized Usage

   Most systems are not intended to be completely accessible to the
   public.  Rather, they are intended to be used only by certain
   authorized individuals.  Although many Internet services are
   available to all Internet users, even those servers generally offer a
   larger subset of services to specific users.  For instance, Web
   Servers often will serve data to any user, but restrict the ability
   to modify pages to specific users.  Such modifications by the general
   public would be UNAUTHORIZED USAGE.

2.3.2. Inappropriate Usage

   Being an authorized user does not mean that you have free run of the
   system.  As we said above, some activities are restricted to
   authorized users, some to specific users, and some activities are
   generally forbidden to all but administrators.  Moreover, even
   activities which are in general permitted might be forbidden in some
   cases.  For instance, users may be permitted to send email but
   forbidden from sending files above a certain size, or files which
   contain viruses.  These are examples of INAPPROPRIATE USAGE.

2.3.3. Denial of Service

   Recall that our third goal was that the system should be available to
   legitimate users.  A broad variety of attacks are possible which
   threaten such usage.  Such attacks are collectively referred to as
   DENIAL OF SERVICE attacks.  Denial of service attacks are often very
   easy to mount and difficult to stop.  Many such attacks are designed
   to consume machine resources, making it difficult or impossible to
   serve legitimate users.  Other attacks cause the target machine to
   crash, completely denying service to users.

3. The Internet Threat Model

   A THREAT MODEL describes the capabilities that an attacker is assumed
   to be able to deploy against a resource.  It should contain such
   information as the resources available to an attacker in terms of
   information, computing capability, and control of the system.  The
   purpose of a threat model is twofold.  First, we wish to identify the
   threats we are concerned with.  Second, we wish to rule some threats
   explicitly out of scope.  Nearly every security system is vulnerable
   to a sufficiently dedicated and resourceful attacker.

   The Internet environment has a fairly well understood threat model.
   In general, we assume that the end-systems engaging in a protocol
   exchange have not themselves been compromised.  Protecting against an
   attack when one of the end-systems has been compromised is



Rescorla & Korver        Best Current Practice                  [Page 6]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   extraordinarily difficult.  It is, however, possible to design
   protocols which minimize the extent of the damage done under these
   circumstances.

   By contrast, we assume that the attacker has nearly complete control
   of the communications channel over which the end-systems communicate.
   This means that the attacker can read any PDU (Protocol Data Unit) on
   the network and undetectably remove, change, or inject forged packets
   onto the wire.  This includes being able to generate packets that
   appear to be from a trusted machine.  Thus, even if the end-system
   with which you wish to communicate is itself secure, the Internet
   environment provides no assurance that packets which claim to be from
   that system in fact are.

   It's important to realize that the meaning of a PDU is different at
   different levels.  At the IP level, a PDU means an IP packet.  At the
   TCP level, it means a TCP segment.  At the application layer, it
   means some kind of application PDU.  For instance, at the level of
   email, it might either mean an RFC-822 message or a single SMTP
   command.  At the HTTP level, it might mean a request or response.

3.1. Limited Threat Models

   As we've said, a resourceful and dedicated attacker can control the
   entire communications channel.  However, a large number of attacks
   can be mounted by an attacker with fewer resources.  A number of
   currently known attacks can be mounted by an attacker with limited
   control of the network.  For instance, password sniffing attacks can
   be mounted by an attacker who can only read arbitrary packets.  This
   is generally referred to as a PASSIVE ATTACK [INTAUTH].

   By contrast, Morris' sequence number guessing attack [SEQNUM] can be
   mounted by an attacker who can write but not read arbitrary packets.
   Any attack which requires the attacker to write to the network is
   known as an ACTIVE ATTACK.

   Thus, a useful way of organizing attacks is to divide them based on
   the capabilities required to mount the attack.  The rest of this
   section describes these categories and provides some examples of each
   category.

3.2. Passive Attacks

   In a passive attack, the attacker reads packets off the network but
   does not write them.  The simplest way to mount such an attack is to
   simply be on the same LAN as the victim.  On most common LAN
   configurations, including Ethernet, 802.3, and FDDI, any machine on
   the wire can read all traffic destined for any other machine on the



Rescorla & Korver        Best Current Practice                  [Page 7]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   same LAN.  Note that switching hubs make this sort of sniffing
   substantially more difficult, since traffic destined for a machine
   only goes to the network segment which that machine is on.

   Similarly, an attacker who has control of a host in the
   communications path between two victim machines is able to mount a
   passive attack on their communications.  It is also possible to
   compromise the routing infrastructure to specifically arrange that
   traffic passes through a compromised machine.  This might involve an
   active attack on the routing infrastructure to facilitate a passive
   attack on a victim machine.

   Wireless communications channels deserve special consideration,
   especially with the recent and growing popularity of wireless-based
   LANs, such as those using 802.11.  Since the data is simply broadcast
   on well known radio frequencies, an attacker simply needs to be able
   to receive those transmissions.  Such channels are especially
   vulnerable to passive attacks.  Although many such channels include
   cryptographic protection, it is often of such poor quality as to be
   nearly useless [WEP].

   In general, the goal of a passive attack is to obtain information
   which the sender and receiver would prefer to remain private.  This
   private information may include credentials useful in the electronic
   world and/or passwords or credentials useful in the outside world,
   such as confidential business information.

3.2.1. Confidentiality Violations

   The classic example of passive attack is sniffing some inherently
   private data off of the wire.  For instance, despite the wide
   availability of SSL, many credit card transactions still traverse the
   Internet in the clear.  An attacker could sniff such a message and
   recover the credit card number, which can then be used to make
   fraudulent transactions.  Moreover, confidential business information
   is routinely transmitted over the network in the clear in email.

3.2.2. Password Sniffing

   Another example of a passive attack is PASSWORD SNIFFING.  Password
   sniffing is directed towards obtaining unauthorized use of resources.
   Many protocols, including [TELNET], [POP], and [NNTP] use a shared
   password to authenticate the client to the server.  Frequently, this
   password is transmitted from the client to the server in the clear
   over the communications channel.  An attacker who can read this
   traffic can therefore capture the password and REPLAY it.  In other
   words, the attacker can initiate a connection to the server and pose
   as the client and login using the captured password.



Rescorla & Korver        Best Current Practice                  [Page 8]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Note that although the login phase of the attack is active, the
   actual password capture phase is passive.  Moreover, unless the
   server checks the originating address of connections, the login phase
   does not require any special control of the network.

3.2.3. Offline Cryptographic Attacks

   Many cryptographic protocols are subject to OFFLINE ATTACKS.  In such
   a protocol, the attacker recovers data which has been processed using
   the victim's secret key and then mounts a cryptanalytic attack on
   that key.  Passwords make a particularly vulnerable target because
   they are typically low entropy.  A number of popular password-based
   challenge response protocols are vulnerable to DICTIONARY ATTACK.
   The attacker captures a challenge-response pair and then proceeds to
   try entries from a list of common words (such as a dictionary file)
   until he finds a password that produces the right response.

   A similar such attack can be mounted on a local network when NIS is
   used.  The Unix password is crypted using a one-way function, but
   tools exist to break such crypted passwords [KLEIN].  When NIS is
   used, the crypted password is transmitted over the local network and
   an attacker can thus sniff the password and attack it.

   Historically, it has also been possible to exploit small operating
   system security holes to recover the password file using an active
   attack.  These holes can then be bootstrapped into an actual account
   by using the aforementioned offline password recovery techniques.
   Thus we combine a low-level active attack with an offline passive
   attack.

3.3. Active Attacks

   When an attack involves writing data to the network, we refer to this
   as an ACTIVE ATTACK.  When IP is used without IPsec, there is no
   authentication for the sender address.  As a consequence, it's
   straightforward for an attacker to create a packet with a source
   address of his choosing.  We'll refer to this as a SPOOFING ATTACK.

   Under certain circumstances, such a packet may be screened out by the
   network.  For instance, many packet filtering firewalls screen out
   all packets with source addresses on the INTERNAL network that arrive
   on the EXTERNAL interface.  Note, however, that this provides no
   protection against an attacker who is inside the firewall.  In
   general, designers should assume that attackers can forge packets.







Rescorla & Korver        Best Current Practice                  [Page 9]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   However, the ability to forge packets does not go hand in hand with
   the ability to receive arbitrary packets.  In fact, there are active
   attacks that involve being able to send forged packets but not
   receive the responses.  We'll refer to these as BLIND ATTACKS.

   Note that not all active attacks require forging addresses.  For
   instance, the TCP SYN denial of service attack [TCPSYN] can be
   mounted successfully without disguising the sender's address.
   However, it is common practice to disguise one's address in order to
   conceal one's identity if an attack is discovered.

   Each protocol is susceptible to specific active attacks, but
   experience shows that a number of common patterns of attack can be
   adapted to any given protocol.  The next sections describe a number
   of these patterns and give specific examples of them as applied to
   known protocols.

3.3.1. Replay Attacks

   In a REPLAY ATTACK, the attacker records a sequence of messages off
   of the wire and plays them back to the party which originally
   received them.  Note that the attacker does not need to be able to
   understand the messages.  He merely needs to capture and retransmit
   them.

   For example, consider the case where an S/MIME message is being used
   to request some service, such as a credit card purchase or a stock
   trade.  An attacker might wish to have the service executed twice, if
   only to inconvenience the victim.  He could capture the message and
   replay it, even though he can't read it, causing the transaction to
   be executed twice.

3.3.2. Message Insertion

   In a MESSAGE INSERTION attack, the attacker forges a message with
   some chosen set of properties and injects it into the network.  Often
   this message will have a forged source address in order to disguise
   the identity of the attacker.

   For example, a denial-of-service attack can be mounted by inserting a
   series of spurious TCP SYN packets directed towards the target host.
   The target host responds with its own SYN and allocates kernel data
   structures for the new connection.  The attacker never completes the
   3-way handshake, so the allocated connection endpoints just sit there
   taking up kernel memory.  Typical TCP stack implementations only






Rescorla & Korver        Best Current Practice                 [Page 10]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   allow some limited number of connections in this "half-open" state
   and when this limit is reached, no more connections can be initiated,
   even from legitimate hosts.  Note that this attack is a blind attack,
   since the attacker does not need to process the victim's SYNs.

3.3.3. Message Deletion

   In a MESSAGE DELETION attack, the attacker removes a message from the
   wire.  Morris' sequence number guessing attack [SEQNUM] often
   requires a message deletion attack to be performed successfully.  In
   this blind attack, the host whose address is being forged will
   receive a spurious TCP SYN packet from the host being attacked.
   Receipt of this SYN packet generates a RST, which would tear the
   illegitimate connection down.  In order to prevent this host from
   sending a RST so that the attack can be carried out successfully,
   Morris describes flooding this host to create queue overflows such
   that the SYN packet is lost and thus never responded to.

3.3.4. Message Modification

   In a MESSAGE MODIFICATION attack, the attacker removes a message from
   the wire, modifies it, and reinjects it into the network.  This sort
   of attack is particularly useful if the attacker wants to send some
   of the data in the message but also wants to change some of it.

   Consider the case where the attacker wants to attack an order for
   goods placed over the Internet.  He doesn't have the victim's credit
   card number so he waits for the victim to place the order and then
   replaces the delivery address (and possibly the goods description)
   with his own.  Note that this particular attack is known as a CUT-
   AND-PASTE attack since the attacker cuts the credit card number out
   of the original message and pastes it into the new message.

   Another interesting example of a cut-and-paste attack is provided by
   [IPSPPROB].  If IPsec ESP is used without any MAC then it is possible
   for the attacker to read traffic encrypted for a victim on the same
   machine.  The attacker attaches an IP header corresponding to a port
   he controls onto the encrypted IP packet.  When the packet is
   received by the host it will automatically be decrypted and forwarded
   to the attacker's port.  Similar techniques can be used to mount a
   session hijacking attack.  Both of these attacks can be avoided by
   always using message authentication when you use encryption.  Note
   that this attack only works if (1) no MAC check is being used, since
   this attack generates damaged packets (2) a host-to-host SA is being
   used, since a user-to-user SA will result in an inconsistency between
   the port associated with the SA and the target port.  If the
   receiving machine is single-user than this attack is infeasible.




Rescorla & Korver        Best Current Practice                 [Page 11]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


3.3.5. Man-In-The-Middle

   A MAN-IN-THE-MIDDLE attack combines the above techniques in a special
   form: The attacker subverts the communication stream in order to pose
   as the sender to receiver and the receiver to the sender:

      What Alice and Bob think:
      Alice  <---------------------------------------------->  Bob

      What's happening:
      Alice  <---------------->  Attacker  <---------------->  Bob

   This differs fundamentally from the above forms of attack because it
   attacks the identity of the communicating parties, rather than the
   data stream itself.  Consequently, many techniques which provide
   integrity of the communications stream are insufficient to protect
   against man-in-the-middle attacks.

   Man-in-the-middle attacks are possible whenever a protocol lacks PEER
   ENTITY AUTHENTICATION.  For instance, if an attacker can hijack the
   client TCP connection during the TCP handshake (perhaps by responding
   to the client's SYN before the server does), then the attacker can
   open another connection to the server and begin a man-in-the-middle
   attack.  It is also trivial to mount man-in-the-middle attacks on
   local networks via ARP spoofing -- the attacker forges an ARP with
   the victim's IP address and his own MAC address.  Tools to mount this
   sort of attack are readily available.

   Note that it is only necessary to authenticate one side of the
   transaction in order to prevent man-in-the-middle attacks.  In such a
   situation the the peers can establish an association in which only
   one peer is authenticated.  In such a system, an attacker can
   initiate an association posing as the unauthenticated peer but cannot
   transmit or access data being sent on a legitimate connection.  This
   is an acceptable situation in contexts such as Web e-commerce where
   only the server needs to be authenticated (or the client is
   independently authenticated via some non-cryptographic mechanism such
   as a credit card number).

3.4. Topological Issues

   In practice, the assumption that it's equally easy for an attacker to
   read and generate all packets is false, since the Internet is not
   fully connected.  This has two primary implications.







Rescorla & Korver        Best Current Practice                 [Page 12]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


3.5. On-path versus off-path

   In order for a datagram to be transmitted from one host to another,
   it generally must traverse some set of intermediate links and
   gateways.  Such gateways are naturally able to read, modify, or
   remove any datagram transmitted along that path.  This makes it much
   easier to mount a wide variety of attacks if you are on-path.

   Off-path hosts can, of course, transmit arbitrary datagrams that
   appear to come from any hosts but cannot necessarily receive
   datagrams intended for other hosts.  Thus, if an attack depends on
   being able to receive data, off-path hosts must first subvert the
   topology in order to place themselves on-path.  This is by no means
   impossible but is not necessarily trivial.

   Applications protocol designers MUST NOT assume that all attackers
   will be off-path.  Where possible, protocols SHOULD be designed to
   resist attacks from attackers who have complete control of the
   network.  However, designers are expected to give more weight to
   attacks which can be mounted by off-path attackers as well as on-path
   ones.

3.6. Link-local

   One specialized case of on-path is being on the same link.  In some
   situations, it's desirable to distinguish between hosts who are on
   the local network and those who are not.  The standard technique for
   this is verifying the IP TTL value [IP].  Since the TTL must be
   decremented by each forwarder, a protocol can demand that TTL be set
   to 255 and that all receivers verify the TTL.  A receiver then has
   some reason to believe that conforming packets are from the same
   link.  Note that this technique must be used with care in the
   presence of tunneling systems, since such systems may pass packets
   without decrementing TTL.

4. Common Issues

   Although each system's security requirements are unique, certain
   common requirements appear in a number of protocols.  Often, when
   naive protocol designers are faced with these requirements, they
   choose an obvious but insecure solution even though better solutions
   are available.  This section describes a number of issues seen in
   many protocols and the common pieces of security technology that may
   be useful in addressing them.







Rescorla & Korver        Best Current Practice                 [Page 13]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


4.1. User Authentication

   Essentially every system which wants to control access to its
   resources needs some way to authenticate users.  A nearly uncountable
   number of such mechanisms have been designed for this purpose.  The
   next several sections describe some of these techniques.

4.1.1. Username/Password

   The most common access control mechanism is simple USERNAME/PASSWORD
   The user provides a username and a reusable password to the host
   which he wishes to use.  This system is vulnerable to a simple
   passive attack where the attacker sniffs the password off the wire
   and then initiates a new session, presenting the password.  This
   threat can be mitigated by hosting the protocol over an encrypted
   connection such as TLS or IPSEC.  Unprotected (plaintext)
   username/password systems are not acceptable in IETF standards.

4.1.2. Challenge Response and One Time Passwords

   Systems which desire greater security than USERNAME/PASSWORD often
   employ either a ONE TIME PASSWORD [OTP] scheme or a CHALLENGE-
   RESPONSE.  In a one time password scheme, the user is provided with a
   list of passwords, which must be used in sequence, one time each.
   (Often these passwords are generated from some secret key so the user
   can simply compute the next password in the sequence.)  SecureID and
   DES Gold are variants of this scheme.  In a challenge-response
   scheme, the host and the user share some secret (which often is
   represented as a password).  In order to authenticate the user, the
   host presents the user with a (randomly generated) challenge.  The
   user computes some function based on the challenge and the secret and
   provides that to the host, which verifies it.  Often this computation
   is performed in a handheld device, such as a DES Gold card.

   Both types of scheme provide protection against replay attack, but
   often still vulnerable to an OFFLINE KEYSEARCH ATTACK (a form of
   passive attack): As previously mentioned, often the one-time password
   or response is computed from a shared secret.  If the attacker knows
   the function being used, he can simply try all possible shared
   secrets until he finds one that produces the right output.  This is
   made easier if the shared secret is a password, in which case he can
   mount a DICTIONARY ATTACK -- meaning that he tries a list of common
   words (or strings) rather than just random strings.

   These systems are also often vulnerable to an active attack.  Unless
   communication security is provided for the entire session, the
   attacker can simply wait until authentication has been performed and
   hijack the connection.



Rescorla & Korver        Best Current Practice                 [Page 14]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


4.1.3. Shared Keys

   CHALLENGE-RESPONSE type systems can be made secure against dictionary
   attack by using randomly generated shared keys instead of user-
   generated passwords.  If the keys are sufficiently large then
   keysearch attacks become impractical.  This approach works best when
   the keys are configured into the end nodes rather than memorized and
   typed in by users, since users have trouble remembering sufficiently
   long keys.

   Like password-based systems, shared key systems suffer from
   management problems.  Each pair of communicating parties must have
   their own agreed-upon key, which leads to there being a lot of keys.

4.1.4. Key Distribution Centers

   One approach to solving the large number of keys problem is to use an
   online "trusted third party" that mediates between the authenticating
   parties.  The trusted third party (generally called a a KEY
   DISTRIBUTION CENTER (KDC)) shares a symmetric key or password with
   each party in the system.  It first contacts the KDC which gives it a
   TICKET containing a randomly generated symmetric key encrypted under
   both peer's keys.  Since only the proper peers can decrypt the
   symmetric key the ticket can be used to establish a trusted
   association.  By far the most popular KDC system is Kerberos
   [KERBEROS].

4.1.5. Certificates

   A simple approach is to have all users have CERTIFICATES [PKIX] which
   they then use to authenticate in some protocol-specific way, as in
   [TLS] or [S/MIME].  A certificate is a signed credential binding an
   entity's identity to its public key.  The signer of a certificate is
   a CERTIFICATE AUTHORITY (CA), whose certificate may itself be signed
   by some superior CA.  In order for this system to work, trust in one
   or more CAs must be established in an out-of-band fashion.  Such CAs
   are referred to as TRUSTED ROOTS or ROOT CAS.  The primary obstacle
   to this approach in client-server type systems is that it requires
   clients to have certificates, which can be a deployment problem.

4.1.6. Some Uncommon Systems

   There are ways to do a better job than the schemes mentioned above,
   but they typically don't add much security unless communications
   security (at least message integrity) will be employed to secure the
   connection, because otherwise the attacker can merely hijack the
   connection after authentication has been performed.  A number of
   protocols ([EKE], [SPEKE], [SRP]) allow one to securely bootstrap a



Rescorla & Korver        Best Current Practice                 [Page 15]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   user's password into a shared key which can be used as input to a
   cryptographic protocol.  One major obstacle to the deployment of
   these protocols has been that their Intellectual Property status is
   extremely unclear.  Similarly, the user can authenticate using public
   key certificates (e.g., S-HTTP client authentication).  Typically
   these methods are used as part of a more complete security protocol.

4.1.7. Host Authentication

   Host authentication presents a special problem.  Quite commonly, the
   addresses of services are presented using a DNS hostname, for
   instance as a URL [URL].  When requesting such a service, one has to
   ensure that the entity that one is talking to not only has a
   certificate but that that certificate corresponds to the expected
   identity of the server.  The important thing to have is a secure
   binding between the certificate and the expected hostname.

   For instance, it is usually not acceptable for the certificate to
   contain an identity in the form of an IP address if the request was
   for a given hostname.  This does not provide end-to-end security
   because the hostname-IP mapping is not secure unless secure name
   resolution [DNSSEC] is being used.  This is a particular problem when
   the hostname is presented at the application layer but the
   authentication is performed at some lower layer.

4.2. Generic Security Frameworks

   Providing security functionality in a protocol can be difficult.  In
   addition to the problem of choosing authentication and key
   establishment mechanisms, one needs to integrate it into a protocol.
   One response to this problem (embodied in IPsec and TLS) is to create
   a lower-level security protocol and then insist that new protocols be
   run over that protocol.  Another approach that has recently become
   popular is to design generic application layer security frameworks.
   The idea is that you design a protocol that allows you to negotiate
   various security mechanisms in a pluggable fashion.  Application
   protocol designers then arrange to carry the security protocol PDUs
   in their application protocol.  Examples of such frameworks include
   GSS-API [GSS] and SASL [SASL].

   The generic framework approach has a number of problems.  First, it
   is highly susceptible to DOWNGRADE ATTACKS.  In a downgrade attack,
   an active attacker tampers with the negotiation in order to force the
   parties to negotiate weaker protection than they otherwise would.
   It's possible to include an integrity check after the negotiation and
   key establishment have both completed, but the strength of this
   integrity check is necessarily limited to the weakest common
   algorithm.  This problem exists with any negotiation approach, but



Rescorla & Korver        Best Current Practice                 [Page 16]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   generic frameworks exacerbate it by encouraging the application
   protocol author to just specify the framework rather than think hard
   about the appropriate underlying mechanisms, particularly since the
   mechanisms can very widely in the degree of security offered.

   Another problem is that it's not always obvious how the various
   security features in the framework interact with the application
   layer protocol.  For instance, SASL can be used merely as an
   authentication framework -- in which case the SASL exchange occurs
   but the rest of the connection is unprotected, but can also negotiate
   traffic protection, such as via GSS, as a mechanism.  Knowing under
   what circumstances traffic protection is optional and which it is
   required requires thinking about the threat model.

   In general, authentication frameworks are most useful in situations
   where new protocols are being added to systems with pre-existing
   legacy authentication systems.  A framework allows new installations
   to provide better authentication while not forcing existing sites
   completely redo their legacy authentication systems.  When the
   security requirements of a system can be clearly identified and only
   a few forms of authentication are used, choosing a single security
   mechanism leads to greater simplicity and predictability.  In
   situations where a framework is to be used, designers SHOULD
   carefully examine the framework's options and specify only the
   mechanisms that are appropriate for their particular threat model.
   If a framework is necessary, designers SHOULD choose one of the
   established ones instead of designing their own.

4.3. Non-repudiation

   The naive approach to non-repudiation is simply to use public-key
   digital signatures over the content.  The party who wishes to be
   bound (the SIGNING PARTY) digitally signs the message in question.
   The counterparty (the RELYING PARTY) can later point to the digital
   signature as proof that the signing party at one point agreed to the
   disputed message.  Unfortunately, this approach is insufficient.

   The easiest way for the signing party to repudiate the message is by
   claiming that his private key has been compromised and that some
   attacker (though not necessarily the relying party) signed the
   disputed message.  In order to defend against this attack the relying
   party needs to demonstrate that the signing party's key had not been
   compromised at the time of the signature.  This requires substantial
   infrastructure, including archival storage of certificate revocation
   information and timestamp servers to establish the time that the
   message was signed.





Rescorla & Korver        Best Current Practice                 [Page 17]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Additionally, the relying party might attempt to trick the signing
   party into signing one message while thinking he's signing another.
   This problem is particularly severe when the relying party controls
   the infrastructure that the signing party uses for signing, such as
   in kiosk situations.  In many such situations the signing party's key
   is kept on a smartcard but the message to be signed is displayed by
   the relying party.

   All of these complications make non-repudiation a difficult service
   to deploy in practice.

4.4. Authorization vs. Authentication

   AUTHORIZATION is the process by which one determines whether an
   authenticated party has permission to access a particular resource or
   service.  Although tightly bound, it is important to realize that
   authentication and authorization are two separate mechanisms.
   Perhaps because of this tight coupling, authentication is sometimes
   mistakenly thought to imply authorization.  Authentication simply
   identifies a party, authorization defines whether they can perform a
   certain action.

   Authorization necessarily relies on authentication, but
   authentication alone does not imply authorization.  Rather, before
   granting permission to perform an action, the authorization mechanism
   must be consulted to determine whether that action is permitted.

4.4.1. Access Control Lists

   One common form of authorization mechanism is an access control list
   (ACL), which lists users that are permitted access to a resource.
   Since assigning individual authorization permissions to each resource
   is tedious, resources are often hierarchically arranged so that the
   parent resource's ACL is inherited by child resources.  This allows
   administrators to set top level policies and override them when
   necessary.

4.4.2. Certificate Based Systems

   While the distinction between authentication and authorization is
   intuitive when using simple authentication mechanisms such as
   username and password (i.e., everyone understands the difference
   between the administrator account and a user account), with more
   complex authentication mechanisms the distinction is sometimes lost.

   With certificates, for instance, presenting a valid signature does
   not imply authorization.  The signature must be backed by a
   certificate chain that contains a trusted root, and that root must be



Rescorla & Korver        Best Current Practice                 [Page 18]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   trusted in the given context.  For instance, users who possess
   certificates issued by the Acme MIS CA may have different web access
   privileges than users who possess certificates issued by the Acme
   Accounting CA, even though both of these CAs are "trusted" by the
   Acme web server.

   Mechanisms for enforcing these more complicated properties have not
   yet been completely explored.  One approach is simply to attach
   policies to ACLs describing what sorts of certificates are trusted.
   Another approach is to carry that information with the certificate,
   either as a certificate extension/attribute [PKIX, SPKI] or as a
   separate "Attribute Certificate".

4.5. Providing Traffic Security

   Securely designed protocols should provide some mechanism for
   securing (meaning integrity protecting, authenticating, and possibly
   encrypting) all sensitive traffic.  One approach is to secure the
   protocol itself, as in [DNSSEC], [S/MIME] or [S-HTTP].  Although this
   provides security which is most fitted to the protocol, it also
   requires considerable effort to get right.

   Many protocols can be adequately secured using one of the available
   channel security systems.  We'll discuss the two most common, IPsec
   [AH, ESP] and [TLS].

4.5.1. IPsec

   The IPsec protocols (specifically, AH and ESP) can provide
   transmission security for all traffic between two hosts.  The IPsec
   protocols support varying granularities of user identification,
   including for example "IP Subnet", "IP Address", "Fully Qualified
   Domain Name", and individual user ("Mailbox name").  These varying
   levels of identification are employed as inputs to access control
   facilities that are an intrinsic part of IPsec.  However, a given
   IPsec implementation might not support all identity types.  In
   particular, security gateways may not provide user-to-user
   authentication or have mechanisms to provide that authentication
   information to applications.

   When AH or ESP is used, the application programmer might not need to
   do anything (if AH or ESP has been enabled system-wide) or might need
   to make specific software changes (e.g., adding specific setsockopt()
   calls) -- depending on the AH or ESP implementation being used.
   Unfortunately, APIs for controlling IPsec implementations are not yet
   standardized.





Rescorla & Korver        Best Current Practice                 [Page 19]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   The primary obstacle to using IPsec to secure other protocols is
   deployment.  The major use of IPsec at present is for VPN
   applications, especially for remote network access.  Without
   extremely tight coordination between security administrators and
   application developers, VPN usage is not well suited to providing
   security services for individual applications since it is difficult
   for such applications to determine what security services have in
   fact been provided.

   IPsec deployment in host-to-host environments has been slow.  Unlike
   application security systems such as TLS, adding IPsec to a non-IPsec
   system generally involves changing the operating system, either by
   modifying with the kernel or installing new drivers.  This is a
   substantially greater undertaking than simply installing a new
   application.  However, recent versions of a number of commodity
   operating systems include IPsec stacks, so deployment is becoming
   easier.

   In environments where IPsec is sure to be available, it represents a
   viable option for protecting application communications traffic.  If
   the traffic to be protected is UDP, IPsec and application-specific
   object security are the only options.  However, designers MUST NOT
   assume that IPsec will be available.  A security policy for a generic
   application layer protocol SHOULD NOT simply state that IPsec must be
   used, unless there is some reason to believe that IPsec will be
   available in the intended deployment environment.  In environments
   where IPsec may not be available and the traffic is solely TCP, TLS
   is the method of choice, since the application developer can easily
   ensure its presence by including a TLS implementation in his package.

   In the special-case of IPv6, both AH and ESP are mandatory to
   implement.  Hence, it is reasonable to assume that AH/ESP are already
   available for IPv6-only protocols or IPv6-only deployments.  However,
   automatic key management (IKE) is not required to implement so
   protocol designers SHOULD not assume it will be present.  [USEIPSEC]
   provides quite a bit of guidance on when IPsec is a good choice.

4.5.2. SSL/TLS

   Currently, the most common approach is to use SSL or its successor
   TLS.  They provide channel security for a TCP connection at the
   application level.  That is, they run over TCP.  SSL implementations
   typically provide a Berkeley Sockets-like interface for easy
   programming.  The primary issue when designing a protocol solution
   around TLS is to differentiate between connections protected using
   TLS and those which are not.





Rescorla & Korver        Best Current Practice                 [Page 20]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   The two primary approaches used have a separate well-known port for
   TLS connections (e.g., the HTTP over TLS port is 443) [HTTPTLS] or to
   have a mechanism for negotiating upward from the base protocol to TLS
   as in [UPGRADE] or [STARTTLS].  When an upward negotiation strategy
   is used, care must be taken to ensure that an attacker can not force
   a clear connection when both parties wish to use TLS.

   Note that TLS depends upon a reliable protocol such as TCP or SCTP.
   This produces two notable difficulties.  First, it cannot be used to
   secure datagram protocols that use UDP.  Second, TLS is susceptible
   to IP layer attacks that IPsec is not.  Typically, these attacks take
   some form of denial of service or connection assassination.  For
   instance, an attacker might forge a TCP RST to shut down SSL
   connections.  TLS has mechanisms to detect truncation attacks but
   these merely allow the victim to know he is being attacked and do not
   provide connection survivability in the face of such attacks.  By
   contrast, if IPsec were being used, such a forged RST could be
   rejected without affecting the TCP connection.  If forged RSTs or
   other such attacks on the TCP connection are a concern, then AH/ESP
   or the TCP MD5 option [TCPMD5] are the preferred choices.

4.5.2.1. Virtual Hosts

   If the "separate ports" approach to TLS is used, then TLS will be
   negotiated before any application-layer traffic is sent.  This can
   cause a problem with protocols that use virtual hosts, such as
   [HTTP], since the server does not know which certificate to offer the
   client during the TLS handshake.  The TLS hostname extension [TLSEXT]
   can be used to solve this problem, although it is too new to have
   seen wide deployment.

4.5.2.2. Remote Authentication and TLS

   One difficulty with using TLS is that the server is authenticated via
   a certificate.  This can be inconvenient in environments where
   previously the only form of authentication was a password shared
   between client and server.  It's tempting to use TLS without an
   authenticated server (i.e., with anonymous DH or a self-signed RSA
   certificate) and then authenticate via some challenge-response
   mechanism such as SASL with CRAM-MD5.

   Unfortunately, this composition of SASL and TLS is less strong than
   one would expect.  It's easy for an active attacker to hijack this
   connection.  The client man-in-the-middles the SSL connection
   (remember we're not authenticating the server, which is what
   ordinarily prevents this attack) and then simply proxies the SASL
   handshake.  From then on, it's as if the connection were in the




Rescorla & Korver        Best Current Practice                 [Page 21]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   clear, at least as far as that attacker is concerned.  In order to
   prevent this attack, the client needs to verify the server's
   certificate.

   However, if the server is authenticated, challenge-response becomes
   less desirable.  If you already have a hardened channel then simple
   passwords are fine.  In fact, they're arguably superior to
   challenge-response since they do not require that the password be
   stored in the clear on the server.  Thus, compromise of the key file
   with challenge-response systems is more serious than if simple
   passwords were used.

   Note that if the client has a certificate than SSL-based client
   authentication can be used.  To make this easier, SASL provides the
   EXTERNAL mechanism, whereby the SASL client can tell the server
   "examine the outer channel for my identity".  Obviously, this is not
   subject to the layering attacks described above.

4.5.3. Remote Login

   In some special cases it may be worth providing channel-level
   security directly in the application rather than using IPSEC or
   SSL/TLS.  One such case is remote terminal security.  Characters are
   typically delivered from client to server one character at a time.
   Since SSL/TLS and AH/ESP authenticate and encrypt every packet, this
   can mean a data expansion of 20-fold.  The telnet encryption option
   [ENCOPT] prevents this expansion by foregoing message integrity.

   When using remote terminal service, it's often desirable to securely
   perform other sorts of communications services.  In addition to
   providing remote login, SSH [SSH] also provides secure port
   forwarding for arbitrary TCP ports, thus allowing users run arbitrary
   TCP-based applications over the SSH channel.  Note that SSH Port
   Forwarding can be security issue if it is used improperly to
   circumvent firewall and improperly expose insecure internal
   applications to the outside world.

4.6. Denial of Service Attacks and Countermeasures

   Denial of service attacks are all too frequently viewed as an fact of
   life.  One problem is that an attacker can often choose from one of
   many denial of service attacks to inflict upon a victim, and because
   most of these attacks cannot be thwarted, common wisdom frequently
   assumes that there is no point protecting against one kind of denial
   of service attack when there are many other denial of service attacks
   that are possible but that cannot be prevented.





Rescorla & Korver        Best Current Practice                 [Page 22]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   However, not all denial of service attacks are equal and more
   importantly, it is possible to design protocols so that denial of
   service attacks are made more difficult, if not impractical.  Recent
   SYN flood attacks [TCPSYN] demonstrate both of these properties: SYN
   flood attacks are so easy, anonymous, and effective that they are
   more attractive to attackers than other attacks; and because the
   design of TCP enables this attack.

   Because complete DoS protection is so difficult, security against DoS
   must be dealt with pragmatically.  In particular, some attacks which
   would be desirable to defend against cannot be defended against
   economically.  The goal should be to manage risk by defending against
   attacks with sufficiently high ratios of severity to cost of defense.
   Both severity of attack and cost of defense change as technology
   changes and therefore so does the set of attacks which should be
   defended against.

   Authors of internet standards MUST describe which denial of service
   attacks their protocol is susceptible to.  This description MUST
   include the reasons it was either unreasonable or out of scope to
   attempt to avoid these denial of service attacks.

4.6.1. Blind Denial of Service

   BLIND denial of service attacks are particularly pernicious.  With a
   blind attack the attacker has a significant advantage.  If the
   attacker must be able to receive traffic from the victim, then he
   must either subvert the routing fabric or use his own IP address.
   Either provides an opportunity for the victim to track the attacker
   and/or filter out his traffic.  With a blind attack the attacker can
   use forged IP addresses, making it extremely difficult for the victim
   to filter out his packets.  The TCP SYN flood attack is an example of
   a blind attack.  Designers should make every attempt possible to
   prevent blind denial of service attacks.

4.6.2. Distributed Denial of Service

   Even more dangerous are DISTRIBUTED denial of service attacks (DDoS)
   [DDOS].  In a DDoS the attacker arranges for a number of machines to
   attack the target machine simultaneously.  Usually this is
   accomplished by infecting a large number of machines with a program
   that allows remote initiation of attacks.  The machines actually
   performing the attack are called ZOMBIEs and are likely owned by
   unsuspecting third parties in an entirely different location from the
   true attacker.  DDoS attacks can be very hard to counter because the
   zombies often appear to be making legitimate protocol requests and





Rescorla & Korver        Best Current Practice                 [Page 23]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   simply crowd out the real users.  DDoS attacks can be difficult to
   thwart, but protocol designers are expected to be cognizant of these
   forms of attack while designing protocols.

4.6.3. Avoiding Denial of Service

   There are two common approaches to making denial of service attacks
   more difficult:

4.6.3.1. Make your attacker do more work than you do

   If an attacker consumes more of his resources than yours when
   launching an attack, attackers with fewer resources than you will be
   unable to launch effective attacks.  One common technique is to
   require the attacker perform a time-intensive operation, such as a
   cryptographic operation.  Note that an attacker can still mount a
   denial of service attack if he can muster substantially sufficient
   CPU power.  For instance, this technique would not stop the
   distributed attacks described in [TCPSYN].

4.6.3.2. Make your attacker prove they can receive data from you

   A blind attack can be subverted by forcing the attacker to prove that
   they can can receive data from the victim.  A common technique is to
   require that the attacker reply using information that was gained
   earlier in the message exchange.  If this countermeasure is used, the
   attacker must either use his own address (making him easy to track)
   or to forge an address which will be routed back along a path that
   traverses the host from which the attack is being launched.

   Hosts on small subnets are thus useless to the attacker (at least in
   the context of a spoofing attack) because the attack can be traced
   back to a subnet (which should be sufficient for locating the
   attacker) so that anti-attack measures can be put into place (for
   instance, a boundary router can be configured to drop all traffic
   from that subnet).  A common technique is to require that the
   attacker reply using information that was gained earlier in the
   message exchange.

4.6.4. Example: TCP SYN Floods

   TCP/IP is vulnerable to SYN flood attacks (which are described in
   section 3.3.2) because of the design of the 3-way handshake.  First,
   an attacker can force a victim to consume significant resources (in
   this case, memory) by sending a single packet.  Second, because the
   attacker can perform this action without ever having received data
   from the victim, the attack can be performed anonymously (and
   therefore using a large number of forged source addresses).



Rescorla & Korver        Best Current Practice                 [Page 24]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


4.6.5. Example: Photuris

   [PHOTURIS] specifies an anti-clogging mechanism that prevents attacks
   on Photuris that resemble the SYN flood attack.  Photuris employs a
   time-variant secret to generate a "cookie" which is returned to the
   attacker.  This cookie must be returned in subsequent messages for
   the exchange to progress.  The interesting feature is that this
   cookie can be regenerated by the victim later in the exchange, and
   thus no state need be retained by the victim until after the attacker
   has proven that he can receive packets from the victim.

4.7. Object vs. Channel Security

   It's useful to make the conceptual distinction between object
   security and channel security.  Object security refers to security
   measures which apply to entire data objects.  Channel security
   measures provide a secure channel over which objects may be carried
   transparently but the channel has no special knowledge about object
   boundaries.

   Consider the case of an email message.  When it's carried over an
   IPSEC or TLS secured connection, the message is protected during
   transmission.  However, it is unprotected in the receiver's mailbox,
   and in intermediate spool files along the way.  Moreover, since mail
   servers generally run as a daemon, not a user, authentication of
   messages generally merely means authentication of the daemon not the
   user.  Finally, since mail transport is hop-by-hop, even if the user
   authenticates to the first hop relay the authentication can't be
   safely verified by the receiver.

   By contrast, when an email message is protected with S/MIME or
   OpenPGP, the entire message is encrypted and integrity protected
   until it is examined and decrypted by the recipient.  It also
   provides strong authentication of the actual sender, as opposed to
   the machine the message came from.  This is object security.
   Moreover, the receiver can prove the signed message's authenticity to
   a third party.

   Note that the difference between object and channel security is a
   matter of perspective.  Object security at one layer of the protocol
   stack often looks like channel security at the next layer up.  So,
   from the perspective of the IP layer, each packet looks like an
   individually secured object.  But from the perspective of a web
   client, IPSEC just provides a secure channel.

   The distinction isn't always clear-cut.  For example, S-HTTP provides
   object level security for a single HTTP transaction, but a web page
   typically consists of multiple HTTP transactions (the base page and



Rescorla & Korver        Best Current Practice                 [Page 25]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   numerous inline images).  Thus, from the perspective of the total web
   page, this looks rather more like channel security.  Object security
   for a web page would consist of security for the transitive closure
   of the page and all its embedded content as a single unit.

4.8. Firewalls and Network Topology

   It's common security practice in modern networks to partition the
   network into external and internal networks using a firewall.  The
   internal network is then assumed to be secure and only limited
   security measures are used there.  The internal portion of such a
   network is often called a WALLED GARDEN.

   Internet protocol designers cannot safely assume that their protocols
   will be deployed in such an environment, for three reasons.  First,
   protocols which were originally designed to be deployed in closed
   environments often are later deployed on the Internet, thus creating
   serious vulnerabilities.

   Second, networks which appear to be topologically disconnected may
   not be.  One reason may be that the network has been reconfigured to
   allow access by the outside world.  Moreover, firewalls are
   increasingly passing generic application layer protocols such as
   [SOAP] or [HTTP].  Network protocols which are based on these generic
   protocols cannot in general assume that a firewall will protect them.
   Finally, one of the most serious security threats to systems is from
   insiders, not outsiders.  Since insiders by definition have access to
   the internal network, topological protections such as firewalls will
   not protect them.

5. Writing Security Considerations Sections

   While it is not a requirement that any given protocol or system be
   immune to all forms of attack, it is still necessary for authors to
   consider as many forms as possible.  Part of the purpose of the
   Security Considerations section is to explain what attacks are out of
   scope and what countermeasures can be applied to defend against them.
   In

   There should be a clear description of the kinds of threats on the
   described protocol or technology.  This should be approached as an
   effort to perform "due diligence" in describing all known or
   foreseeable risks and threats to potential implementers and users.








Rescorla & Korver        Best Current Practice                 [Page 26]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Authors MUST describe

      1.   which attacks are out of scope (and why!)
      2.   which attacks are in-scope
      2.1  and the protocol is susceptible to
      2.2  and the protocol protects against

   At least the following forms of attack MUST be considered:
   eavesdropping, replay, message insertion, deletion, modification, and
   man-in-the-middle.  Potential denial of service attacks MUST be
   identified as well.  If the protocol incorporates cryptographic
   protection mechanisms, it should be clearly indicated which portions
   of the data are protected and what the protections are (i.e.,
   integrity only, confidentiality, and/or endpoint authentication,
   etc.).  Some indication should also be given to what sorts of attacks
   the cryptographic protection is susceptible.  Data which should be
   held secret (keying material, random seeds, etc.) should be clearly
   labeled.

   If the technology involves authentication, particularly user-host
   authentication, the security of the authentication method MUST be
   clearly specified.  That is, authors MUST document the assumptions
   that the security of this authentication method is predicated upon.
   For instance, in the case of the UNIX username/password login method,
   a statement to the effect of:

      Authentication in the system is secure only to the extent that it
      is difficult to guess or obtain a ASCII password that is a maximum
      of 8 characters long.  These passwords can be obtained by sniffing
      telnet sessions or by running the 'crack' program using the
      contents of the /etc/passwd file.  Attempts to protect against
      on-line password guessing by (1) disconnecting after several
      unsuccessful login attempts and (2) waiting between successive
      password prompts is effective only to the extent that attackers
      are impatient.

      Because the /etc/passwd file maps usernames to user ids, groups,
      etc. it must be world readable.  In order to permit this usage but
      make running crack more difficult, the file is often split into
      /etc/passwd and a 'shadow' password file.  The shadow file is not
      world readable and contains the encrypted password.  The regular
      /etc/passwd file contains a dummy password in its place.

   It is insufficient to simply state that one's protocol should be run
   over some lower layer security protocol.  If a system relies upon
   lower layer security services for security, the protections those





Rescorla & Korver        Best Current Practice                 [Page 27]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   services are expected to provide MUST be clearly specified.  In
   addition, the resultant properties of the combined system need to be
   specified.

   Note: In general, the IESG will not approve standards track protocols
   which do not provide for strong authentication, either internal to
   the protocol or through tight binding to a lower layer security
   protocol.

   The threat environment addressed by the Security Considerations
   section MUST at a minimum include deployment across the global
   Internet across multiple administrative boundaries without assuming
   that firewalls are in place, even if only to provide justification
   for why such consideration is out of scope for the protocol.  It is
   not acceptable to only discuss threats applicable to LANs and ignore
   the broader threat environment.  All IETF standards-track protocols
   are considered likely to have deployment in the global Internet.  In
   some cases, there might be an Applicability Statement discouraging
   use of a technology or protocol in a particular environment.
   Nonetheless, the security issues of broader deployment should be
   discussed in the document.

   There should be a clear description of the residual risk to the user
   or operator of that protocol after threat mitigation has been
   deployed.  Such risks might arise from compromise in a related
   protocol (e.g., IPsec is useless if key management has been
   compromised), from incorrect implementation, compromise of the
   security technology used for risk reduction (e.g., a cipher with a
   40-bit key), or there might be risks that are not addressed by the
   protocol specification (e.g., denial of service attacks on an
   underlying link protocol).  Particular care should be taken in
   situations where the compromise of a single system would compromise
   an entire protocol.  For instance, in general protocol designers
   assume that end-systems are inviolate and don't worry about physical
   attack.  However, in cases (such as a certificate authority) where
   compromise of a single system could lead to widespread compromises,
   it is appropriate to consider systems and physical security as well.

   There should also be some discussion of potential security risks
   arising from potential misapplications of the protocol or technology
   described in the RFC.  This might be coupled with an Applicability
   Statement for that RFC.

6. Examples

   This section consists of some example security considerations
   sections, intended to give the reader a flavor of what's intended by
   this document.



Rescorla & Korver        Best Current Practice                 [Page 28]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   The first example is a 'retrospective' example, applying the criteria
   of this document to an existing widely deployed protocol, SMTP.  The
   second example is a good security considerations section clipped from
   a current protocol.

6.1. SMTP

   When RFC 821 was written, Security Considerations sections were not
   required in RFCs, and none is contained in that document.  [RFC 2821]
   updated RFC 821 and added a detailed security considerations section.
   We reproduce here the Security Considerations section from that
   document (with new section numbers).  Our comments are indented and
   prefaced with 'NOTE:'.  We also add a number of new sections to cover
   topics we consider important.  Those sections are marked with [NEW]
   in the section header.

6.1.1. Security Considerations

6.1.1.1. Mail Security and Spoofing

   SMTP mail is inherently insecure in that it is feasible for even
   fairly casual users to negotiate directly with receiving and relaying
   SMTP servers and create messages that will trick a naive recipient
   into believing that they came from somewhere else.  Constructing such
   a message so that the "spoofed" behavior cannot be detected by an
   expert is somewhat more difficult, but not sufficiently so as to be a
   deterrent to someone who is determined and knowledgeable.
   Consequently, as knowledge of Internet mail increases, so does the
   knowledge that SMTP mail inherently cannot be authenticated, or
   integrity checks provided, at the transport level.  Real mail
   security lies only in end-to-end methods involving the message
   bodies, such as those which use digital signatures (see [14] and,
   e.g., PGP [4] or S/MIME [31]).

      NOTE: One bad approach to sender authentication is [IDENT] in
      which the receiving mail server contacts the alleged sender and
      asks for the username of the sender.  This is a bad idea for a
      number of reasons, including but not limited to relaying, TCP
      connection hijacking, and simple lying by the origin server.
      Aside from the fact that IDENT is of low security value, use of
      IDENT by receiving sites can lead to operational problems.  Many
      sending sites blackhole IDENT requests, thus causing mail to be
      held until the receiving server's IDENT request times out.

   Various protocol extensions and configuration options that provide
   authentication at the transport level (e.g., from an SMTP client to
   an SMTP server) improve somewhat on the traditional situation
   described above.  However, unless they are accompanied by careful



Rescorla & Korver        Best Current Practice                 [Page 29]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   handoffs of responsibility in a carefully-designed trust environment,
   they remain inherently weaker than end-to-end mechanisms which use
   digitally signed messages rather than depending on the integrity of
   the transport system.

   Efforts to make it more difficult for users to set envelope return
   path and header "From" fields to point to valid addresses other than
   their own are largely misguided: they frustrate legitimate
   applications in which mail is sent by one user on behalf of another
   or in which error (or normal) replies should be directed to a special
   address.  (Systems that provide convenient ways for users to alter
   these fields on a per-message basis should attempt to establish a
   primary and permanent mailbox address for the user so that Sender
   fields within the message data can be generated sensibly.)

   This specification does not further address the authentication issues
   associated with SMTP other than to advocate that useful functionality
   not be disabled in the hope of providing some small margin of
   protection against an ignorant user who is trying to fake mail.

      NOTE: We have added additional material on communications security
      and SMTP in Section 6.1.2 In a final specification, the above text
      would be edited somewhat to reflect that fact.

6.1.1.2. Blind Copies

   Addresses that do not appear in the message headers may appear in the
   RCPT commands to an SMTP server for a number of reasons.  The two
   most common involve the use of a mailing address as a "list exploder"
   (a single address that resolves into multiple addresses) and the
   appearance of "blind copies".  Especially when more than one RCPT
   command is present, and in order to avoid defeating some of the
   purpose of these mechanisms, SMTP clients and servers SHOULD NOT copy
   the full set of RCPT command arguments into the headers, either as
   part of trace headers or as informational or private-extension
   headers.  Since this rule is often violated in practice, and cannot
   be enforced, sending SMTP systems that are aware of "bcc" use MAY
   find it helpful to send each blind copy as a separate message
   transaction containing only a single RCPT command.

   There is no inherent relationship between either "reverse" (from
   MAIL, SAML, etc., commands) or "forward" (RCPT) addresses in the SMTP
   transaction ("envelope") and the addresses in the headers.  Receiving
   systems SHOULD NOT attempt to deduce such relationships and use them







Rescorla & Korver        Best Current Practice                 [Page 30]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   to alter the headers of the message for delivery.  The popular
   "Apparently-to" header is a violation of this principle as well as a
   common source of unintended information disclosure and SHOULD NOT be
   used.

6.1.1.3. VRFY, EXPN, and Security

   As discussed in section 3.5, individual sites may want to disable
   either or both of VRFY or EXPN for security reasons.  As a corollary
   to the above, implementations that permit this MUST NOT appear to
   have verified addresses that are not, in fact, verified.  If a site
   disables these commands for security reasons, the SMTP server MUST
   return a 252 response, rather than a code that could be confused with
   successful or unsuccessful verification.

   Returning a 250 reply code with the address listed in the VRFY
   command after having checked it only for syntax violates this rule.
   Of course, an implementation that "supports" VRFY by always returning
   550 whether or not the address is valid is equally not in
   conformance.

   Within the last few years, the contents of mailing lists have become
   popular as an address information source for so-called "spammers."
   The use of EXPN to "harvest" addresses has increased as list
   administrators have installed protections against inappropriate uses
   of the lists themselves.  Implementations SHOULD still provide
   support for EXPN, but sites SHOULD carefully evaluate the tradeoffs.
   As authentication mechanisms are introduced into SMTP, some sites may
   choose to make EXPN available only to authenticated requesters.

      NOTE: It's not clear that disabling VRFY adds much protection,
      since it's often possible to discover whether an address is valid
      using RCPT TO.

6.1.1.4. Information Disclosure in Announcements

   There has been an ongoing debate about the tradeoffs between the
   debugging advantages of announcing server type and version (and,
   sometimes, even server domain name) in the greeting response or in
   response to the HELP command and the disadvantages of exposing
   information that might be useful in a potential hostile attack.  The
   utility of the debugging information is beyond doubt.  Those who
   argue for making it available point out that it is far better to
   actually secure an SMTP server rather than hope that trying to
   conceal known vulnerabilities by hiding the server's precise identity
   will provide more protection.  Sites are encouraged to evaluate the





Rescorla & Korver        Best Current Practice                 [Page 31]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   tradeoff with that issue in mind; implementations are strongly
   encouraged to minimally provide for making type and version
   information available in some way to other network hosts.

6.1.1.5. Information Disclosure in Trace Fields

   In some circumstances, such as when mail originates from within a LAN
   whose hosts are not directly on the public Internet, trace
   ("Received") fields produced in conformance with this specification
   may disclose host names and similar information that would not
   normally be available.  This ordinarily does not pose a problem, but
   sites with special concerns about name disclosure should be aware of
   it.  Also, the optional FOR clause should be supplied with caution or
   not at all when multiple recipients are involved lest it
   inadvertently disclose the identities of "blind copy" recipients to
   others.

6.1.1.6. Information Disclosure in Message Forwarding

   As discussed in section 3.4, use of the 251 or 551 reply codes to
   identify the replacement address associated with a mailbox may
   inadvertently disclose sensitive information.  Sites that are
   concerned about those issues should ensure that they select and
   configure servers appropriately.

6.1.1.7. Scope of Operation of SMTP Servers

   It is a well-established principle that an SMTP server may refuse to
   accept mail for any operational or technical reason that makes sense
   to the site providing the server.  However, cooperation among sites
   and installations makes the Internet possible.  If sites take
   excessive advantage of the right to reject traffic, the ubiquity of
   email availability (one of the strengths of the Internet) will be
   threatened; considerable care should be taken and balance maintained
   if a site decides to be selective about the traffic it will accept
   and process.

   In recent years, use of the relay function through arbitrary sites
   has been used as part of hostile efforts to hide the actual origins
   of mail.  Some sites have decided to limit the use of the relay
   function to known or identifiable sources, and implementations SHOULD
   provide the capability to perform this type of filtering.  When mail
   is rejected for these or other policy reasons, a 550 code SHOULD be
   used in response to EHLO, MAIL, or RCPT as appropriate.







Rescorla & Korver        Best Current Practice                 [Page 32]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


6.1.1.8. Inappropriate Usage [NEW]

   SMTP itself provides no protection is provided against unsolicited
   commercial mass e-mail (aka spam).  It is extremely difficult to tell
   a priori whether a given message is spam or not.  From a protocol
   perspective, spam is indistinguishable from other e-mail -- the
   distinction is almost entirely social and often quite subtle.  (For
   instance, is a message from a merchant from whom you've purchased
   items before advertising similar items spam?) SMTP spam-suppression
   mechanisms are generally limited to identifying known spam senders
   and either refusing to service them or target them for
   punishment/disconnection.  [RFC-2505] provides extensive guidance on
   making SMTP servers spam-resistant.  We provide a brief discussion of
   the topic here.

   The primary tool for refusal to service spammers is the blacklist.
   Some authority such as [MAPS] collects and publishes a list of known
   spammers.  Individual SMTP servers then block the blacklisted
   offenders (generally by IP address).

   In order to avoid being blacklisted or otherwise identified, spammers
   often attempt to obscure their identity, either simply by sending a
   false SMTP identity or by forwarding their mail through an Open Relay
   -- an SMTP server which will perform mail relaying for any sender.
   As a consequence, there are now blacklists [ORBS] of open relays as
   well.

6.1.1.8.1. Closed Relaying [NEW]

   To avoid being used for spam forwarding, many SMTP servers operate as
   closed relays, providing relaying service only for clients who they
   can identify.  Such relays should generally insist that senders
   advertise a sending address consistent with their known identity.  If
   the relay is providing service for an identifiable network (such as a
   corporate network or an ISP's network) then it is sufficient to block
   all other IP addresses).  In other cases, explicit authentication
   must be used.  The two standard choices for this are TLS [STARTTLS]
   and SASL [SASLSMTP].

6.1.1.8.2. Endpoints [NEW]

   Realistically, SMTP endpoints cannot refuse to deny service to
   unauthenticated senders.  Since the vast majority of senders are
   unauthenticated, this would break Internet mail interoperability.
   The exception to this is when the endpoint server should only be






Rescorla & Korver        Best Current Practice                 [Page 33]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   receiving mail from some other server which can itself receive
   unauthenticated messages.  For instance, a company might operate a
   public gateway but configure its internal servers to only talk to the
   gateway.

6.1.2. Communications security issues [NEW]

   SMTP itself provides no communications security, and therefore a
   large number of attacks are possible.  A passive attack is sufficient
   to recover the text of messages transmitted with SMTP.  No endpoint
   authentication is provided by the protocol.  Sender spoofing is
   trivial, and therefore forging email messages is trivial.  Some
   implementations do add header lines with hostnames derived through
   reverse name resolution (which is only secure to the extent that it
   is difficult to spoof DNS -- not very), although these header lines
   are normally not displayed to users.  Receiver spoofing is also
   fairly straight-forward, either using TCP connection hijacking or DNS
   spoofing.  Moreover, since email messages often pass through SMTP
   gateways, all intermediate gateways must be trusted, a condition
   nearly impossible on the global Internet.

   Several approaches are available for alleviating these threats.  In
   order of increasingly high level in the protocol stack, we have:

      SMTP over IPSEC
      SMTP/TLS
      S/MIME and PGP/MIME

6.1.2.1. SMTP over IPSEC [NEW]

   An SMTP connection run over IPSEC can provide confidentiality for the
   message between the sender and the first hop SMTP gateway, or between
   any pair of connected SMTP gateways.  That is to say, it provides
   channel security for the SMTP connections.  In a situation where the
   message goes directly from the client to the receiver's gateway, this
   may provide substantial security (though the receiver must still
   trust the gateway).  Protection is provided against replay attacks,
   since the data itself is protected and the packets cannot be
   replayed.

   Endpoint identification is a problem, however, unless the receiver's
   address can be directly cryptographically authenticated.  Sender
   identification is not generally available, since generally only the
   sender's machine is authenticated, not the sender himself.
   Furthermore, the identity of the sender simply appears in the From
   header of the message, so it is easily spoofable by the sender.
   Finally, unless the security policy is set extremely strictly, there
   is also an active downgrade to cleartext attack.



Rescorla & Korver        Best Current Practice                 [Page 34]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Another problem with IPsec as a security solution for SMTP is the
   lack of a standard IPsec API.  In order to take advantage of IPsec,
   applications in general need to be able to instruct the IPsec
   implementation about their security policies and discover what
   protection has been applied to their connections.  Without a standard
   API this is very difficult to do portably.

   Implementors of SMTP servers or SMTP administrators MUST NOT assume
   that IPsec will be available unless they have reason to believe that
   it will be (such as the existence of preexisting association between
   two machines).  However, it may be a reasonable procedure to attempt
   to create an IPsec association opportunistically to a peer server
   when mail is delivered.  Note that in cases where IPsec is used to
   provide a VPN tunnel between two sites, this is of substantial
   security value, particularly to the extent that confidentiality is
   provided, subject to the caveats mentioned above.  Also see
   [USEIPSEC] for general guidance on the applicability of IPsec.

6.1.2.2. SMTP/TLS [NEW]

   SMTP can be combined with TLS as described in [STARTTLS].  This
   provides similar protection to that provided when using IPSEC.  Since
   TLS certificates typically contain the server's host name, recipient
   authentication may be slightly more obvious, but is still susceptible
   to DNS spoofing attacks.  Notably, common implementations of TLS
   contain a US exportable (and hence low security) mode.  Applications
   desiring high security should ensure that this mode is disabled.
   Protection is provided against replay attacks, since the data itself
   is protected and the packets cannot be replayed.  [Note:  The
   Security Considerations section of the SMTP over TLS document is
   quite good and bears reading as an example of how to do things.]

6.1.2.3. S/MIME and PGP/MIME [NEW]

   S/MIME and PGP/MIME are both message oriented security protocols.
   They provide object security for individual messages.  With various
   settings, sender and recipient authentication and confidentiality may
   be provided.  More importantly, the identification is not of the
   sending and receiving machines, but rather of the sender and
   recipient themselves.  (Or, at least, of cryptographic keys
   corresponding to the sender and recipient.)  Consequently, end-to-end
   security may be obtained.  Note, however, that no protection is
   provided against replay attacks.  Note also that S/MIME and PGP/MIME
   generally provide identifying marks for both sender and receiver.
   Thus even when confidentiality is provided, traffic analysis is still
   possible.





Rescorla & Korver        Best Current Practice                 [Page 35]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


6.1.3. Denial of Service [NEW]

   None of these security measures provides any real protection against
   denial of service.  SMTP connections can easily be used to tie up
   system resources in a number of ways, including excessive port
   consumption, excessive disk usage (email is typically delivered to
   disk files), and excessive memory consumption (sendmail, for
   instance, is fairly large, and typically forks a new process to deal
   with each message.)

   If transport- or application-layer security is used for SMTP
   connections, it is possible to mount a variety of attacks on
   individual connections using forged RSTs or other kinds of packet
   injection.

6.2. VRRP

   The second example is from VRRP, the Virtual Router Redundance
   Protocol ([VRRP]).  We reproduce here the Security Considerations
   section from that document (with new section numbers).  Our comments
   are indented and prefaced with 'NOTE:'.

6.2.1. Security Considerations

   VRRP is designed for a range of internetworking environments that may
   employ different security policies.  The protocol includes several
   authentication methods ranging from no authentication, simple clear
   text passwords, and strong authentication using IP Authentication
   with MD5 HMAC.  The details on each approach including possible
   attacks and recommended environments follows.

   Independent of any authentication type VRRP includes a mechanism
   (setting TTL=255, checking on receipt) that protects against VRRP
   packets being injected from another remote network.  This limits most
   vulnerabilities to local attacks.

      NOTE: The security measures discussed in the following sections
      only provide various kinds of authentication.  No confidentiality
      is provided at all.  This should be explicitly described as
      outside the scope.

6.2.1.1. No Authentication

   The use of this authentication type means that VRRP protocol
   exchanges are not authenticated.  This type of authentication SHOULD
   only be used in environments were there is minimal security risk and
   little chance for configuration errors (e.g., two VRRP routers on a
   LAN).



Rescorla & Korver        Best Current Practice                 [Page 36]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


6.2.1.2. Simple Text Password

   The use of this authentication type means that VRRP protocol
   exchanges are authenticated by a simple clear text password.

   This type of authentication is useful to protect against accidental
   misconfiguration of routers on a LAN.  It protects against routers
   inadvertently backing up another router.  A new router must first be
   configured with the correct password before it can run VRRP with
   another router.  This type of authentication does not protect against
   hostile attacks where the password can be learned by a node snooping
   VRRP packets on the LAN.  The Simple Text Authentication combined
   with the TTL check makes it difficult for a VRRP packet to be sent
   from another LAN to disrupt VRRP operation.

   This type of authentication is RECOMMENDED when there is minimal risk
   of nodes on a LAN actively disrupting VRRP operation.  If this type
   of authentication is used the user should be aware that this clear
   text password is sent frequently, and therefore should not be the
   same as any security significant password.

      NOTE: This section should be clearer.  The basic point is that no
      authentication and Simple Text are only useful for a very limited
      threat model, namely that none of the nodes on the local LAN are
      hostile.  The TTL check prevents hostile nodes off-LAN from posing
      as valid nodes, but nothing stops hostile nodes on-LAN from
      impersonating authorized nodes.  This is not a particularly
      realistic threat model in many situations.  In particular, it's
      extremely brittle: the compromise of any node the LAN allows
      reconfiguration of the VRRP nodes.

6.2.1.3. IP Authentication Header

   The use of this authentication type means the VRRP protocol exchanges
   are authenticated using the mechanisms defined by the IP
   Authentication Header [AH] using [HMAC].  This provides strong
   protection against configuration errors, replay attacks, and packet
   corruption/modification.

   This type of authentication is RECOMMENDED when there is limited
   control over the administration of nodes on a LAN.  While this type
   of authentication does protect the operation of VRRP, there are other
   types of attacks that may be employed on shared media links (e.g.,
   generation of bogus ARP replies) which are independent from VRRP and
   are not protected.






Rescorla & Korver        Best Current Practice                 [Page 37]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


      NOTE: It's a mistake to have AH be a RECOMMENDED in this context.
      Since AH is the only mechanism that protects VRRP against attack
      from other nodes on the same LAN, it should be a MUST for cases
      where there are untrusted nodes on the same network.  In any case,
      AH should be a MUST implement.

      NOTE: There's an important piece of security analysis that's only
      hinted at in this document, namely the cost/benefit tradeoff of
      VRRP authentication.

   [The rest of this section is NEW material]
   The threat that VRRP authentication is intended to prevent is an
   attacker arranging to be the VRRP master.  This would be done by
   joining the group (probably multiple times), gagging the master and
   then electing oneself master.  Such a node could then direct traffic
   in arbitrary undesirable ways.

   However, it is not necessary for an attacker to be the VRRP master to
   do this.  An attacker can do similar kinds of damage to the network
   by forging ARP packets or (on switched networks) fooling the switch
   VRRP authentication offers no real protection against these attacks.

   Unfortunately, authentication makes VRRP networks very brittle in the
   face of misconfiguration.  Consider what happens if two nodes are
   configured with different passwords.  Each will reject messages from
   the other and therefore both will attempt to be master.  This creates
   substantial network instability.

   This set of cost/benefit tradeoffs suggests that VRRP authentication
   is a bad idea, since the incremental security benefit is marginal but
   the incremental risk is high.  This judgment should be revisited if
   the current set of non-VRRP threats are removed.

7. Acknowledgments

   This document is heavily based on a note written by Ran Atkinson in
   1997.  That note was written after the IAB Security Workshop held in
   early 1997, based on input from everyone at that workshop.  Some of
   the specific text above was taken from Ran's original document, and
   some of that text was taken from an email message written by Fred
   Baker.  The other primary source for this document is specific
   comments received from Steve Bellovin.  Early review of this document
   was done by Lisa Dusseault and Mark Schertler.  Other useful comments
   were received from Bill Fenner, Ned Freed, Lawrence Greenfield, Steve
   Kent, Allison Mankin and Kurt Zeilenga.






Rescorla & Korver        Best Current Practice                 [Page 38]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


8. Normative References

   [AH]       Kent, S. and R. Atkinson, "IP Authentication Header", RFC
              2402, November 1998.

   [DNSSEC]   Eastlake, D., "Domain Name System Security Extensions",
              RFC 2535, March 1999.

   [ENCOPT]   Tso, T., "Telnet Data Encryption Option", RFC 2946,
              September, 2000.

   [ESP]      Kent, S. and R. Atkinson, "IP Encapsulating Security
              Payload (ESP)", RFC 2406, November 1998.

   [GSS]      Linn, J., "Generic Security Services Application Program
              Interface Version 2, Update 1", RFC 2743, January 2000.

   [HTTP]     Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P. and T. Berners-Lee, "HyperText
              Transfer Protocol", RFC 2616, June 1999.

   [HTTPTLS]  Rescorla, E., "HTTP over TLS", RFC 2818, May 2000.

   [HMAC]     Madson, C. and R. Glenn, "The Use of HMAC-MD5-96 within
              ESP and AH", RFC 2403, November 1998.

   KERBEROS]  Kohl, J. and C. Neuman, "The Kerberos Network
              Authentication Service (V5)", RFC 1510, September 1993.

   [KEYWORDS] Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [OTP]      Haller, N., Metz, C., Nesser, P. and M. Straw, "A One-Time
              Password System", STD 61, RFC 2289, February 1998.

   [PHOTURIS] Karn, P. and W. Simpson, "Photuris: Session-Key Management
              Protocol", RFC 2522, March 1999.

   [PKIX]     Housley, R., Polk, W., Ford, W. and D. Solo, "Internet
              X.509 "Public Key Infrastructure Certificate and
              Certificate Restoration List (CRL) Profile", RFC 3280,
              April 2002.

   [RFC-2223] Postel J. and J. Reynolds, "Instructions to RFC Authors",
              RFC 2223, October 1997.

   [RFC-2505] Lindberg, G., "Anti-Spam Recommendations for SMTP MTAs",
              BCP 30, RFC 2505, February 1999.



Rescorla & Korver        Best Current Practice                 [Page 39]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   [RFC-2821] Klensin, J., "Simple Mail Transfer Protocol", RFC 2821,
              April 2001.

   [SASL]     Myers, J., "Simple Authentication and Security Layer
              (SASL)", RFC 2222, October 1997.

   [SPKI]     Ellison, C., Frantz, B., Lampson, B., Rivest, R., Thomas,
              B. and T. Ylonen, "SPKI Certificate Theory",  RFC 2693,
              September 1999.

   [SSH]      Ylonen, T., "SSH - Secure Login Connections Over the
              Internet", 6th USENIX Security Symposium, p. 37-42, July
              1996.

   [SASLSMTP] Myers, J., "SMTP Service Extension for Authentication",
              RFC 2554, March 1999.

   [STARTTLS] Hoffman, P., "SMTP Service Extension for Secure SMTP over
              Transport Layer Security", RFC 3207, February 2002.

   [S-HTTP]   Rescorla, E. and A. Schiffman, "The Secure HyperText
              Transfer Protocol", RFC 2660, August 1999.

   [S/MIME]   Ramsdell, B., Editor, "S/MIME Version 3 Message
              Specification", RFC 2633, June 1999.

   [TELNET]   Postel, J. and J. Reynolds, "Telnet Protocol
              Specification", STD 8, RFC 854, May 1983.

   [TLS]      Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              RFC 2246, January 1999.

   [TLSEXT]   Blake-Wilson, S., Nystrom, M., Hopwood, D. and J.
              Mikkelsen, "Transport Layer Security (TLS) Extensions",
              RFC 3546, May 2003.

   [TCPSYN]   "TCP SYN Flooding and IP Spoofing Attacks", CERT Advisory
              CA-1996-21, 19 September 1996, CERT.
              http://www.cert.org/advisories/CA-1996-21.html

   [UPGRADE]  Khare, R. and S. Lawrence, "Upgrading to TLS Within
              HTTP/1.1", RFC 2817, May 2000.

   [URL]      Berners-Lee, T., Masinter, M. and M. McCahill, "Uniform
              Resource Locators (URL)", RFC 1738, December 1994.






Rescorla & Korver        Best Current Practice                 [Page 40]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   [VRRP]     Knight, S., Weaver, D., Whipple, D., Hinden, R., Mitzel,
              D., Hunt, P., Higginson, P., Shand, M. and A. Lindemn,
              "Virtual Router Redundancy Protocol", RFC 2338, April
              1998.

9. Informative References

   [DDOS]     "Denial-Of-Service Tools" CERT Advisory CA-1999-17, 28
              December 1999, CERT http://www.cert.org/advisories/CA-
              1999-17.html

   [EKE]      Bellovin, S., Merritt, M., "Encrypted Key Exchange:
              Password-based protocols secure against dictionary
              attacks", Proceedings of the IEEE Symposium on Research in
              Security and Privacy, May 1992.

   [IDENT]    St. Johns, M. and M. Rose, "Identification Protocol", RFC
              1414, February 1993.

   [INTAUTH]  Haller, N. and R. Atkinson, "On Internet Authentication",
              RFC 1704, October 1994.

   [IPSPPROB] Bellovin, S. M., "Problem Areas for the IP Security
              Protocols", Proceedings of the Sixth Usenix UNIX Security
              Symposium, July 1996.

   [KLEIN]    Klein, D.V., "Foiling the Cracker: A Survey of and
              Improvements to Password Security",  1990.

   [NNTP]     Kantor, B. and P. Lapsley, "Network News Transfer
              Protocol", RFC 977, February 1986.

   [POP]      Myers, J. and M. Rose, "Post Office Protocol - Version 3",
              STD 53, RFC 1939, May 1996.

   [SEQNUM]   Morris, R.T., "A Weakness in the 4.2 BSD UNIX TCP/IP
              Software", AT&T Bell Laboratories, CSTR 117, 1985.

   [SOAP]     Box, D., Ehnebuske, D., Kakivaya, G., Layman, A.,
              Mendelsoh, N., Nielsen, H., Thatte, S., Winer, D., "Simple
              Object Access Protocol (SOAP) 1.1", May 2000.

   [SPEKE]    Jablon, D., "Strong Password-Only Authenticated Key
              Exchange", Computer Communication Review, ACM SIGCOMM,
              vol. 26, no. 5, pp. 5-26, October 1996.

   [SRP]      Wu T., "The Secure Remote Password Protocol", ISOC NDSS
              Symposium, 1998.



Rescorla & Korver        Best Current Practice                 [Page 41]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   [USEIPSEC] Bellovin, S., "Guidelines for Mandating the Use of IPsec",
              Work in Progress.

   [WEP]      Borisov, N., Goldberg, I., Wagner, D., "Intercepting
              Mobile Communications: The Insecurity of 802.11",
              http://www.isaac.cs.berkeley.edu/isaac/wep-draft.pdf

10. Security Considerations

   This entire document is about security considerations.









































Rescorla & Korver        Best Current Practice                 [Page 42]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


Appendix A.

   IAB Members at the time of this writing

   Harald Alvestrand
   Ran Atkinson
   Rob Austein
   Fred Baker
   Leslie Daigle
   Steve Deering
   Sally Floyd
   Ted Hardie
   Geoff Huston
   Charlie Kaufman
   James Kempf
   Eric Rescorla
   Mike St. Johns

Authors' Addresses

   Eric Rescorla
   RTFM, Inc.
   2439 Alvin Drive
   Mountain View, CA 94043

   Phone: (650)-320-8549
   EMail: ekr@rtfm.com


   Brian Korver
   Xythos Software, Inc.
   77 Maiden Lane, 6th Floor
   San Francisco, CA, 94108

   Phone: (415)-248-3800
   EMail: briank@xythos.com


   Internet Architecture Board
   IAB
   EMail: iab@iab.org










Rescorla & Korver        Best Current Practice                 [Page 43]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


Full Copyright Statement

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Rescorla & Korver        Best Current Practice                 [Page 44]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2] [IPR]
   [Errata]
   Obsoleted by: 8446 PROPOSED STANDARD
   Updated by: 5746, 5878, 6176, 7465, 7507, 7568, 7627, 7685, 7905, 7919,
   8447 Errata Exist
Network Working Group                                          T. Dierks
Request for Comments: 5246                                   Independent
Obsoletes: 3268, 4346, 4366                                  E. Rescorla
Updates: 4492                                                 RTFM, Inc.
Category: Standards Track                                    August 2008


              The Transport Layer Security (TLS) Protocol
                              Version 1.2

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   This document specifies Version 1.2 of the Transport Layer Security
   (TLS) protocol.  The TLS protocol provides communications security
   over the Internet.  The protocol allows client/server applications to
   communicate in a way that is designed to prevent eavesdropping,
   tampering, or message forgery.

Table of Contents

   1. Introduction ....................................................4
      1.1. Requirements Terminology ...................................5
      1.2. Major Differences from TLS 1.1 .............................5
   2. Goals ...........................................................6
   3. Goals of This Document ..........................................7
   4. Presentation Language ...........................................7
      4.1. Basic Block Size ...........................................7
      4.2. Miscellaneous ..............................................8
      4.3. Vectors ....................................................8
      4.4. Numbers ....................................................9
      4.5. Enumerateds ................................................9
      4.6. Constructed Types .........................................10
           4.6.1. Variants ...........................................10
      4.7. Cryptographic Attributes ..................................12
      4.8. Constants .................................................14
   5. HMAC and the Pseudorandom Function .............................14
   6. The TLS Record Protocol ........................................15
      6.1. Connection States .........................................16
      6.2. Record Layer ..............................................19
           6.2.1. Fragmentation ......................................19



Dierks & Rescorla           Standards Track                     [Page 1]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


           6.2.2. Record Compression and Decompression ...............20
           6.2.3. Record Payload Protection ..........................21
                  6.2.3.1. Null or Standard Stream Cipher ............22
                  6.2.3.2. CBC Block Cipher ..........................22
                  6.2.3.3. AEAD Ciphers ..............................24
      6.3. Key Calculation ...........................................25
   7. The TLS Handshaking Protocols ..................................26
      7.1. Change Cipher Spec Protocol ...............................27
      7.2. Alert Protocol ............................................28
           7.2.1. Closure Alerts .....................................29
           7.2.2. Error Alerts .......................................30
      7.3. Handshake Protocol Overview ...............................33
      7.4. Handshake Protocol ........................................37
           7.4.1. Hello Messages .....................................38
                  7.4.1.1. Hello Request .............................38
                  7.4.1.2. Client Hello ..............................39
                  7.4.1.3. Server Hello ..............................42
                  7.4.1.4. Hello Extensions ..........................44
                           7.4.1.4.1. Signature Algorithms ...........45
           7.4.2. Server Certificate .................................47
           7.4.3. Server Key Exchange Message ........................50
           7.4.4. Certificate Request ................................53
           7.4.5. Server Hello Done ..................................55
           7.4.6. Client Certificate .................................55
           7.4.7. Client Key Exchange Message ........................57
                  7.4.7.1. RSA-Encrypted Premaster Secret Message ....58
                  7.4.7.2. Client Diffie-Hellman Public Value ........61
           7.4.8. Certificate Verify .................................62
           7.4.9. Finished ...........................................63
   8. Cryptographic Computations .....................................64
      8.1. Computing the Master Secret ...............................64
           8.1.1. RSA ................................................65
           8.1.2. Diffie-Hellman .....................................65
   9. Mandatory Cipher Suites ........................................65
   10. Application Data Protocol .....................................65
   11. Security Considerations .......................................65
   12. IANA Considerations ...........................................65
   Appendix A. Protocol Data Structures and Constant Values ..........68
      A.1. Record Layer ..............................................68
      A.2. Change Cipher Specs Message ...............................69
      A.3. Alert Messages ............................................69
      A.4. Handshake Protocol ........................................70
           A.4.1. Hello Messages .....................................71
           A.4.2. Server Authentication and Key Exchange Messages ....72
           A.4.3. Client Authentication and Key Exchange Messages ....74
           A.4.4. Handshake Finalization Message .....................74
      A.5. The Cipher Suite ..........................................75
      A.6. The Security Parameters ...................................77



Dierks & Rescorla           Standards Track                     [Page 2]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      A.7. Changes to RFC 4492 .......................................78
   Appendix B. Glossary ..............................................78
   Appendix C. Cipher Suite Definitions ..............................83
   Appendix D. Implementation Notes ..................................85
      D.1. Random Number Generation and Seeding ......................85
      D.2. Certificates and Authentication ...........................85
      D.3. Cipher Suites .............................................85
      D.4. Implementation Pitfalls ...................................85
   Appendix E. Backward Compatibility ................................87
      E.1. Compatibility with TLS 1.0/1.1 and SSL 3.0 ................87
      E.2. Compatibility with SSL 2.0 ................................88
      E.3. Avoiding Man-in-the-Middle Version Rollback ...............90
   Appendix F. Security Analysis .....................................91
      F.1. Handshake Protocol ........................................91
           F.1.1. Authentication and Key Exchange ....................91
                  F.1.1.1. Anonymous Key Exchange ....................91
                  F.1.1.2. RSA Key Exchange and Authentication .......92
                  F.1.1.3. Diffie-Hellman Key Exchange with
                           Authentication ............................92
           F.1.2. Version Rollback Attacks ...........................93
           F.1.3. Detecting Attacks Against the Handshake Protocol ...94
           F.1.4. Resuming Sessions ..................................94
      F.2. Protecting Application Data ...............................94
      F.3. Explicit IVs ..............................................95
      F.4. Security of Composite Cipher Modes ........................95
      F.5. Denial of Service .........................................96
      F.6. Final Notes ...............................................96
   Normative References ..............................................97
   Informative References ............................................98
   Working Group Information ........................................101
   Contributors .....................................................101




















Dierks & Rescorla           Standards Track                     [Page 3]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


1.  Introduction

   The primary goal of the TLS protocol is to provide privacy and data
   integrity between two communicating applications.  The protocol is
   composed of two layers: the TLS Record Protocol and the TLS Handshake
   Protocol.  At the lowest level, layered on top of some reliable
   transport protocol (e.g., TCP [TCP]), is the TLS Record Protocol.
   The TLS Record Protocol provides connection security that has two
   basic properties:

   -  The connection is private.  Symmetric cryptography is used for
      data encryption (e.g., AES [AES], RC4 [SCH], etc.).  The keys for
      this symmetric encryption are generated uniquely for each
      connection and are based on a secret negotiated by another
      protocol (such as the TLS Handshake Protocol).  The Record
      Protocol can also be used without encryption.

   -  The connection is reliable.  Message transport includes a message
      integrity check using a keyed MAC.  Secure hash functions (e.g.,
      SHA-1, etc.) are used for MAC computations.  The Record Protocol
      can operate without a MAC, but is generally only used in this mode
      while another protocol is using the Record Protocol as a transport
      for negotiating security parameters.

   The TLS Record Protocol is used for encapsulation of various higher-
   level protocols.  One such encapsulated protocol, the TLS Handshake
   Protocol, allows the server and client to authenticate each other and
   to negotiate an encryption algorithm and cryptographic keys before
   the application protocol transmits or receives its first byte of
   data.  The TLS Handshake Protocol provides connection security that
   has three basic properties:

   -  The peer's identity can be authenticated using asymmetric, or
      public key, cryptography (e.g., RSA [RSA], DSA [DSS], etc.).  This
      authentication can be made optional, but is generally required for
      at least one of the peers.

   -  The negotiation of a shared secret is secure: the negotiated
      secret is unavailable to eavesdroppers, and for any authenticated
      connection the secret cannot be obtained, even by an attacker who
      can place himself in the middle of the connection.

   -  The negotiation is reliable: no attacker can modify the
      negotiation communication without being detected by the parties to
      the communication.






Dierks & Rescorla           Standards Track                     [Page 4]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   One advantage of TLS is that it is application protocol independent.
   Higher-level protocols can layer on top of the TLS protocol
   transparently.  The TLS standard, however, does not specify how
   protocols add security with TLS; the decisions on how to initiate TLS
   handshaking and how to interpret the authentication certificates
   exchanged are left to the judgment of the designers and implementors
   of protocols that run on top of TLS.

1.1.  Requirements Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [REQ].

1.2.  Major Differences from TLS 1.1

   This document is a revision of the TLS 1.1 [TLS1.1] protocol which
   contains improved flexibility, particularly for negotiation of
   cryptographic algorithms.  The major changes are:

   -  The MD5/SHA-1 combination in the pseudorandom function (PRF) has
      been replaced with cipher-suite-specified PRFs.  All cipher suites
      in this document use P_SHA256.

   -  The MD5/SHA-1 combination in the digitally-signed element has been
      replaced with a single hash.  Signed elements now include a field
      that explicitly specifies the hash algorithm used.

   -  Substantial cleanup to the client's and server's ability to
      specify which hash and signature algorithms they will accept.
      Note that this also relaxes some of the constraints on signature
      and hash algorithms from previous versions of TLS.

   -  Addition of support for authenticated encryption with additional
      data modes.

   -  TLS Extensions definition and AES Cipher Suites were merged in
      from external [TLSEXT] and [TLSAES].

   -  Tighter checking of EncryptedPreMasterSecret version numbers.

   -  Tightened up a number of requirements.

   -  Verify_data length now depends on the cipher suite (default is
      still 12).

   -  Cleaned up description of Bleichenbacher/Klima attack defenses.




Dierks & Rescorla           Standards Track                     [Page 5]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   -  Alerts MUST now be sent in many cases.

   -  After a certificate_request, if no certificates are available,
      clients now MUST send an empty certificate list.

   -  TLS_RSA_WITH_AES_128_CBC_SHA is now the mandatory to implement
      cipher suite.

   -  Added HMAC-SHA256 cipher suites.

   -  Removed IDEA and DES cipher suites.  They are now deprecated and
      will be documented in a separate document.

   -  Support for the SSLv2 backward-compatible hello is now a MAY, not
      a SHOULD, with sending it a SHOULD NOT.  Support will probably
      become a SHOULD NOT in the future.

   -  Added limited "fall-through" to the presentation language to allow
      multiple case arms to have the same encoding.

   -  Added an Implementation Pitfalls sections

   -  The usual clarifications and editorial work.

2.  Goals

   The goals of the TLS protocol, in order of priority, are as follows:

   1. Cryptographic security: TLS should be used to establish a secure
      connection between two parties.

   2. Interoperability: Independent programmers should be able to
      develop applications utilizing TLS that can successfully exchange
      cryptographic parameters without knowledge of one another's code.

   3. Extensibility: TLS seeks to provide a framework into which new
      public key and bulk encryption methods can be incorporated as
      necessary.  This will also accomplish two sub-goals: preventing
      the need to create a new protocol (and risking the introduction of
      possible new weaknesses) and avoiding the need to implement an
      entire new security library.

   4. Relative efficiency: Cryptographic operations tend to be highly
      CPU intensive, particularly public key operations.  For this
      reason, the TLS protocol has incorporated an optional session
      caching scheme to reduce the number of connections that need to be
      established from scratch.  Additionally, care has been taken to
      reduce network activity.



Dierks & Rescorla           Standards Track                     [Page 6]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


3.  Goals of This Document

   This document and the TLS protocol itself are based on the SSL 3.0
   Protocol Specification as published by Netscape.  The differences
   between this protocol and SSL 3.0 are not dramatic, but they are
   significant enough that the various versions of TLS and SSL 3.0 do
   not interoperate (although each protocol incorporates a mechanism by
   which an implementation can back down to prior versions).  This
   document is intended primarily for readers who will be implementing
   the protocol and for those doing cryptographic analysis of it.  The
   specification has been written with this in mind, and it is intended
   to reflect the needs of those two groups.  For that reason, many of
   the algorithm-dependent data structures and rules are included in the
   body of the text (as opposed to in an appendix), providing easier
   access to them.

   This document is not intended to supply any details of service
   definition or of interface definition, although it does cover select
   areas of policy as they are required for the maintenance of solid
   security.

4.  Presentation Language

   This document deals with the formatting of data in an external
   representation.  The following very basic and somewhat casually
   defined presentation syntax will be used.  The syntax draws from
   several sources in its structure.  Although it resembles the
   programming language "C" in its syntax and XDR [XDR] in both its
   syntax and intent, it would be risky to draw too many parallels.  The
   purpose of this presentation language is to document TLS only; it has
   no general application beyond that particular goal.

4.1.  Basic Block Size

   The representation of all data items is explicitly specified.  The
   basic data block size is one byte (i.e., 8 bits).  Multiple byte data
   items are concatenations of bytes, from left to right, from top to
   bottom.  From the byte stream, a multi-byte item (a numeric in the
   example) is formed (using C notation) by:

      value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
              ... | byte[n-1];

   This byte ordering for multi-byte values is the commonplace network
   byte order or big-endian format.






Dierks & Rescorla           Standards Track                     [Page 7]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


4.2.  Miscellaneous

   Comments begin with "/*" and end with "*/".

   Optional components are denoted by enclosing them in "[[ ]]" double
   brackets.

   Single-byte entities containing uninterpreted data are of type
   opaque.

4.3.  Vectors

   A vector (single-dimensioned array) is a stream of homogeneous data
   elements.  The size of the vector may be specified at documentation
   time or left unspecified until runtime.  In either case, the length
   declares the number of bytes, not the number of elements, in the
   vector.  The syntax for specifying a new type, T', that is a fixed-
   length vector of type T is

      T T'[n];

   Here, T' occupies n bytes in the data stream, where n is a multiple
   of the size of T.  The length of the vector is not included in the
   encoded stream.

   In the following example, Datum is defined to be three consecutive
   bytes that the protocol does not interpret, while Data is three
   consecutive Datum, consuming a total of nine bytes.

      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* 3 consecutive 3 byte vectors */

   Variable-length vectors are defined by specifying a subrange of legal
   lengths, inclusively, using the notation <floor..ceiling>.  When
   these are encoded, the actual length precedes the vector's contents
   in the byte stream.  The length will be in the form of a number
   consuming as many bytes as required to hold the vector's specified
   maximum (ceiling) length.  A variable-length vector with an actual
   length field of zero is referred to as an empty vector.

      T T'<floor..ceiling>;

   In the following example, mandatory is a vector that must contain
   between 300 and 400 bytes of type opaque.  It can never be empty.
   The actual length field consumes two bytes, a uint16, which is
   sufficient to represent the value 400 (see Section 4.4).  On the
   other hand, longer can represent up to 800 bytes of data, or 400
   uint16 elements, and it may be empty.  Its encoding will include a



Dierks & Rescorla           Standards Track                     [Page 8]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   two-byte actual length field prepended to the vector.  The length of
   an encoded vector must be an even multiple of the length of a single
   element (for example, a 17-byte vector of uint16 would be illegal).

      opaque mandatory<300..400>;
            /* length field is 2 bytes, cannot be empty */
      uint16 longer<0..800>;
            /* zero to 400 16-bit unsigned integers */

4.4.  Numbers

   The basic numeric data type is an unsigned byte (uint8).  All larger
   numeric data types are formed from fixed-length series of bytes
   concatenated as described in Section 4.1 and are also unsigned.  The
   following numeric types are predefined.

      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];

   All values, here and elsewhere in the specification, are stored in
   network byte (big-endian) order; the uint32 represented by the hex
   bytes 01 02 03 04 is equivalent to the decimal value 16909060.

   Note that in some cases (e.g., DH parameters) it is necessary to
   represent integers as opaque vectors.  In such cases, they are
   represented as unsigned integers (i.e., leading zero octets are not
   required even if the most significant bit is set).

4.5.  Enumerateds

   An additional sparse data type is available called enum.  A field of
   type enum can only assume the values declared in the definition.
   Each definition is a different type.  Only enumerateds of the same
   type may be assigned or compared.  Every element of an enumerated
   must be assigned a value, as demonstrated in the following example.
   Since the elements of the enumerated are not ordered, they can be
   assigned any unique value, in any order.

      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;

   An enumerated occupies as much space in the byte stream as would its
   maximal defined ordinal value.  The following definition would cause
   one byte to be used to carry fields of type Color.

      enum { red(3), blue(5), white(7) } Color;




Dierks & Rescorla           Standards Track                     [Page 9]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   One may optionally specify a value without its associated tag to
   force the width definition without defining a superfluous element.

   In the following example, Taste will consume two bytes in the data
   stream but can only assume the values 1, 2, or 4.

      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;

   The names of the elements of an enumeration are scoped within the
   defined type.  In the first example, a fully qualified reference to
   the second element of the enumeration would be Color.blue.  Such
   qualification is not required if the target of the assignment is well
   specified.

      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */

   For enumerateds that are never converted to external representation,
   the numerical information may be omitted.

      enum { low, medium, high } Amount;

4.6.  Constructed Types

   Structure types may be constructed from primitive types for
   convenience.  Each specification declares a new, unique type.  The
   syntax for definition is much like that of C.

      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } [[T]];

   The fields within a structure may be qualified using the type's name,
   with a syntax much like that available for enumerateds.  For example,
   T.f2 refers to the second field of the previous declaration.
   Structure definitions may be embedded.

4.6.1.  Variants

   Defined structures may have variants based on some knowledge that is
   available within the environment.  The selector must be an enumerated
   type that defines the possible variants the structure defines.  There
   must be a case arm for every element of the enumeration declared in
   the select.  Case arms have limited fall-through: if two case arms
   follow in immediate succession with no fields in between, then they



Dierks & Rescorla           Standards Track                    [Page 10]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   both contain the same fields.  Thus, in the example below, "orange"
   and "banana" both contain V2.  Note that this is a new piece of
   syntax in TLS 1.2.

   The body of the variant structure may be given a label for reference.
   The mechanism by which the variant is selected at runtime is not
   prescribed by the presentation language.

      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               case e3: case e4: Te3;
               ....
               case en: Ten;
           } [[fv]];
      } [[Tv]];

   For example:

      enum { apple, orange, banana } VariantTag;

      struct {
          uint16 number;
          opaque string<0..10>; /* variable length */
      } V1;

      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;

      struct {
          select (VariantTag) { /* value of selector is implicit */
              case apple:
                V1;   /* VariantBody, tag = apple */
              case orange:
              case banana:
                V2;   /* VariantBody, tag = orange or banana */
          } variant_body;       /* optional label on variant */
      } VariantRecord;






Dierks & Rescorla           Standards Track                    [Page 11]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


4.7.  Cryptographic Attributes

   The five cryptographic operations -- digital signing, stream cipher
   encryption, block cipher encryption, authenticated encryption with
   additional data (AEAD) encryption, and public key encryption -- are
   designated digitally-signed, stream-ciphered, block-ciphered, aead-
   ciphered, and public-key-encrypted, respectively.  A field's
   cryptographic processing is specified by prepending an appropriate
   key word designation before the field's type specification.
   Cryptographic keys are implied by the current session state (see
   Section 6.1).

   A digitally-signed element is encoded as a struct DigitallySigned:

      struct {
         SignatureAndHashAlgorithm algorithm;
         opaque signature<0..2^16-1>;
      } DigitallySigned;

   The algorithm field specifies the algorithm used (see Section
   7.4.1.4.1 for the definition of this field).  Note that the
   introduction of the algorithm field is a change from previous
   versions.  The signature is a digital signature using those
   algorithms over the contents of the element.  The contents themselves
   do not appear on the wire but are simply calculated.  The length of
   the signature is specified by the signing algorithm and key.

   In RSA signing, the opaque vector contains the signature generated
   using the RSASSA-PKCS1-v1_5 signature scheme defined in [PKCS1].  As
   discussed in [PKCS1], the DigestInfo MUST be DER-encoded [X680]
   [X690].  For hash algorithms without parameters (which includes
   SHA-1), the DigestInfo.AlgorithmIdentifier.parameters field MUST be
   NULL, but implementations MUST accept both without parameters and
   with NULL parameters.  Note that earlier versions of TLS used a
   different RSA signature scheme that did not include a DigestInfo
   encoding.

   In DSA, the 20 bytes of the SHA-1 hash are run directly through the
   Digital Signing Algorithm with no additional hashing.  This produces
   two values, r and s.  The DSA signature is an opaque vector, as
   above, the contents of which are the DER encoding of:

      Dss-Sig-Value ::= SEQUENCE {
          r INTEGER,
          s INTEGER
      }





Dierks & Rescorla           Standards Track                    [Page 12]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Note: In current terminology, DSA refers to the Digital Signature
   Algorithm and DSS refers to the NIST standard.  In the original SSL
   and TLS specs, "DSS" was used universally.  This document uses "DSA"
   to refer to the algorithm, "DSS" to refer to the standard, and it
   uses "DSS" in the code point definitions for historical continuity.

   In stream cipher encryption, the plaintext is exclusive-ORed with an
   identical amount of output generated from a cryptographically secure
   keyed pseudorandom number generator.

   In block cipher encryption, every block of plaintext encrypts to a
   block of ciphertext.  All block cipher encryption is done in CBC
   (Cipher Block Chaining) mode, and all items that are block-ciphered
   will be an exact multiple of the cipher block length.

   In AEAD encryption, the plaintext is simultaneously encrypted and
   integrity protected.  The input may be of any length, and aead-
   ciphered output is generally larger than the input in order to
   accommodate the integrity check value.

   In public key encryption, a public key algorithm is used to encrypt
   data in such a way that it can be decrypted only with the matching
   private key.  A public-key-encrypted element is encoded as an opaque
   vector <0..2^16-1>, where the length is specified by the encryption
   algorithm and key.

   RSA encryption is done using the RSAES-PKCS1-v1_5 encryption scheme
   defined in [PKCS1].

   In the following example

      stream-ciphered struct {
          uint8 field1;
          uint8 field2;
          digitally-signed opaque {
            uint8 field3<0..255>;
            uint8 field4;
          };
      } UserType;

   The contents of the inner struct (field3 and field4) are used as
   input for the signature/hash algorithm, and then the entire structure
   is encrypted with a stream cipher.  The length of this structure, in
   bytes, would be equal to two bytes for field1 and field2, plus two
   bytes for the signature and hash algorithm, plus two bytes for the
   length of the signature, plus the length of the output of the signing





Dierks & Rescorla           Standards Track                    [Page 13]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   algorithm.  The length of the signature is known because the
   algorithm and key used for the signing are known prior to encoding or
   decoding this structure.

4.8.  Constants

   Typed constants can be defined for purposes of specification by
   declaring a symbol of the desired type and assigning values to it.

   Under-specified types (opaque, variable-length vectors, and
   structures that contain opaque) cannot be assigned values.  No fields
   of a multi-element structure or vector may be elided.

   For example:

      struct {
          uint8 f1;
          uint8 f2;
      } Example1;

      Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */

5.  HMAC and the Pseudorandom Function

   The TLS record layer uses a keyed Message Authentication Code (MAC)
   to protect message integrity.  The cipher suites defined in this
   document use a construction known as HMAC, described in [HMAC], which
   is based on a hash function.  Other cipher suites MAY define their
   own MAC constructions, if needed.

   In addition, a construction is required to do expansion of secrets
   into blocks of data for the purposes of key generation or validation.
   This pseudorandom function (PRF) takes as input a secret, a seed, and
   an identifying label and produces an output of arbitrary length.

   In this section, we define one PRF, based on HMAC.  This PRF with the
   SHA-256 hash function is used for all cipher suites defined in this
   document and in TLS documents published prior to this document when
   TLS 1.2 is negotiated.  New cipher suites MUST explicitly specify a
   PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a
   stronger standard hash function.

   First, we define a data expansion function, P_hash(secret, data),
   that uses a single hash function to expand a secret and seed into an
   arbitrary quantity of output:






Dierks & Rescorla           Standards Track                    [Page 14]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                             HMAC_hash(secret, A(2) + seed) +
                             HMAC_hash(secret, A(3) + seed) + ...

   where + indicates concatenation.

   A() is defined as:

      A(0) = seed
      A(i) = HMAC_hash(secret, A(i-1))

   P_hash can be iterated as many times as necessary to produce the
   required quantity of data.  For example, if P_SHA256 is being used to
   create 80 bytes of data, it will have to be iterated three times
   (through A(3)), creating 96 bytes of output data; the last 16 bytes
   of the final iteration will then be discarded, leaving 80 bytes of
   output data.

   TLS's PRF is created by applying P_hash to the secret as:

      PRF(secret, label, seed) = P_<hash>(secret, label + seed)

   The label is an ASCII string.  It should be included in the exact
   form it is given without a length byte or trailing null character.
   For example, the label "slithy toves" would be processed by hashing
   the following bytes:

      73 6C 69 74 68 79 20 74 6F 76 65 73

6.  The TLS Record Protocol

   The TLS Record Protocol is a layered protocol.  At each layer,
   messages may include fields for length, description, and content.
   The Record Protocol takes messages to be transmitted, fragments the
   data into manageable blocks, optionally compresses the data, applies
   a MAC, encrypts, and transmits the result.  Received data is
   decrypted, verified, decompressed, reassembled, and then delivered to
   higher-level clients.

   Four protocols that use the record protocol are described in this
   document: the handshake protocol, the alert protocol, the change
   cipher spec protocol, and the application data protocol.  In order to
   allow extension of the TLS protocol, additional record content types
   can be supported by the record protocol.  New record content type
   values are assigned by IANA in the TLS Content Type Registry as
   described in Section 12.





Dierks & Rescorla           Standards Track                    [Page 15]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Implementations MUST NOT send record types not defined in this
   document unless negotiated by some extension.  If a TLS
   implementation receives an unexpected record type, it MUST send an
   unexpected_message alert.

   Any protocol designed for use over TLS must be carefully designed to
   deal with all possible attacks against it.  As a practical matter,
   this means that the protocol designer must be aware of what security
   properties TLS does and does not provide and cannot safely rely on
   the latter.

   Note in particular that type and length of a record are not protected
   by encryption.  If this information is itself sensitive, application
   designers may wish to take steps (padding, cover traffic) to minimize
   information leakage.

6.1.  Connection States

   A TLS connection state is the operating environment of the TLS Record
   Protocol.  It specifies a compression algorithm, an encryption
   algorithm, and a MAC algorithm.  In addition, the parameters for
   these algorithms are known: the MAC key and the bulk encryption keys
   for the connection in both the read and the write directions.
   Logically, there are always four connection states outstanding: the
   current read and write states, and the pending read and write states.
   All records are processed under the current read and write states.
   The security parameters for the pending states can be set by the TLS
   Handshake Protocol, and the ChangeCipherSpec can selectively make
   either of the pending states current, in which case the appropriate
   current state is disposed of and replaced with the pending state; the
   pending state is then reinitialized to an empty state.  It is illegal
   to make a state that has not been initialized with security
   parameters a current state.  The initial current state always
   specifies that no encryption, compression, or MAC will be used.

   The security parameters for a TLS Connection read and write state are
   set by providing the following values:

   connection end
      Whether this entity is considered the "client" or the "server" in
      this connection.

   PRF algorithm
      An algorithm used to generate keys from the master secret (see
      Sections 5 and 6.3).






Dierks & Rescorla           Standards Track                    [Page 16]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   bulk encryption algorithm
      An algorithm to be used for bulk encryption.  This specification
      includes the key size of this algorithm, whether it is a block,
      stream, or AEAD cipher, the block size of the cipher (if
      appropriate), and the lengths of explicit and implicit
      initialization vectors (or nonces).

   MAC algorithm
      An algorithm to be used for message authentication.  This
      specification includes the size of the value returned by the MAC
      algorithm.

   compression algorithm
      An algorithm to be used for data compression.  This specification
      must include all information the algorithm requires to do
      compression.

   master secret
      A 48-byte secret shared between the two peers in the connection.

   client random
      A 32-byte value provided by the client.

   server random
      A 32-byte value provided by the server.

      These parameters are defined in the presentation language as:

      enum { server, client } ConnectionEnd;

      enum { tls_prf_sha256 } PRFAlgorithm;

      enum { null, rc4, 3des, aes }
        BulkCipherAlgorithm;

      enum { stream, block, aead } CipherType;

      enum { null, hmac_md5, hmac_sha1, hmac_sha256,
           hmac_sha384, hmac_sha512} MACAlgorithm;

      enum { null(0), (255) } CompressionMethod;

      /* The algorithms specified in CompressionMethod, PRFAlgorithm,
         BulkCipherAlgorithm, and MACAlgorithm may be added to. */







Dierks & Rescorla           Standards Track                    [Page 17]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          ConnectionEnd          entity;
          PRFAlgorithm           prf_algorithm;
          BulkCipherAlgorithm    bulk_cipher_algorithm;
          CipherType             cipher_type;
          uint8                  enc_key_length;
          uint8                  block_length;
          uint8                  fixed_iv_length;
          uint8                  record_iv_length;
          MACAlgorithm           mac_algorithm;
          uint8                  mac_length;
          uint8                  mac_key_length;
          CompressionMethod      compression_algorithm;
          opaque                 master_secret[48];
          opaque                 client_random[32];
          opaque                 server_random[32];
      } SecurityParameters;

   The record layer will use the security parameters to generate the
   following six items (some of which are not required by all ciphers,
   and are thus empty):

      client write MAC key
      server write MAC key
      client write encryption key
      server write encryption key
      client write IV
      server write IV

   The client write parameters are used by the server when receiving and
   processing records and vice versa.  The algorithm used for generating
   these items from the security parameters is described in Section 6.3.

   Once the security parameters have been set and the keys have been
   generated, the connection states can be instantiated by making them
   the current states.  These current states MUST be updated for each
   record processed.  Each connection state includes the following
   elements:

   compression state
      The current state of the compression algorithm.

   cipher state
      The current state of the encryption algorithm.  This will consist
      of the scheduled key for that connection.  For stream ciphers,
      this will also contain whatever state information is necessary to
      allow the stream to continue to encrypt or decrypt data.




Dierks & Rescorla           Standards Track                    [Page 18]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   MAC key
      The MAC key for this connection, as generated above.

   sequence number
      Each connection state contains a sequence number, which is
      maintained separately for read and write states.  The sequence
      number MUST be set to zero whenever a connection state is made the
      active state.  Sequence numbers are of type uint64 and may not
      exceed 2^64-1.  Sequence numbers do not wrap.  If a TLS
      implementation would need to wrap a sequence number, it must
      renegotiate instead.  A sequence number is incremented after each
      record: specifically, the first record transmitted under a
      particular connection state MUST use sequence number 0.

6.2.  Record Layer

   The TLS record layer receives uninterpreted data from higher layers
   in non-empty blocks of arbitrary size.

6.2.1.  Fragmentation

   The record layer fragments information blocks into TLSPlaintext
   records carrying data in chunks of 2^14 bytes or less.  Client
   message boundaries are not preserved in the record layer (i.e.,
   multiple client messages of the same ContentType MAY be coalesced
   into a single TLSPlaintext record, or a single message MAY be
   fragmented across several records).

      struct {
          uint8 major;
          uint8 minor;
      } ProtocolVersion;

      enum {
          change_cipher_spec(20), alert(21), handshake(22),
          application_data(23), (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;

   type
      The higher-level protocol used to process the enclosed fragment.




Dierks & Rescorla           Standards Track                    [Page 19]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   version
      The version of the protocol being employed.  This document
      describes TLS Version 1.2, which uses the version { 3, 3 }.  The
      version value 3.3 is historical, deriving from the use of {3, 1}
      for TLS 1.0.  (See Appendix A.1.)  Note that a client that
      supports multiple versions of TLS may not know what version will
      be employed before it receives the ServerHello.  See Appendix E
      for discussion about what record layer version number should be
      employed for ClientHello.

   length
      The length (in bytes) of the following TLSPlaintext.fragment.  The
      length MUST NOT exceed 2^14.

   fragment
      The application data.  This data is transparent and treated as an
      independent block to be dealt with by the higher-level protocol
      specified by the type field.

   Implementations MUST NOT send zero-length fragments of Handshake,
   Alert, or ChangeCipherSpec content types.  Zero-length fragments of
   Application data MAY be sent as they are potentially useful as a
   traffic analysis countermeasure.

   Note: Data of different TLS record layer content types MAY be
   interleaved.  Application data is generally of lower precedence for
   transmission than other content types.  However, records MUST be
   delivered to the network in the same order as they are protected by
   the record layer.  Recipients MUST receive and process interleaved
   application layer traffic during handshakes subsequent to the first
   one on a connection.

6.2.2.  Record Compression and Decompression

   All records are compressed using the compression algorithm defined in
   the current session state.  There is always an active compression
   algorithm; however, initially it is defined as
   CompressionMethod.null.  The compression algorithm translates a
   TLSPlaintext structure into a TLSCompressed structure.  Compression
   functions are initialized with default state information whenever a
   connection state is made active.  [RFC3749] describes compression
   algorithms for TLS.

   Compression must be lossless and may not increase the content length
   by more than 1024 bytes.  If the decompression function encounters a
   TLSCompressed.fragment that would decompress to a length in excess of
   2^14 bytes, it MUST report a fatal decompression failure error.




Dierks & Rescorla           Standards Track                    [Page 20]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          ContentType type;       /* same as TLSPlaintext.type */
          ProtocolVersion version;/* same as TLSPlaintext.version */
          uint16 length;
          opaque fragment[TLSCompressed.length];
      } TLSCompressed;

   length
      The length (in bytes) of the following TLSCompressed.fragment.
      The length MUST NOT exceed 2^14 + 1024.

   fragment
      The compressed form of TLSPlaintext.fragment.

      Note: A CompressionMethod.null operation is an identity operation;
      no fields are altered.

      Implementation note: Decompression functions are responsible for
      ensuring that messages cannot cause internal buffer overflows.

6.2.3.  Record Payload Protection

      The encryption and MAC functions translate a TLSCompressed
      structure into a TLSCiphertext.  The decryption functions reverse
      the process.  The MAC of the record also includes a sequence
      number so that missing, extra, or repeated messages are
      detectable.

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          select (SecurityParameters.cipher_type) {
              case stream: GenericStreamCipher;
              case block:  GenericBlockCipher;
              case aead:   GenericAEADCipher;
          } fragment;
      } TLSCiphertext;

   type
      The type field is identical to TLSCompressed.type.

   version
      The version field is identical to TLSCompressed.version.

   length
      The length (in bytes) of the following TLSCiphertext.fragment.
      The length MUST NOT exceed 2^14 + 2048.



Dierks & Rescorla           Standards Track                    [Page 21]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   fragment
      The encrypted form of TLSCompressed.fragment, with the MAC.

6.2.3.1.  Null or Standard Stream Cipher

   Stream ciphers (including BulkCipherAlgorithm.null; see Appendix A.6)
   convert TLSCompressed.fragment structures to and from stream
   TLSCiphertext.fragment structures.

      stream-ciphered struct {
          opaque content[TLSCompressed.length];
          opaque MAC[SecurityParameters.mac_length];
      } GenericStreamCipher;

   The MAC is generated as:

      MAC(MAC_write_key, seq_num +
                            TLSCompressed.type +
                            TLSCompressed.version +
                            TLSCompressed.length +
                            TLSCompressed.fragment);

   where "+" denotes concatenation.

   seq_num
      The sequence number for this record.

   MAC
      The MAC algorithm specified by SecurityParameters.mac_algorithm.

   Note that the MAC is computed before encryption.  The stream cipher
   encrypts the entire block, including the MAC.  For stream ciphers
   that do not use a synchronization vector (such as RC4), the stream
   cipher state from the end of one record is simply used on the
   subsequent packet.  If the cipher suite is TLS_NULL_WITH_NULL_NULL,
   encryption consists of the identity operation (i.e., the data is not
   encrypted, and the MAC size is zero, implying that no MAC is used).
   For both null and stream ciphers, TLSCiphertext.length is
   TLSCompressed.length plus SecurityParameters.mac_length.

6.2.3.2.  CBC Block Cipher

   For block ciphers (such as 3DES or AES), the encryption and MAC
   functions convert TLSCompressed.fragment structures to and from block
   TLSCiphertext.fragment structures.






Dierks & Rescorla           Standards Track                    [Page 22]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          opaque IV[SecurityParameters.record_iv_length];
          block-ciphered struct {
              opaque content[TLSCompressed.length];
              opaque MAC[SecurityParameters.mac_length];
              uint8 padding[GenericBlockCipher.padding_length];
              uint8 padding_length;
          };
      } GenericBlockCipher;

   The MAC is generated as described in Section 6.2.3.1.

   IV
      The Initialization Vector (IV) SHOULD be chosen at random, and
      MUST be unpredictable.  Note that in versions of TLS prior to 1.1,
      there was no IV field, and the last ciphertext block of the
      previous record (the "CBC residue") was used as the IV.  This was
      changed to prevent the attacks described in [CBCATT].  For block
      ciphers, the IV length is of length
      SecurityParameters.record_iv_length, which is equal to the
      SecurityParameters.block_size.

   padding
      Padding that is added to force the length of the plaintext to be
      an integral multiple of the block cipher's block length.  The
      padding MAY be any length up to 255 bytes, as long as it results
      in the TLSCiphertext.length being an integral multiple of the
      block length.  Lengths longer than necessary might be desirable to
      frustrate attacks on a protocol that are based on analysis of the
      lengths of exchanged messages.  Each uint8 in the padding data
      vector MUST be filled with the padding length value.  The receiver
      MUST check this padding and MUST use the bad_record_mac alert to
      indicate padding errors.

   padding_length
      The padding length MUST be such that the total size of the
      GenericBlockCipher structure is a multiple of the cipher's block
      length.  Legal values range from zero to 255, inclusive.  This
      length specifies the length of the padding field exclusive of the
      padding_length field itself.

   The encrypted data length (TLSCiphertext.length) is one more than the
   sum of SecurityParameters.block_length, TLSCompressed.length,
   SecurityParameters.mac_length, and padding_length.

   Example: If the block length is 8 bytes, the content length
   (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes,
   then the length before padding is 82 bytes (this does not include the



Dierks & Rescorla           Standards Track                    [Page 23]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   IV.  Thus, the padding length modulo 8 must be equal to 6 in order to
   make the total length an even multiple of 8 bytes (the block length).
   The padding length can be 6, 14, 22, and so on, through 254.  If the
   padding length were the minimum necessary, 6, the padding would be 6
   bytes, each containing the value 6.  Thus, the last 8 octets of the
   GenericBlockCipher before block encryption would be xx 06 06 06 06 06
   06 06, where xx is the last octet of the MAC.

   Note: With block ciphers in CBC mode (Cipher Block Chaining), it is
   critical that the entire plaintext of the record be known before any
   ciphertext is transmitted.  Otherwise, it is possible for the
   attacker to mount the attack described in [CBCATT].

   Implementation note: Canvel et al. [CBCTIME] have demonstrated a
   timing attack on CBC padding based on the time required to compute
   the MAC.  In order to defend against this attack, implementations
   MUST ensure that record processing time is essentially the same
   whether or not the padding is correct.  In general, the best way to
   do this is to compute the MAC even if the padding is incorrect, and
   only then reject the packet.  For instance, if the pad appears to be
   incorrect, the implementation might assume a zero-length pad and then
   compute the MAC.  This leaves a small timing channel, since MAC
   performance depends to some extent on the size of the data fragment,
   but it is not believed to be large enough to be exploitable, due to
   the large block size of existing MACs and the small size of the
   timing signal.

6.2.3.3.  AEAD Ciphers

   For AEAD [AEAD] ciphers (such as [CCM] or [GCM]), the AEAD function
   converts TLSCompressed.fragment structures to and from AEAD
   TLSCiphertext.fragment structures.

      struct {
         opaque nonce_explicit[SecurityParameters.record_iv_length];
         aead-ciphered struct {
             opaque content[TLSCompressed.length];
         };
      } GenericAEADCipher;

   AEAD ciphers take as input a single key, a nonce, a plaintext, and
   "additional data" to be included in the authentication check, as
   described in Section 2.1 of [AEAD].  The key is either the
   client_write_key or the server_write_key.  No MAC key is used.

   Each AEAD cipher suite MUST specify how the nonce supplied to the
   AEAD operation is constructed, and what is the length of the
   GenericAEADCipher.nonce_explicit part.  In many cases, it is



Dierks & Rescorla           Standards Track                    [Page 24]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   appropriate to use the partially implicit nonce technique described
   in Section 3.2.1 of [AEAD]; with record_iv_length being the length of
   the explicit part.  In this case, the implicit part SHOULD be derived
   from key_block as client_write_iv and server_write_iv (as described
   in Section 6.3), and the explicit part is included in
   GenericAEAEDCipher.nonce_explicit.

   The plaintext is the TLSCompressed.fragment.

   The additional authenticated data, which we denote as
   additional_data, is defined as follows:

      additional_data = seq_num + TLSCompressed.type +
                        TLSCompressed.version + TLSCompressed.length;

   where "+" denotes concatenation.

   The aead_output consists of the ciphertext output by the AEAD
   encryption operation.  The length will generally be larger than
   TLSCompressed.length, but by an amount that varies with the AEAD
   cipher.  Since the ciphers might incorporate padding, the amount of
   overhead could vary with different TLSCompressed.length values.  Each
   AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes.
   Symbolically,

      AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext,
                                   additional_data)

   In order to decrypt and verify, the cipher takes as input the key,
   nonce, the "additional_data", and the AEADEncrypted value.  The
   output is either the plaintext or an error indicating that the
   decryption failed.  There is no separate integrity check.  That is:

      TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce,
                                            AEADEncrypted,
                                            additional_data)

   If the decryption fails, a fatal bad_record_mac alert MUST be
   generated.

6.3.  Key Calculation

   The Record Protocol requires an algorithm to generate keys required
   by the current connection state (see Appendix A.6) from the security
   parameters provided by the handshake protocol.






Dierks & Rescorla           Standards Track                    [Page 25]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The master secret is expanded into a sequence of secure bytes, which
   is then split to a client write MAC key, a server write MAC key, a
   client write encryption key, and a server write encryption key.  Each
   of these is generated from the byte sequence in that order.  Unused
   values are empty.  Some AEAD ciphers may additionally require a
   client write IV and a server write IV (see Section 6.2.3.3).

   When keys and MAC keys are generated, the master secret is used as an
   entropy source.

   To generate the key material, compute

      key_block = PRF(SecurityParameters.master_secret,
                      "key expansion",
                      SecurityParameters.server_random +
                      SecurityParameters.client_random);

   until enough output has been generated.  Then, the key_block is
   partitioned as follows:

      client_write_MAC_key[SecurityParameters.mac_key_length]
      server_write_MAC_key[SecurityParameters.mac_key_length]
      client_write_key[SecurityParameters.enc_key_length]
      server_write_key[SecurityParameters.enc_key_length]
      client_write_IV[SecurityParameters.fixed_iv_length]
      server_write_IV[SecurityParameters.fixed_iv_length]

   Currently, the client_write_IV and server_write_IV are only generated
   for implicit nonce techniques as described in Section 3.2.1 of
   [AEAD].

   Implementation note: The currently defined cipher suite which
   requires the most material is AES_256_CBC_SHA256.  It requires 2 x 32
   byte keys and 2 x 32 byte MAC keys, for a total 128 bytes of key
   material.

7.  The TLS Handshaking Protocols

   TLS has three subprotocols that are used to allow peers to agree upon
   security parameters for the record layer, to authenticate themselves,
   to instantiate negotiated security parameters, and to report error
   conditions to each other.

   The Handshake Protocol is responsible for negotiating a session,
   which consists of the following items:






Dierks & Rescorla           Standards Track                    [Page 26]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   session identifier
      An arbitrary byte sequence chosen by the server to identify an
      active or resumable session state.

   peer certificate
      X509v3 [PKIX] certificate of the peer.  This element of the state
      may be null.

   compression method
      The algorithm used to compress data prior to encryption.

   cipher spec
      Specifies the pseudorandom function (PRF) used to generate keying
      material, the bulk data encryption algorithm (such as null, AES,
      etc.) and the MAC algorithm (such as HMAC-SHA1).  It also defines
      cryptographic attributes such as the mac_length.  (See Appendix
      A.6 for formal definition.)

   master secret
      48-byte secret shared between the client and server.

   is resumable
      A flag indicating whether the session can be used to initiate new
      connections.

   These items are then used to create security parameters for use by
   the record layer when protecting application data.  Many connections
   can be instantiated using the same session through the resumption
   feature of the TLS Handshake Protocol.

7.1.  Change Cipher Spec Protocol

   The change cipher spec protocol exists to signal transitions in
   ciphering strategies.  The protocol consists of a single message,
   which is encrypted and compressed under the current (not the pending)
   connection state.  The message consists of a single byte of value 1.

      struct {
          enum { change_cipher_spec(1), (255) } type;
      } ChangeCipherSpec;

   The ChangeCipherSpec message is sent by both the client and the
   server to notify the receiving party that subsequent records will be
   protected under the newly negotiated CipherSpec and keys.  Reception
   of this message causes the receiver to instruct the record layer to
   immediately copy the read pending state into the read current state.
   Immediately after sending this message, the sender MUST instruct the
   record layer to make the write pending state the write active state.



Dierks & Rescorla           Standards Track                    [Page 27]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   (See Section 6.1.)  The ChangeCipherSpec message is sent during the
   handshake after the security parameters have been agreed upon, but
   before the verifying Finished message is sent.

   Note: If a rehandshake occurs while data is flowing on a connection,
   the communicating parties may continue to send data using the old
   CipherSpec.  However, once the ChangeCipherSpec has been sent, the
   new CipherSpec MUST be used.  The first side to send the
   ChangeCipherSpec does not know that the other side has finished
   computing the new keying material (e.g., if it has to perform a
   time-consuming public key operation).  Thus, a small window of time,
   during which the recipient must buffer the data, MAY exist.  In
   practice, with modern machines this interval is likely to be fairly
   short.

7.2.  Alert Protocol

   One of the content types supported by the TLS record layer is the
   alert type.  Alert messages convey the severity of the message
   (warning or fatal) and a description of the alert.  Alert messages
   with a level of fatal result in the immediate termination of the
   connection.  In this case, other connections corresponding to the
   session may continue, but the session identifier MUST be invalidated,
   preventing the failed session from being used to establish new
   connections.  Like other messages, alert messages are encrypted and
   compressed, as specified by the current connection state.

      enum { warning(1), fatal(2), (255) } AlertLevel;

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),



Dierks & Rescorla           Standards Track                    [Page 28]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          user_canceled(90),
          no_renegotiation(100),
          unsupported_extension(110),
          (255)
      } AlertDescription;

      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;

7.2.1.  Closure Alerts

   The client and the server must share knowledge that the connection is
   ending in order to avoid a truncation attack.  Either party may
   initiate the exchange of closing messages.

   close_notify
      This message notifies the recipient that the sender will not send
      any more messages on this connection.  Note that as of TLS 1.1,
      failure to properly close a connection no longer requires that a
      session not be resumed.  This is a change from TLS 1.0 to conform
      with widespread implementation practice.

   Either party may initiate a close by sending a close_notify alert.
   Any data received after a closure alert is ignored.

   Unless some other fatal alert has been transmitted, each party is
   required to send a close_notify alert before closing the write side
   of the connection.  The other party MUST respond with a close_notify
   alert of its own and close down the connection immediately,
   discarding any pending writes.  It is not required for the initiator
   of the close to wait for the responding close_notify alert before
   closing the read side of the connection.

   If the application protocol using TLS provides that any data may be
   carried over the underlying transport after the TLS connection is
   closed, the TLS implementation must receive the responding
   close_notify alert before indicating to the application layer that
   the TLS connection has ended.  If the application protocol will not
   transfer any additional data, but will only close the underlying
   transport connection, then the implementation MAY choose to close the
   transport without waiting for the responding close_notify.  No part




Dierks & Rescorla           Standards Track                    [Page 29]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   of this standard should be taken to dictate the manner in which a
   usage profile for TLS manages its data transport, including when
   connections are opened or closed.

   Note: It is assumed that closing a connection reliably delivers
   pending data before destroying the transport.

7.2.2.  Error Alerts

   Error handling in the TLS Handshake protocol is very simple.  When an
   error is detected, the detecting party sends a message to the other
   party.  Upon transmission or receipt of a fatal alert message, both
   parties immediately close the connection.  Servers and clients MUST
   forget any session-identifiers, keys, and secrets associated with a
   failed connection.  Thus, any connection terminated with a fatal
   alert MUST NOT be resumed.

   Whenever an implementation encounters a condition which is defined as
   a fatal alert, it MUST send the appropriate alert prior to closing
   the connection.  For all errors where an alert level is not
   explicitly specified, the sending party MAY determine at its
   discretion whether to treat this as a fatal error or not.  If the
   implementation chooses to send an alert but intends to close the
   connection immediately afterwards, it MUST send that alert at the
   fatal alert level.

   If an alert with a level of warning is sent and received, generally
   the connection can continue normally.  If the receiving party decides
   not to proceed with the connection (e.g., after having received a
   no_renegotiation alert that it is not willing to accept), it SHOULD
   send a fatal alert to terminate the connection.  Given this, the
   sending party cannot, in general, know how the receiving party will
   behave.  Therefore, warning alerts are not very useful when the
   sending party wants to continue the connection, and thus are
   sometimes omitted.  For example, if a peer decides to accept an
   expired certificate (perhaps after confirming this with the user) and
   wants to continue the connection, it would not generally send a
   certificate_expired alert.

   The following error alerts are defined:

   unexpected_message
      An inappropriate message was received.  This alert is always fatal
      and should never be observed in communication between proper
      implementations.






Dierks & Rescorla           Standards Track                    [Page 30]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   bad_record_mac
      This alert is returned if a record is received with an incorrect
      MAC.  This alert also MUST be returned if an alert is sent because
      a TLSCiphertext decrypted in an invalid way: either it wasn't an
      even multiple of the block length, or its padding values, when
      checked, weren't correct.  This message is always fatal and should
      never be observed in communication between proper implementations
      (except when messages were corrupted in the network).

   decryption_failed_RESERVED
      This alert was used in some earlier versions of TLS, and may have
      permitted certain attacks against the CBC mode [CBCATT].  It MUST
      NOT be sent by compliant implementations.

   record_overflow
      A TLSCiphertext record was received that had a length more than
      2^14+2048 bytes, or a record decrypted to a TLSCompressed record
      with more than 2^14+1024 bytes.  This message is always fatal and
      should never be observed in communication between proper
      implementations (except when messages were corrupted in the
      network).

   decompression_failure
      The decompression function received improper input (e.g., data
      that would expand to excessive length).  This message is always
      fatal and should never be observed in communication between proper
      implementations.

   handshake_failure
      Reception of a handshake_failure alert message indicates that the
      sender was unable to negotiate an acceptable set of security
      parameters given the options available.  This is a fatal error.

   no_certificate_RESERVED
      This alert was used in SSLv3 but not any version of TLS.  It MUST
      NOT be sent by compliant implementations.

   bad_certificate
      A certificate was corrupt, contained signatures that did not
      verify correctly, etc.

   unsupported_certificate
      A certificate was of an unsupported type.

   certificate_revoked
      A certificate was revoked by its signer.





Dierks & Rescorla           Standards Track                    [Page 31]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   certificate_expired
      A certificate has expired or is not currently valid.

   certificate_unknown
      Some other (unspecified) issue arose in processing the
      certificate, rendering it unacceptable.

   illegal_parameter
      A field in the handshake was out of range or inconsistent with
      other fields.  This message is always fatal.

   unknown_ca
      A valid certificate chain or partial chain was received, but the
      certificate was not accepted because the CA certificate could not
      be located or couldn't be matched with a known, trusted CA.  This
      message is always fatal.

   access_denied
      A valid certificate was received, but when access control was
      applied, the sender decided not to proceed with negotiation.  This
      message is always fatal.

   decode_error
      A message could not be decoded because some field was out of the
      specified range or the length of the message was incorrect.  This
      message is always fatal and should never be observed in
      communication between proper implementations (except when messages
      were corrupted in the network).

   decrypt_error
      A handshake cryptographic operation failed, including being unable
      to correctly verify a signature or validate a Finished message.
      This message is always fatal.

   export_restriction_RESERVED
      This alert was used in some earlier versions of TLS.  It MUST NOT
      be sent by compliant implementations.

   protocol_version
      The protocol version the client has attempted to negotiate is
      recognized but not supported.  (For example, old protocol versions
      might be avoided for security reasons.)  This message is always
      fatal.








Dierks & Rescorla           Standards Track                    [Page 32]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   insufficient_security
      Returned instead of handshake_failure when a negotiation has
      failed specifically because the server requires ciphers more
      secure than those supported by the client.  This message is always
      fatal.

   internal_error
      An internal error unrelated to the peer or the correctness of the
      protocol (such as a memory allocation failure) makes it impossible
      to continue.  This message is always fatal.

   user_canceled
      This handshake is being canceled for some reason unrelated to a
      protocol failure.  If the user cancels an operation after the
      handshake is complete, just closing the connection by sending a
      close_notify is more appropriate.  This alert should be followed
      by a close_notify.  This message is generally a warning.

   no_renegotiation
      Sent by the client in response to a hello request or by the server
      in response to a client hello after initial handshaking.  Either
      of these would normally lead to renegotiation; when that is not
      appropriate, the recipient should respond with this alert.  At
      that point, the original requester can decide whether to proceed
      with the connection.  One case where this would be appropriate is
      where a server has spawned a process to satisfy a request; the
      process might receive security parameters (key length,
      authentication, etc.) at startup, and it might be difficult to
      communicate changes to these parameters after that point.  This
      message is always a warning.

   unsupported_extension
      sent by clients that receive an extended server hello containing
      an extension that they did not put in the corresponding client
      hello.  This message is always fatal.

   New Alert values are assigned by IANA as described in Section 12.

7.3.  Handshake Protocol Overview

   The cryptographic parameters of the session state are produced by the
   TLS Handshake Protocol, which operates on top of the TLS record
   layer.  When a TLS client and server first start communicating, they
   agree on a protocol version, select cryptographic algorithms,
   optionally authenticate each other, and use public-key encryption
   techniques to generate shared secrets.





Dierks & Rescorla           Standards Track                    [Page 33]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The TLS Handshake Protocol involves the following steps:

   -  Exchange hello messages to agree on algorithms, exchange random
      values, and check for session resumption.

   -  Exchange the necessary cryptographic parameters to allow the
      client and server to agree on a premaster secret.

   -  Exchange certificates and cryptographic information to allow the
      client and server to authenticate themselves.

   -  Generate a master secret from the premaster secret and exchanged
      random values.

   -  Provide security parameters to the record layer.

   -  Allow the client and server to verify that their peer has
      calculated the same security parameters and that the handshake
      occurred without tampering by an attacker.

   Note that higher layers should not be overly reliant on whether TLS
   always negotiates the strongest possible connection between two
   peers.  There are a number of ways in which a man-in-the-middle
   attacker can attempt to make two entities drop down to the least
   secure method they support.  The protocol has been designed to
   minimize this risk, but there are still attacks available: for
   example, an attacker could block access to the port a secure service
   runs on, or attempt to get the peers to negotiate an unauthenticated
   connection.  The fundamental rule is that higher levels must be
   cognizant of what their security requirements are and never transmit
   information over a channel less secure than what they require.  The
   TLS protocol is secure in that any cipher suite offers its promised
   level of security: if you negotiate 3DES with a 1024-bit RSA key
   exchange with a host whose certificate you have verified, you can
   expect to be that secure.

   These goals are achieved by the handshake protocol, which can be
   summarized as follows: The client sends a ClientHello message to
   which the server must respond with a ServerHello message, or else a
   fatal error will occur and the connection will fail.  The ClientHello
   and ServerHello are used to establish security enhancement
   capabilities between client and server.  The ClientHello and
   ServerHello establish the following attributes: Protocol Version,
   Session ID, Cipher Suite, and Compression Method.  Additionally, two
   random values are generated and exchanged: ClientHello.random and
   ServerHello.random.





Dierks & Rescorla           Standards Track                    [Page 34]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The actual key exchange uses up to four messages: the server
   Certificate, the ServerKeyExchange, the client Certificate, and the
   ClientKeyExchange.  New key exchange methods can be created by
   specifying a format for these messages and by defining the use of the
   messages to allow the client and server to agree upon a shared
   secret.  This secret MUST be quite long; currently defined key
   exchange methods exchange secrets that range from 46 bytes upwards.

   Following the hello messages, the server will send its certificate in
   a Certificate message if it is to be authenticated.  Additionally, a
   ServerKeyExchange message may be sent, if it is required (e.g., if
   the server has no certificate, or if its certificate is for signing
   only).  If the server is authenticated, it may request a certificate
   from the client, if that is appropriate to the cipher suite selected.
   Next, the server will send the ServerHelloDone message, indicating
   that the hello-message phase of the handshake is complete.  The
   server will then wait for a client response.  If the server has sent
   a CertificateRequest message, the client MUST send the Certificate
   message.  The ClientKeyExchange message is now sent, and the content
   of that message will depend on the public key algorithm selected
   between the ClientHello and the ServerHello.  If the client has sent
   a certificate with signing ability, a digitally-signed
   CertificateVerify message is sent to explicitly verify possession of
   the private key in the certificate.

   At this point, a ChangeCipherSpec message is sent by the client, and
   the client copies the pending Cipher Spec into the current Cipher
   Spec.  The client then immediately sends the Finished message under
   the new algorithms, keys, and secrets.  In response, the server will
   send its own ChangeCipherSpec message, transfer the pending to the
   current Cipher Spec, and send its Finished message under the new
   Cipher Spec.  At this point, the handshake is complete, and the
   client and server may begin to exchange application layer data.  (See
   flow chart below.)  Application data MUST NOT be sent prior to the
   completion of the first handshake (before a cipher suite other than
   TLS_NULL_WITH_NULL_NULL is established).















Dierks & Rescorla           Standards Track                    [Page 35]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      Client                                               Server

      ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
      Application Data             <------->     Application Data

             Figure 1.  Message flow for a full handshake

   * Indicates optional or situation-dependent messages that are not
   always sent.

   Note: To help avoid pipeline stalls, ChangeCipherSpec is an
   independent TLS protocol content type, and is not actually a TLS
   handshake message.

   When the client and server decide to resume a previous session or
   duplicate an existing session (instead of negotiating new security
   parameters), the message flow is as follows:

   The client sends a ClientHello using the Session ID of the session to
   be resumed.  The server then checks its session cache for a match.
   If a match is found, and the server is willing to re-establish the
   connection under the specified session state, it will send a
   ServerHello with the same Session ID value.  At this point, both
   client and server MUST send ChangeCipherSpec messages and proceed
   directly to Finished messages.  Once the re-establishment is
   complete, the client and server MAY begin to exchange application
   layer data.  (See flow chart below.)  If a Session ID match is not
   found, the server generates a new session ID, and the TLS client and
   server perform a full handshake.










Dierks & Rescorla           Standards Track                    [Page 36]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      Client                                                Server

      ClientHello                   -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------             Finished
      [ChangeCipherSpec]
      Finished                      -------->
      Application Data              <------->     Application Data

          Figure 2.  Message flow for an abbreviated handshake

   The contents and significance of each message will be presented in
   detail in the following sections.

7.4.  Handshake Protocol

   The TLS Handshake Protocol is one of the defined higher-level clients
   of the TLS Record Protocol.  This protocol is used to negotiate the
   secure attributes of a session.  Handshake messages are supplied to
   the TLS record layer, where they are encapsulated within one or more
   TLSPlaintext structures, which are processed and transmitted as
   specified by the current active session state.

      enum {
          hello_request(0), client_hello(1), server_hello(2),
          certificate(11), server_key_exchange (12),
          certificate_request(13), server_hello_done(14),
          certificate_verify(15), client_key_exchange(16),
          finished(20), (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
          } body;
      } Handshake;



Dierks & Rescorla           Standards Track                    [Page 37]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The handshake protocol messages are presented below in the order they
   MUST be sent; sending handshake messages in an unexpected order
   results in a fatal error.  Unneeded handshake messages can be
   omitted, however.  Note one exception to the ordering: the
   Certificate message is used twice in the handshake (from server to
   client, then from client to server), but described only in its first
   position.  The one message that is not bound by these ordering rules
   is the HelloRequest message, which can be sent at any time, but which
   SHOULD be ignored by the client if it arrives in the middle of a
   handshake.

   New handshake message types are assigned by IANA as described in
   Section 12.

7.4.1.  Hello Messages

   The hello phase messages are used to exchange security enhancement
   capabilities between the client and server.  When a new session
   begins, the record layer's connection state encryption, hash, and
   compression algorithms are initialized to null.  The current
   connection state is used for renegotiation messages.

7.4.1.1.  Hello Request

   When this message will be sent:

      The HelloRequest message MAY be sent by the server at any time.

   Meaning of this message:

      HelloRequest is a simple notification that the client should begin
      the negotiation process anew.  In response, the client should send
      a ClientHello message when convenient.  This message is not
      intended to establish which side is the client or server but
      merely to initiate a new negotiation.  Servers SHOULD NOT send a
      HelloRequest immediately upon the client's initial connection.  It
      is the client's job to send a ClientHello at that time.

      This message will be ignored by the client if the client is
      currently negotiating a session.  This message MAY be ignored by
      the client if it does not wish to renegotiate a session, or the
      client may, if it wishes, respond with a no_renegotiation alert.
      Since handshake messages are intended to have transmission
      precedence over application data, it is expected that the
      negotiation will begin before no more than a few records are
      received from the client.  If the server sends a HelloRequest but
      does not receive a ClientHello in response, it may close the
      connection with a fatal alert.



Dierks & Rescorla           Standards Track                    [Page 38]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      After sending a HelloRequest, servers SHOULD NOT repeat the
      request until the subsequent handshake negotiation is complete.

   Structure of this message:

      struct { } HelloRequest;

   This message MUST NOT be included in the message hashes that are
   maintained throughout the handshake and used in the Finished messages
   and the certificate verify message.

7.4.1.2.  Client Hello

   When this message will be sent:

      When a client first connects to a server, it is required to send
      the ClientHello as its first message.  The client can also send a
      ClientHello in response to a HelloRequest or on its own initiative
      in order to renegotiate the security parameters in an existing
      connection.

   Structure of this message:

      The ClientHello message includes a random structure, which is used
      later in the protocol.

         struct {
             uint32 gmt_unix_time;
             opaque random_bytes[28];
         } Random;

      gmt_unix_time
         The current time and date in standard UNIX 32-bit format
         (seconds since the midnight starting Jan 1, 1970, UTC, ignoring
         leap seconds) according to the sender's internal clock.  Clocks
         are not required to be set correctly by the basic TLS protocol;
         higher-level or application protocols may define additional
         requirements.  Note that, for historical reasons, the data
         element is named using GMT, the predecessor of the current
         worldwide time base, UTC.

      random_bytes
         28 bytes generated by a secure random number generator.

   The ClientHello message includes a variable-length session
   identifier.  If not empty, the value identifies a session between the
   same client and server whose security parameters the client wishes to
   reuse.  The session identifier MAY be from an earlier connection,



Dierks & Rescorla           Standards Track                    [Page 39]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   this connection, or from another currently active connection.  The
   second option is useful if the client only wishes to update the
   random structures and derived values of a connection, and the third
   option makes it possible to establish several independent secure
   connections without repeating the full handshake protocol.  These
   independent connections may occur sequentially or simultaneously; a
   SessionID becomes valid when the handshake negotiating it completes
   with the exchange of Finished messages and persists until it is
   removed due to aging or because a fatal error was encountered on a
   connection associated with the session.  The actual contents of the
   SessionID are defined by the server.

      opaque SessionID<0..32>;

   Warning: Because the SessionID is transmitted without encryption or
   immediate MAC protection, servers MUST NOT place confidential
   information in session identifiers or let the contents of fake
   session identifiers cause any breach of security.  (Note that the
   content of the handshake as a whole, including the SessionID, is
   protected by the Finished messages exchanged at the end of the
   handshake.)

   The cipher suite list, passed from the client to the server in the
   ClientHello message, contains the combinations of cryptographic
   algorithms supported by the client in order of the client's
   preference (favorite choice first).  Each cipher suite defines a key
   exchange algorithm, a bulk encryption algorithm (including secret key
   length), a MAC algorithm, and a PRF.  The server will select a cipher
   suite or, if no acceptable choices are presented, return a handshake
   failure alert and close the connection.  If the list contains cipher
   suites the server does not recognize, support, or wish to use, the
   server MUST ignore those cipher suites, and process the remaining
   ones as usual.

      uint8 CipherSuite[2];    /* Cryptographic suite selector */

   The ClientHello includes a list of compression algorithms supported
   by the client, ordered according to the client's preference.

      enum { null(0), (255) } CompressionMethod;











Dierks & Rescorla           Standards Track                    [Page 40]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          ProtocolVersion client_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suites<2..2^16-2>;
          CompressionMethod compression_methods<1..2^8-1>;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ClientHello;

   TLS allows extensions to follow the compression_methods field in an
   extensions block.  The presence of extensions can be detected by
   determining whether there are bytes following the compression_methods
   at the end of the ClientHello.  Note that this method of detecting
   optional data differs from the normal TLS method of having a
   variable-length field, but it is used for compatibility with TLS
   before extensions were defined.

   client_version
      The version of the TLS protocol by which the client wishes to
      communicate during this session.  This SHOULD be the latest
      (highest valued) version supported by the client.  For this
      version of the specification, the version will be 3.3 (see
      Appendix E for details about backward compatibility).

   random
      A client-generated random structure.

   session_id
      The ID of a session the client wishes to use for this connection.
      This field is empty if no session_id is available, or if the
      client wishes to generate new security parameters.

   cipher_suites
      This is a list of the cryptographic options supported by the
      client, with the client's first preference first.  If the
      session_id field is not empty (implying a session resumption
      request), this vector MUST include at least the cipher_suite from
      that session.  Values are defined in Appendix A.5.

   compression_methods
      This is a list of the compression methods supported by the client,
      sorted by client preference.  If the session_id field is not empty
      (implying a session resumption request), it MUST include the



Dierks & Rescorla           Standards Track                    [Page 41]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      compression_method from that session.  This vector MUST contain,
      and all implementations MUST support, CompressionMethod.null.
      Thus, a client and server will always be able to agree on a
      compression method.

   extensions
      Clients MAY request extended functionality from servers by sending
      data in the extensions field.  The actual "Extension" format is
      defined in Section 7.4.1.4.

   In the event that a client requests additional functionality using
   extensions, and this functionality is not supplied by the server, the
   client MAY abort the handshake.  A server MUST accept ClientHello
   messages both with and without the extensions field, and (as for all
   other messages) it MUST check that the amount of data in the message
   precisely matches one of these formats; if not, then it MUST send a
   fatal "decode_error" alert.

   After sending the ClientHello message, the client waits for a
   ServerHello message.  Any handshake message returned by the server,
   except for a HelloRequest, is treated as a fatal error.

7.4.1.3.  Server Hello

   When this message will be sent:

      The server will send this message in response to a ClientHello
      message when it was able to find an acceptable set of algorithms.
      If it cannot find such a match, it will respond with a handshake
      failure alert.

   Structure of this message:

      struct {
          ProtocolVersion server_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ServerHello;





Dierks & Rescorla           Standards Track                    [Page 42]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The presence of extensions can be detected by determining whether
   there are bytes following the compression_method field at the end of
   the ServerHello.

   server_version
      This field will contain the lower of that suggested by the client
      in the client hello and the highest supported by the server.  For
      this version of the specification, the version is 3.3.  (See
      Appendix E for details about backward compatibility.)

   random
      This structure is generated by the server and MUST be
      independently generated from the ClientHello.random.

   session_id
      This is the identity of the session corresponding to this
      connection.  If the ClientHello.session_id was non-empty, the
      server will look in its session cache for a match.  If a match is
      found and the server is willing to establish the new connection
      using the specified session state, the server will respond with
      the same value as was supplied by the client.  This indicates a
      resumed session and dictates that the parties must proceed
      directly to the Finished messages.  Otherwise, this field will
      contain a different value identifying the new session.  The server
      may return an empty session_id to indicate that the session will
      not be cached and therefore cannot be resumed.  If a session is
      resumed, it must be resumed using the same cipher suite it was
      originally negotiated with.  Note that there is no requirement
      that the server resume any session even if it had formerly
      provided a session_id.  Clients MUST be prepared to do a full
      negotiation -- including negotiating new cipher suites -- during
      any handshake.

   cipher_suite
      The single cipher suite selected by the server from the list in
      ClientHello.cipher_suites.  For resumed sessions, this field is
      the value from the state of the session being resumed.

   compression_method
      The single compression algorithm selected by the server from the
      list in ClientHello.compression_methods.  For resumed sessions,
      this field is the value from the resumed session state.

   extensions
      A list of extensions.  Note that only extensions offered by the
      client can appear in the server's list.





Dierks & Rescorla           Standards Track                    [Page 43]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


7.4.1.4.  Hello Extensions

   The extension format is:

      struct {
          ExtensionType extension_type;
          opaque extension_data<0..2^16-1>;
      } Extension;

      enum {
          signature_algorithms(13), (65535)
      } ExtensionType;

   Here:

   -  "extension_type" identifies the particular extension type.

   -  "extension_data" contains information specific to the particular
      extension type.

   The initial set of extensions is defined in a companion document
   [TLSEXT].  The list of extension types is maintained by IANA as
   described in Section 12.

   An extension type MUST NOT appear in the ServerHello unless the same
   extension type appeared in the corresponding ClientHello.  If a
   client receives an extension type in ServerHello that it did not
   request in the associated ClientHello, it MUST abort the handshake
   with an unsupported_extension fatal alert.

   Nonetheless, "server-oriented" extensions may be provided in the
   future within this framework.  Such an extension (say, of type x)
   would require the client to first send an extension of type x in a
   ClientHello with empty extension_data to indicate that it supports
   the extension type.  In this case, the client is offering the
   capability to understand the extension type, and the server is taking
   the client up on its offer.

   When multiple extensions of different types are present in the
   ClientHello or ServerHello messages, the extensions MAY appear in any
   order.  There MUST NOT be more than one extension of the same type.

   Finally, note that extensions can be sent both when starting a new
   session and when requesting session resumption.  Indeed, a client
   that requests session resumption does not in general know whether the
   server will accept this request, and therefore it SHOULD send the
   same extensions as it would send if it were not attempting
   resumption.



Dierks & Rescorla           Standards Track                    [Page 44]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   In general, the specification of each extension type needs to
   describe the effect of the extension both during full handshake and
   session resumption.  Most current TLS extensions are relevant only
   when a session is initiated: when an older session is resumed, the
   server does not process these extensions in Client Hello, and does
   not include them in Server Hello.  However, some extensions may
   specify different behavior during session resumption.

   There are subtle (and not so subtle) interactions that may occur in
   this protocol between new features and existing features which may
   result in a significant reduction in overall security.  The following
   considerations should be taken into account when designing new
   extensions:

   -  Some cases where a server does not agree to an extension are error
      conditions, and some are simply refusals to support particular
      features.  In general, error alerts should be used for the former,
      and a field in the server extension response for the latter.

   -  Extensions should, as far as possible, be designed to prevent any
      attack that forces use (or non-use) of a particular feature by
      manipulation of handshake messages.  This principle should be
      followed regardless of whether the feature is believed to cause a
      security problem.

      Often the fact that the extension fields are included in the
      inputs to the Finished message hashes will be sufficient, but
      extreme care is needed when the extension changes the meaning of
      messages sent in the handshake phase.  Designers and implementors
      should be aware of the fact that until the handshake has been
      authenticated, active attackers can modify messages and insert,
      remove, or replace extensions.

   -  It would be technically possible to use extensions to change major
      aspects of the design of TLS; for example the design of cipher
      suite negotiation.  This is not recommended; it would be more
      appropriate to define a new version of TLS -- particularly since
      the TLS handshake algorithms have specific protection against
      version rollback attacks based on the version number, and the
      possibility of version rollback should be a significant
      consideration in any major design change.

7.4.1.4.1.  Signature Algorithms

   The client uses the "signature_algorithms" extension to indicate to
   the server which signature/hash algorithm pairs may be used in
   digital signatures.  The "extension_data" field of this extension
   contains a "supported_signature_algorithms" value.



Dierks & Rescorla           Standards Track                    [Page 45]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      enum {
          none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
          sha512(6), (255)
      } HashAlgorithm;

      enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
        SignatureAlgorithm;

      struct {
            HashAlgorithm hash;
            SignatureAlgorithm signature;
      } SignatureAndHashAlgorithm;

      SignatureAndHashAlgorithm
        supported_signature_algorithms<2..2^16-2>;

   Each SignatureAndHashAlgorithm value lists a single hash/signature
   pair that the client is willing to verify.  The values are indicated
   in descending order of preference.

   Note: Because not all signature algorithms and hash algorithms may be
   accepted by an implementation (e.g., DSA with SHA-1, but not
   SHA-256), algorithms here are listed in pairs.

   hash
      This field indicates the hash algorithm which may be used.  The
      values indicate support for unhashed data, MD5 [MD5], SHA-1,
      SHA-224, SHA-256, SHA-384, and SHA-512 [SHS], respectively.  The
      "none" value is provided for future extensibility, in case of a
      signature algorithm which does not require hashing before signing.

   signature
      This field indicates the signature algorithm that may be used.
      The values indicate anonymous signatures, RSASSA-PKCS1-v1_5
      [PKCS1] and DSA [DSS], and ECDSA [ECDSA], respectively.  The
      "anonymous" value is meaningless in this context but used in
      Section 7.4.3.  It MUST NOT appear in this extension.

   The semantics of this extension are somewhat complicated because the
   cipher suite indicates permissible signature algorithms but not hash
   algorithms.  Sections 7.4.2 and 7.4.3 describe the appropriate rules.

   If the client supports only the default hash and signature algorithms
   (listed in this section), it MAY omit the signature_algorithms
   extension.  If the client does not support the default algorithms, or
   supports other hash and signature algorithms (and it is willing to
   use them for verifying messages sent by the server, i.e., server
   certificates and server key exchange), it MUST send the



Dierks & Rescorla           Standards Track                    [Page 46]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   signature_algorithms extension, listing the algorithms it is willing
   to accept.

   If the client does not send the signature_algorithms extension, the
   server MUST do the following:

   -  If the negotiated key exchange algorithm is one of (RSA, DHE_RSA,
      DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA), behave as if client had
      sent the value {sha1,rsa}.

   -  If the negotiated key exchange algorithm is one of (DHE_DSS,
      DH_DSS), behave as if the client had sent the value {sha1,dsa}.

   -  If the negotiated key exchange algorithm is one of (ECDH_ECDSA,
      ECDHE_ECDSA), behave as if the client had sent value {sha1,ecdsa}.

   Note: this is a change from TLS 1.1 where there are no explicit
   rules, but as a practical matter one can assume that the peer
   supports MD5 and SHA-1.

   Note: this extension is not meaningful for TLS versions prior to 1.2.
   Clients MUST NOT offer it if they are offering prior versions.
   However, even if clients do offer it, the rules specified in [TLSEXT]
   require servers to ignore extensions they do not understand.

   Servers MUST NOT send this extension.  TLS servers MUST support
   receiving this extension.

   When performing session resumption, this extension is not included in
   Server Hello, and the server ignores the extension in Client Hello
   (if present).

7.4.2.  Server Certificate

   When this message will be sent:

      The server MUST send a Certificate message whenever the agreed-
      upon key exchange method uses certificates for authentication
      (this includes all key exchange methods defined in this document
      except DH_anon).  This message will always immediately follow the
      ServerHello message.

   Meaning of this message:

      This message conveys the server's certificate chain to the client.

      The certificate MUST be appropriate for the negotiated cipher
      suite's key exchange algorithm and any negotiated extensions.



Dierks & Rescorla           Standards Track                    [Page 47]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Structure of this message:

      opaque ASN.1Cert<1..2^24-1>;

      struct {
          ASN.1Cert certificate_list<0..2^24-1>;
      } Certificate;

   certificate_list
      This is a sequence (chain) of certificates.  The sender's
      certificate MUST come first in the list.  Each following
      certificate MUST directly certify the one preceding it.  Because
      certificate validation requires that root keys be distributed
      independently, the self-signed certificate that specifies the root
      certificate authority MAY be omitted from the chain, under the
      assumption that the remote end must already possess it in order to
      validate it in any case.

   The same message type and structure will be used for the client's
   response to a certificate request message.  Note that a client MAY
   send no certificates if it does not have an appropriate certificate
   to send in response to the server's authentication request.

   Note: PKCS #7 [PKCS7] is not used as the format for the certificate
   vector because PKCS #6 [PKCS6] extended certificates are not used.
   Also, PKCS #7 defines a SET rather than a SEQUENCE, making the task
   of parsing the list more difficult.

   The following rules apply to the certificates sent by the server:

   -  The certificate type MUST be X.509v3, unless explicitly negotiated
      otherwise (e.g., [TLSPGP]).

   -  The end entity certificate's public key (and associated
      restrictions) MUST be compatible with the selected key exchange
      algorithm.

      Key Exchange Alg.  Certificate Key Type

      RSA                RSA public key; the certificate MUST allow the
      RSA_PSK            key to be used for encryption (the
                         keyEncipherment bit MUST be set if the key
                         usage extension is present).
                         Note: RSA_PSK is defined in [TLSPSK].







Dierks & Rescorla           Standards Track                    [Page 48]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      DHE_RSA            RSA public key; the certificate MUST allow the
      ECDHE_RSA          key to be used for signing (the
                         digitalSignature bit MUST be set if the key
                         usage extension is present) with the signature
                         scheme and hash algorithm that will be employed
                         in the server key exchange message.
                         Note: ECDHE_RSA is defined in [TLSECC].

      DHE_DSS            DSA public key; the certificate MUST allow the
                         key to be used for signing with the hash
                         algorithm that will be employed in the server
                         key exchange message.

      DH_DSS             Diffie-Hellman public key; the keyAgreement bit
      DH_RSA             MUST be set if the key usage extension is
                         present.

      ECDH_ECDSA         ECDH-capable public key; the public key MUST
      ECDH_RSA           use a curve and point format supported by the
                         client, as described in [TLSECC].

      ECDHE_ECDSA        ECDSA-capable public key; the certificate MUST
                         allow the key to be used for signing with the
                         hash algorithm that will be employed in the
                         server key exchange message.  The public key
                         MUST use a curve and point format supported by
                         the client, as described in  [TLSECC].

   -  The "server_name" and "trusted_ca_keys" extensions [TLSEXT] are
      used to guide certificate selection.

   If the client provided a "signature_algorithms" extension, then all
   certificates provided by the server MUST be signed by a
   hash/signature algorithm pair that appears in that extension.  Note
   that this implies that a certificate containing a key for one
   signature algorithm MAY be signed using a different signature
   algorithm (for instance, an RSA key signed with a DSA key).  This is
   a departure from TLS 1.1, which required that the algorithms be the
   same.  Note that this also implies that the DH_DSS, DH_RSA,
   ECDH_ECDSA, and ECDH_RSA key exchange algorithms do not restrict the
   algorithm used to sign the certificate.  Fixed DH certificates MAY be
   signed with any hash/signature algorithm pair appearing in the
   extension.  The names DH_DSS, DH_RSA, ECDH_ECDSA, and ECDH_RSA are
   historical.







Dierks & Rescorla           Standards Track                    [Page 49]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   If the server has multiple certificates, it chooses one of them based
   on the above-mentioned criteria (in addition to other criteria, such
   as transport layer endpoint, local configuration and preferences,
   etc.).  If the server has a single certificate, it SHOULD attempt to
   validate that it meets these criteria.

   Note that there are certificates that use algorithms and/or algorithm
   combinations that cannot be currently used with TLS.  For example, a
   certificate with RSASSA-PSS signature key (id-RSASSA-PSS OID in
   SubjectPublicKeyInfo) cannot be used because TLS defines no
   corresponding signature algorithm.

   As cipher suites that specify new key exchange methods are specified
   for the TLS protocol, they will imply the certificate format and the
   required encoded keying information.

7.4.3.  Server Key Exchange Message

   When this message will be sent:

      This message will be sent immediately after the server Certificate
      message (or the ServerHello message, if this is an anonymous
      negotiation).

      The ServerKeyExchange message is sent by the server only when the
      server Certificate message (if sent) does not contain enough data
      to allow the client to exchange a premaster secret.  This is true
      for the following key exchange methods:

         DHE_DSS
         DHE_RSA
         DH_anon

      It is not legal to send the ServerKeyExchange message for the
      following key exchange methods:

         RSA
         DH_DSS
         DH_RSA

      Other key exchange algorithms, such as those defined in [TLSECC],
      MUST specify whether the ServerKeyExchange message is sent or not;
      and if the message is sent, its contents.








Dierks & Rescorla           Standards Track                    [Page 50]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Meaning of this message:

      This message conveys cryptographic information to allow the client
      to communicate the premaster secret: a Diffie-Hellman public key
      with which the client can complete a key exchange (with the result
      being the premaster secret) or a public key for some other
      algorithm.

   Structure of this message:

      enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa
            /* may be extended, e.g., for ECDH -- see [TLSECC] */
           } KeyExchangeAlgorithm;

      struct {
          opaque dh_p<1..2^16-1>;
          opaque dh_g<1..2^16-1>;
          opaque dh_Ys<1..2^16-1>;
      } ServerDHParams;     /* Ephemeral DH parameters */

      dh_p
         The prime modulus used for the Diffie-Hellman operation.

      dh_g
         The generator used for the Diffie-Hellman operation.

      dh_Ys
         The server's Diffie-Hellman public value (g^X mod p).























Dierks & Rescorla           Standards Track                    [Page 51]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          select (KeyExchangeAlgorithm) {
              case dh_anon:
                  ServerDHParams params;
              case dhe_dss:
              case dhe_rsa:
                  ServerDHParams params;
                  digitally-signed struct {
                      opaque client_random[32];
                      opaque server_random[32];
                      ServerDHParams params;
                  } signed_params;
              case rsa:
              case dh_dss:
              case dh_rsa:
                  struct {} ;
                 /* message is omitted for rsa, dh_dss, and dh_rsa */
              /* may be extended, e.g., for ECDH -- see [TLSECC] */
          };
      } ServerKeyExchange;

      params
         The server's key exchange parameters.

      signed_params
         For non-anonymous key exchanges, a signature over the server's
         key exchange parameters.

   If the client has offered the "signature_algorithms" extension, the
   signature algorithm and hash algorithm MUST be a pair listed in that
   extension.  Note that there is a possibility for inconsistencies
   here.  For instance, the client might offer DHE_DSS key exchange but
   omit any DSA pairs from its "signature_algorithms" extension.  In
   order to negotiate correctly, the server MUST check any candidate
   cipher suites against the "signature_algorithms" extension before
   selecting them.  This is somewhat inelegant but is a compromise
   designed to minimize changes to the original cipher suite design.

   In addition, the hash and signature algorithms MUST be compatible
   with the key in the server's end-entity certificate.  RSA keys MAY be
   used with any permitted hash algorithm, subject to restrictions in
   the certificate, if any.

   Because DSA signatures do not contain any secure indication of hash
   algorithm, there is a risk of hash substitution if multiple hashes
   may be used with any key.  Currently, DSA [DSS] may only be used with
   SHA-1.  Future revisions of DSS [DSS-3] are expected to allow the use
   of other digest algorithms with DSA, as well as guidance as to which



Dierks & Rescorla           Standards Track                    [Page 52]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   digest algorithms should be used with each key size.  In addition,
   future revisions of [PKIX] may specify mechanisms for certificates to
   indicate which digest algorithms are to be used with DSA.

   As additional cipher suites are defined for TLS that include new key
   exchange algorithms, the server key exchange message will be sent if
   and only if the certificate type associated with the key exchange
   algorithm does not provide enough information for the client to
   exchange a premaster secret.

7.4.4.  Certificate Request

   When this message will be sent:

       A non-anonymous server can optionally request a certificate from
       the client, if appropriate for the selected cipher suite.  This
       message, if sent, will immediately follow the ServerKeyExchange
       message (if it is sent; otherwise, this message follows the
       server's Certificate message).

   Structure of this message:

      enum {
          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
          rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
          fortezza_dms_RESERVED(20), (255)
      } ClientCertificateType;

      opaque DistinguishedName<1..2^16-1>;

      struct {
          ClientCertificateType certificate_types<1..2^8-1>;
          SignatureAndHashAlgorithm
            supported_signature_algorithms<2^16-1>;
          DistinguishedName certificate_authorities<0..2^16-1>;
      } CertificateRequest;

   certificate_types
      A list of the types of certificate types that the client may
      offer.

         rsa_sign        a certificate containing an RSA key
         dss_sign        a certificate containing a DSA key
         rsa_fixed_dh    a certificate containing a static DH key.
         dss_fixed_dh    a certificate containing a static DH key






Dierks & Rescorla           Standards Track                    [Page 53]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   supported_signature_algorithms
      A list of the hash/signature algorithm pairs that the server is
      able to verify, listed in descending order of preference.

   certificate_authorities
      A list of the distinguished names [X501] of acceptable
      certificate_authorities, represented in DER-encoded format.  These
      distinguished names may specify a desired distinguished name for a
      root CA or for a subordinate CA; thus, this message can be used to
      describe known roots as well as a desired authorization space.  If
      the certificate_authorities list is empty, then the client MAY
      send any certificate of the appropriate ClientCertificateType,
      unless there is some external arrangement to the contrary.

   The interaction of the certificate_types and
   supported_signature_algorithms fields is somewhat complicated.
   certificate_types has been present in TLS since SSLv3, but was
   somewhat underspecified.  Much of its functionality is superseded by
   supported_signature_algorithms.  The following rules apply:

   -  Any certificates provided by the client MUST be signed using a
      hash/signature algorithm pair found in
      supported_signature_algorithms.

   -  The end-entity certificate provided by the client MUST contain a
      key that is compatible with certificate_types.  If the key is a
      signature key, it MUST be usable with some hash/signature
      algorithm pair in supported_signature_algorithms.

   -  For historical reasons, the names of some client certificate types
      include the algorithm used to sign the certificate.  For example,
      in earlier versions of TLS, rsa_fixed_dh meant a certificate
      signed with RSA and containing a static DH key.  In TLS 1.2, this
      functionality has been obsoleted by the
      supported_signature_algorithms, and the certificate type no longer
      restricts the algorithm used to sign the certificate.  For
      example, if the server sends dss_fixed_dh certificate type and
      {{sha1, dsa}, {sha1, rsa}} signature types, the client MAY reply
      with a certificate containing a static DH key, signed with RSA-
      SHA1.

   New ClientCertificateType values are assigned by IANA as described in
   Section 12.

   Note: Values listed as RESERVED may not be used.  They were used in
   SSLv3.





Dierks & Rescorla           Standards Track                    [Page 54]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Note: It is a fatal handshake_failure alert for an anonymous server
   to request client authentication.

7.4.5.  Server Hello Done

   When this message will be sent:

      The ServerHelloDone message is sent by the server to indicate the
      end of the ServerHello and associated messages.  After sending
      this message, the server will wait for a client response.

   Meaning of this message:

      This message means that the server is done sending messages to
      support the key exchange, and the client can proceed with its
      phase of the key exchange.

      Upon receipt of the ServerHelloDone message, the client SHOULD
      verify that the server provided a valid certificate, if required,
      and check that the server hello parameters are acceptable.

   Structure of this message:

      struct { } ServerHelloDone;

7.4.6.  Client Certificate

   When this message will be sent:

      This is the first message the client can send after receiving a
      ServerHelloDone message.  This message is only sent if the server
      requests a certificate.  If no suitable certificate is available,
      the client MUST send a certificate message containing no
      certificates.  That is, the certificate_list structure has a
      length of zero.  If the client does not send any certificates, the
      server MAY at its discretion either continue the handshake without
      client authentication, or respond with a fatal handshake_failure
      alert.  Also, if some aspect of the certificate chain was
      unacceptable (e.g., it was not signed by a known, trusted CA), the
      server MAY at its discretion either continue the handshake
      (considering the client unauthenticated) or send a fatal alert.

      Client certificates are sent using the Certificate structure
      defined in Section 7.4.2.







Dierks & Rescorla           Standards Track                    [Page 55]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Meaning of this message:

      This message conveys the client's certificate chain to the server;
      the server will use it when verifying the CertificateVerify
      message (when the client authentication is based on signing) or
      calculating the premaster secret (for non-ephemeral Diffie-
      Hellman).  The certificate MUST be appropriate for the negotiated
      cipher suite's key exchange algorithm, and any negotiated
      extensions.

   In particular:

   -  The certificate type MUST be X.509v3, unless explicitly negotiated
      otherwise (e.g., [TLSPGP]).

   -  The end-entity certificate's public key (and associated
      restrictions) has to be compatible with the certificate types
      listed in CertificateRequest:

      Client Cert. Type   Certificate Key Type

      rsa_sign            RSA public key; the certificate MUST allow the
                          key to be used for signing with the signature
                          scheme and hash algorithm that will be
                          employed in the certificate verify message.

      dss_sign            DSA public key; the certificate MUST allow the
                          key to be used for signing with the hash
                          algorithm that will be employed in the
                          certificate verify message.

      ecdsa_sign          ECDSA-capable public key; the certificate MUST
                          allow the key to be used for signing with the
                          hash algorithm that will be employed in the
                          certificate verify message; the public key
                          MUST use a curve and point format supported by
                          the server.

      rsa_fixed_dh        Diffie-Hellman public key; MUST use the same
      dss_fixed_dh        parameters as server's key.

      rsa_fixed_ecdh      ECDH-capable public key; MUST use the
      ecdsa_fixed_ecdh    same curve as the server's key, and MUST use a
                          point format supported by the server.

   -  If the certificate_authorities list in the certificate request
      message was non-empty, one of the certificates in the certificate
      chain SHOULD be issued by one of the listed CAs.



Dierks & Rescorla           Standards Track                    [Page 56]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   -  The certificates MUST be signed using an acceptable hash/
      signature algorithm pair, as described in Section 7.4.4.  Note
      that this relaxes the constraints on certificate-signing
      algorithms found in prior versions of TLS.

   Note that, as with the server certificate, there are certificates
   that use algorithms/algorithm combinations that cannot be currently
   used with TLS.

7.4.7.  Client Key Exchange Message

   When this message will be sent:

      This message is always sent by the client.  It MUST immediately
      follow the client certificate message, if it is sent.  Otherwise,
      it MUST be the first message sent by the client after it receives
      the ServerHelloDone message.

   Meaning of this message:

      With this message, the premaster secret is set, either by direct
      transmission of the RSA-encrypted secret or by the transmission of
      Diffie-Hellman parameters that will allow each side to agree upon
      the same premaster secret.

      When the client is using an ephemeral Diffie-Hellman exponent,
      then this message contains the client's Diffie-Hellman public
      value.  If the client is sending a certificate containing a static
      DH exponent (i.e., it is doing fixed_dh client authentication),
      then this message MUST be sent but MUST be empty.

   Structure of this message:

      The choice of messages depends on which key exchange method has
      been selected.  See Section 7.4.3 for the KeyExchangeAlgorithm
      definition.















Dierks & Rescorla           Standards Track                    [Page 57]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          select (KeyExchangeAlgorithm) {
              case rsa:
                  EncryptedPreMasterSecret;
              case dhe_dss:
              case dhe_rsa:
              case dh_dss:
              case dh_rsa:
              case dh_anon:
                  ClientDiffieHellmanPublic;
          } exchange_keys;
      } ClientKeyExchange;

7.4.7.1.  RSA-Encrypted Premaster Secret Message

   Meaning of this message:

      If RSA is being used for key agreement and authentication, the
      client generates a 48-byte premaster secret, encrypts it using the
      public key from the server's certificate, and sends the result in
      an encrypted premaster secret message.  This structure is a
      variant of the ClientKeyExchange message and is not a message in
      itself.

   Structure of this message:

      struct {
          ProtocolVersion client_version;
          opaque random[46];
      } PreMasterSecret;

      client_version
         The latest (newest) version supported by the client.  This is
         used to detect version rollback attacks.

      random
         46 securely-generated random bytes.

      struct {
          public-key-encrypted PreMasterSecret pre_master_secret;
      } EncryptedPreMasterSecret;

      pre_master_secret
         This random value is generated by the client and is used to
         generate the master secret, as specified in Section 8.1.






Dierks & Rescorla           Standards Track                    [Page 58]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Note: The version number in the PreMasterSecret is the version
   offered by the client in the ClientHello.client_version, not the
   version negotiated for the connection.  This feature is designed to
   prevent rollback attacks.  Unfortunately, some old implementations
   use the negotiated version instead, and therefore checking the
   version number may lead to failure to interoperate with such
   incorrect client implementations.

   Client implementations MUST always send the correct version number in
   PreMasterSecret.  If ClientHello.client_version is TLS 1.1 or higher,
   server implementations MUST check the version number as described in
   the note below.  If the version number is TLS 1.0 or earlier, server
   implementations SHOULD check the version number, but MAY have a
   configuration option to disable the check.  Note that if the check
   fails, the PreMasterSecret SHOULD be randomized as described below.

   Note: Attacks discovered by Bleichenbacher [BLEI] and Klima et al.
   [KPR03] can be used to attack a TLS server that reveals whether a
   particular message, when decrypted, is properly PKCS#1 formatted,
   contains a valid PreMasterSecret structure, or has the correct
   version number.

   As described by Klima [KPR03], these vulnerabilities can be avoided
   by treating incorrectly formatted message blocks and/or mismatched
   version numbers in a manner indistinguishable from correctly
   formatted RSA blocks.  In other words:

      1. Generate a string R of 46 random bytes

      2. Decrypt the message to recover the plaintext M

      3. If the PKCS#1 padding is not correct, or the length of message
         M is not exactly 48 bytes:
            pre_master_secret = ClientHello.client_version || R
         else If ClientHello.client_version <= TLS 1.0, and version
         number check is explicitly disabled:
            pre_master_secret = M
         else:
            pre_master_secret = ClientHello.client_version || M[2..47]

   Note that explicitly constructing the pre_master_secret with the
   ClientHello.client_version produces an invalid master_secret if the
   client has sent the wrong version in the original pre_master_secret.

   An alternative approach is to treat a version number mismatch as a
   PKCS-1 formatting error and randomize the premaster secret
   completely:




Dierks & Rescorla           Standards Track                    [Page 59]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      1. Generate a string R of 48 random bytes

      2. Decrypt the message to recover the plaintext M

      3. If the PKCS#1 padding is not correct, or the length of message
         M is not exactly 48 bytes:
            pre_master_secret = R
         else If ClientHello.client_version <= TLS 1.0, and version
         number check is explicitly disabled:
            premaster secret = M
         else If M[0..1] != ClientHello.client_version:
            premaster secret = R
         else:
            premaster secret = M

   Although no practical attacks against this construction are known,
   Klima et al. [KPR03] describe some theoretical attacks, and therefore
   the first construction described is RECOMMENDED.

   In any case, a TLS server MUST NOT generate an alert if processing an
   RSA-encrypted premaster secret message fails, or the version number
   is not as expected.  Instead, it MUST continue the handshake with a
   randomly generated premaster secret.  It may be useful to log the
   real cause of failure for troubleshooting purposes; however, care
   must be taken to avoid leaking the information to an attacker
   (through, e.g., timing, log files, or other channels.)

   The RSAES-OAEP encryption scheme defined in [PKCS1] is more secure
   against the Bleichenbacher attack.  However, for maximal
   compatibility with earlier versions of TLS, this specification uses
   the RSAES-PKCS1-v1_5 scheme.  No variants of the Bleichenbacher
   attack are known to exist provided that the above recommendations are
   followed.

   Implementation note: Public-key-encrypted data is represented as an
   opaque vector <0..2^16-1> (see Section 4.7).  Thus, the RSA-encrypted
   PreMasterSecret in a ClientKeyExchange is preceded by two length
   bytes.  These bytes are redundant in the case of RSA because the
   EncryptedPreMasterSecret is the only data in the ClientKeyExchange
   and its length can therefore be unambiguously determined.  The SSLv3
   specification was not clear about the encoding of public-key-
   encrypted data, and therefore many SSLv3 implementations do not
   include the length bytes -- they encode the RSA-encrypted data
   directly in the ClientKeyExchange message.

   This specification requires correct encoding of the
   EncryptedPreMasterSecret complete with length bytes.  The resulting
   PDU is incompatible with many SSLv3 implementations.  Implementors



Dierks & Rescorla           Standards Track                    [Page 60]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   upgrading from SSLv3 MUST modify their implementations to generate
   and accept the correct encoding.  Implementors who wish to be
   compatible with both SSLv3 and TLS should make their implementation's
   behavior dependent on the protocol version.

   Implementation note: It is now known that remote timing-based attacks
   on TLS are possible, at least when the client and server are on the
   same LAN.  Accordingly, implementations that use static RSA keys MUST
   use RSA blinding or some other anti-timing technique, as described in
   [TIMING].

7.4.7.2.  Client Diffie-Hellman Public Value

   Meaning of this message:

      This structure conveys the client's Diffie-Hellman public value
      (Yc) if it was not already included in the client's certificate.
      The encoding used for Yc is determined by the enumerated
      PublicValueEncoding.  This structure is a variant of the client
      key exchange message, and not a message in itself.

   Structure of this message:

      enum { implicit, explicit } PublicValueEncoding;

      implicit
         If the client has sent a certificate which contains a suitable
         Diffie-Hellman key (for fixed_dh client authentication), then
         Yc is implicit and does not need to be sent again.  In this
         case, the client key exchange message will be sent, but it MUST
         be empty.

      explicit
         Yc needs to be sent.

      struct {
          select (PublicValueEncoding) {
              case implicit: struct { };
              case explicit: opaque dh_Yc<1..2^16-1>;
          } dh_public;
      } ClientDiffieHellmanPublic;

      dh_Yc
         The client's Diffie-Hellman public value (Yc).







Dierks & Rescorla           Standards Track                    [Page 61]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


7.4.8.  Certificate Verify

   When this message will be sent:

      This message is used to provide explicit verification of a client
      certificate.  This message is only sent following a client
      certificate that has signing capability (i.e., all certificates
      except those containing fixed Diffie-Hellman parameters).  When
      sent, it MUST immediately follow the client key exchange message.

   Structure of this message:

      struct {
           digitally-signed struct {
               opaque handshake_messages[handshake_messages_length];
           }
      } CertificateVerify;

      Here handshake_messages refers to all handshake messages sent or
      received, starting at client hello and up to, but not including,
      this message, including the type and length fields of the
      handshake messages.  This is the concatenation of all the
      Handshake structures (as defined in Section 7.4) exchanged thus
      far.  Note that this requires both sides to either buffer the
      messages or compute running hashes for all potential hash
      algorithms up to the time of the CertificateVerify computation.
      Servers can minimize this computation cost by offering a
      restricted set of digest algorithms in the CertificateRequest
      message.

      The hash and signature algorithms used in the signature MUST be
      one of those present in the supported_signature_algorithms field
      of the CertificateRequest message.  In addition, the hash and
      signature algorithms MUST be compatible with the key in the
      client's end-entity certificate.  RSA keys MAY be used with any
      permitted hash algorithm, subject to restrictions in the
      certificate, if any.

      Because DSA signatures do not contain any secure indication of
      hash algorithm, there is a risk of hash substitution if multiple
      hashes may be used with any key.  Currently, DSA [DSS] may only be
      used with SHA-1.  Future revisions of DSS [DSS-3] are expected to
      allow the use of other digest algorithms with DSA, as well as
      guidance as to which digest algorithms should be used with each
      key size.  In addition, future revisions of [PKIX] may specify
      mechanisms for certificates to indicate which digest algorithms
      are to be used with DSA.




Dierks & Rescorla           Standards Track                    [Page 62]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


7.4.9.  Finished

   When this message will be sent:

      A Finished message is always sent immediately after a change
      cipher spec message to verify that the key exchange and
      authentication processes were successful.  It is essential that a
      change cipher spec message be received between the other handshake
      messages and the Finished message.

   Meaning of this message:

      The Finished message is the first one protected with the just
      negotiated algorithms, keys, and secrets.  Recipients of Finished
      messages MUST verify that the contents are correct.  Once a side
      has sent its Finished message and received and validated the
      Finished message from its peer, it may begin to send and receive
      application data over the connection.

   Structure of this message:

      struct {
          opaque verify_data[verify_data_length];
      } Finished;

      verify_data
         PRF(master_secret, finished_label, Hash(handshake_messages))
            [0..verify_data_length-1];

      finished_label
         For Finished messages sent by the client, the string
         "client finished".  For Finished messages sent by the server,
         the string "server finished".

      Hash denotes a Hash of the handshake messages.  For the PRF
      defined in Section 5, the Hash MUST be the Hash used as the basis
      for the PRF.  Any cipher suite which defines a different PRF MUST
      also define the Hash to use in the Finished computation.

      In previous versions of TLS, the verify_data was always 12 octets
      long.  In the current version of TLS, it depends on the cipher
      suite.  Any cipher suite which does not explicitly specify
      verify_data_length has a verify_data_length equal to 12.  This
      includes all existing cipher suites.  Note that this
      representation has the same encoding as with previous versions.
      Future cipher suites MAY specify other lengths but such length
      MUST be at least 12 bytes.




Dierks & Rescorla           Standards Track                    [Page 63]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      handshake_messages
         All of the data from all messages in this handshake (not
         including any HelloRequest messages) up to, but not including,
         this message.  This is only data visible at the handshake layer
         and does not include record layer headers.  This is the
         concatenation of all the Handshake structures as defined in
         Section 7.4, exchanged thus far.

   It is a fatal error if a Finished message is not preceded by a
   ChangeCipherSpec message at the appropriate point in the handshake.

   The value handshake_messages includes all handshake messages starting
   at ClientHello up to, but not including, this Finished message.  This
   may be different from handshake_messages in Section 7.4.8 because it
   would include the CertificateVerify message (if sent).  Also, the
   handshake_messages for the Finished message sent by the client will
   be different from that for the Finished message sent by the server,
   because the one that is sent second will include the prior one.

   Note: ChangeCipherSpec messages, alerts, and any other record types
   are not handshake messages and are not included in the hash
   computations.  Also, HelloRequest messages are omitted from handshake
   hashes.

8.  Cryptographic Computations

   In order to begin connection protection, the TLS Record Protocol
   requires specification of a suite of algorithms, a master secret, and
   the client and server random values.  The authentication, encryption,
   and MAC algorithms are determined by the cipher_suite selected by the
   server and revealed in the ServerHello message.  The compression
   algorithm is negotiated in the hello messages, and the random values
   are exchanged in the hello messages.  All that remains is to
   calculate the master secret.

8.1.  Computing the Master Secret

   For all key exchange methods, the same algorithm is used to convert
   the pre_master_secret into the master_secret.  The pre_master_secret
   should be deleted from memory once the master_secret has been
   computed.

      master_secret = PRF(pre_master_secret, "master secret",
                          ClientHello.random + ServerHello.random)
                          [0..47];

   The master secret is always exactly 48 bytes in length.  The length
   of the premaster secret will vary depending on key exchange method.



Dierks & Rescorla           Standards Track                    [Page 64]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


8.1.1.  RSA

   When RSA is used for server authentication and key exchange, a 48-
   byte pre_master_secret is generated by the client, encrypted under
   the server's public key, and sent to the server.  The server uses its
   private key to decrypt the pre_master_secret.  Both parties then
   convert the pre_master_secret into the master_secret, as specified
   above.

8.1.2.  Diffie-Hellman

   A conventional Diffie-Hellman computation is performed.  The
   negotiated key (Z) is used as the pre_master_secret, and is converted
   into the master_secret, as specified above.  Leading bytes of Z that
   contain all zero bits are stripped before it is used as the
   pre_master_secret.

   Note: Diffie-Hellman parameters are specified by the server and may
   be either ephemeral or contained within the server's certificate.

9.  Mandatory Cipher Suites

   In the absence of an application profile standard specifying
   otherwise, a TLS-compliant application MUST implement the cipher
   suite TLS_RSA_WITH_AES_128_CBC_SHA (see Appendix A.5 for the
   definition).

10.  Application Data Protocol

   Application data messages are carried by the record layer and are
   fragmented, compressed, and encrypted based on the current connection
   state.  The messages are treated as transparent data to the record
   layer.

11.  Security Considerations

   Security issues are discussed throughout this memo, especially in
   Appendices D, E, and F.

12.  IANA Considerations

   This document uses several registries that were originally created in
   [TLS1.1].  IANA has updated these to reference this document.  The
   registries and their allocation policies (unchanged from [TLS1.1])
   are listed below.






Dierks & Rescorla           Standards Track                    [Page 65]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   -  TLS ClientCertificateType Identifiers Registry: Future values in
      the range 0-63 (decimal) inclusive are assigned via Standards
      Action [RFC2434].  Values in the range 64-223 (decimal) inclusive
      are assigned via Specification Required [RFC2434].  Values from
      224-255 (decimal) inclusive are reserved for Private Use
      [RFC2434].

   -  TLS Cipher Suite Registry: Future values with the first byte in
      the range 0-191 (decimal) inclusive are assigned via Standards
      Action [RFC2434].  Values with the first byte in the range 192-254
      (decimal) are assigned via Specification Required [RFC2434].
      Values with the first byte 255 (decimal) are reserved for Private
      Use [RFC2434].

   -  This document defines several new HMAC-SHA256-based cipher suites,
      whose values (in Appendix A.5) have been allocated from the TLS
      Cipher Suite registry.

   -  TLS ContentType Registry: Future values are allocated via
      Standards Action [RFC2434].

   -  TLS Alert Registry: Future values are allocated via Standards
      Action [RFC2434].

   -  TLS HandshakeType Registry: Future values are allocated via
      Standards Action [RFC2434].

   This document also uses a registry originally created in [RFC4366].
   IANA has updated it to reference this document.  The registry and its
   allocation policy (unchanged from [RFC4366]) is listed below:

   -  TLS ExtensionType Registry: Future values are allocated via IETF
      Consensus [RFC2434].  IANA has updated this registry to include
      the signature_algorithms extension and its corresponding value
      (see Section 7.4.1.4).

   In addition, this document defines two new registries to be
   maintained by IANA:

   -  TLS SignatureAlgorithm Registry: The registry has been initially
      populated with the values described in Section 7.4.1.4.1.  Future
      values in the range 0-63 (decimal) inclusive are assigned via
      Standards Action [RFC2434].  Values in the range 64-223 (decimal)
      inclusive are assigned via Specification Required [RFC2434].
      Values from 224-255 (decimal) inclusive are reserved for Private
      Use [RFC2434].





Dierks & Rescorla           Standards Track                    [Page 66]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   -  TLS HashAlgorithm Registry: The registry has been initially
      populated with the values described in Section 7.4.1.4.1.  Future
      values in the range 0-63 (decimal) inclusive are assigned via
      Standards Action [RFC2434].  Values in the range 64-223 (decimal)
      inclusive are assigned via Specification Required [RFC2434].
      Values from 224-255 (decimal) inclusive are reserved for Private
      Use [RFC2434].

      This document also uses the TLS Compression Method Identifiers
      Registry, defined in [RFC3749].  IANA has allocated value 0 for
      the "null" compression method.








































Dierks & Rescorla           Standards Track                    [Page 67]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


Appendix A.  Protocol Data Structures and Constant Values

   This section describes protocol types and constants.

A.1.  Record Layer

   struct {
       uint8 major;
       uint8 minor;
   } ProtocolVersion;

   ProtocolVersion version = { 3, 3 };     /* TLS v1.2*/

   enum {
       change_cipher_spec(20), alert(21), handshake(22),
       application_data(23), (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSCompressed.length];
   } TLSCompressed;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       select (SecurityParameters.cipher_type) {
           case stream: GenericStreamCipher;
           case block:  GenericBlockCipher;
           case aead:   GenericAEADCipher;
       } fragment;
   } TLSCiphertext;

   stream-ciphered struct {
       opaque content[TLSCompressed.length];
       opaque MAC[SecurityParameters.mac_length];
   } GenericStreamCipher;




Dierks & Rescorla           Standards Track                    [Page 68]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   struct {
       opaque IV[SecurityParameters.record_iv_length];
       block-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[SecurityParameters.mac_length];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       };
   } GenericBlockCipher;

   struct {
      opaque nonce_explicit[SecurityParameters.record_iv_length];
      aead-ciphered struct {
          opaque content[TLSCompressed.length];
      };
   } GenericAEADCipher;

A.2.  Change Cipher Specs Message

   struct {
       enum { change_cipher_spec(1), (255) } type;
   } ChangeCipherSpec;

A.3.  Alert Messages

   enum { warning(1), fatal(2), (255) } AlertLevel;

   enum {
       close_notify(0),
       unexpected_message(10),
       bad_record_mac(20),
       decryption_failed_RESERVED(21),
       record_overflow(22),
       decompression_failure(30),
       handshake_failure(40),
       no_certificate_RESERVED(41),
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),
       unknown_ca(48),
       access_denied(49),
       decode_error(50),
       decrypt_error(51),
       export_restriction_RESERVED(60),
       protocol_version(70),



Dierks & Rescorla           Standards Track                    [Page 69]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


       insufficient_security(71),
       internal_error(80),
       user_canceled(90),
       no_renegotiation(100),
       unsupported_extension(110),           /* new */
       (255)
   } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;

A.4.  Handshake Protocol

   enum {
       hello_request(0), client_hello(1), server_hello(2),
       certificate(11), server_key_exchange (12),
       certificate_request(13), server_hello_done(14),
       certificate_verify(15), client_key_exchange(16),
       finished(20)
       (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;
       uint24 length;
       select (HandshakeType) {
           case hello_request:       HelloRequest;
           case client_hello:        ClientHello;
           case server_hello:        ServerHello;
           case certificate:         Certificate;
           case server_key_exchange: ServerKeyExchange;
           case certificate_request: CertificateRequest;
           case server_hello_done:   ServerHelloDone;
           case certificate_verify:  CertificateVerify;
           case client_key_exchange: ClientKeyExchange;
           case finished:            Finished;
       } body;
   } Handshake;











Dierks & Rescorla           Standards Track                    [Page 70]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


A.4.1.  Hello Messages

   struct { } HelloRequest;

   struct {
       uint32 gmt_unix_time;
       opaque random_bytes[28];
   } Random;

   opaque SessionID<0..32>;

   uint8 CipherSuite[2];

   enum { null(0), (255) } CompressionMethod;

   struct {
       ProtocolVersion client_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suites<2..2^16-2>;
       CompressionMethod compression_methods<1..2^8-1>;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions<0..2^16-1>;
       };
   } ClientHello;

   struct {
       ProtocolVersion server_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suite;
       CompressionMethod compression_method;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions<0..2^16-1>;
       };
   } ServerHello;

   struct {
       ExtensionType extension_type;
       opaque extension_data<0..2^16-1>;
   } Extension;




Dierks & Rescorla           Standards Track                    [Page 71]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   enum {
       signature_algorithms(13), (65535)
   } ExtensionType;

   enum{
       none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
       sha512(6), (255)
   } HashAlgorithm;
   enum {
      anonymous(0), rsa(1), dsa(2), ecdsa(3), (255)
   } SignatureAlgorithm;

   struct {
         HashAlgorithm hash;
         SignatureAlgorithm signature;
   } SignatureAndHashAlgorithm;

   SignatureAndHashAlgorithm
    supported_signature_algorithms<2..2^16-1>;

A.4.2.  Server Authentication and Key Exchange Messages

   opaque ASN.1Cert<2^24-1>;

   struct {
       ASN.1Cert certificate_list<0..2^24-1>;
   } Certificate;

   enum { dhe_dss, dhe_rsa, dh_anon, rsa,dh_dss, dh_rsa
          /* may be extended, e.g., for ECDH -- see [TLSECC] */
        } KeyExchangeAlgorithm;

   struct {
       opaque dh_p<1..2^16-1>;
       opaque dh_g<1..2^16-1>;
       opaque dh_Ys<1..2^16-1>;
   } ServerDHParams;     /* Ephemeral DH parameters */














Dierks & Rescorla           Standards Track                    [Page 72]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   struct {
       select (KeyExchangeAlgorithm) {
           case dh_anon:
               ServerDHParams params;
           case dhe_dss:
           case dhe_rsa:
               ServerDHParams params;
               digitally-signed struct {
                   opaque client_random[32];
                   opaque server_random[32];
                   ServerDHParams params;
               } signed_params;
           case rsa:
           case dh_dss:
           case dh_rsa:
               struct {} ;
              /* message is omitted for rsa, dh_dss, and dh_rsa */
           /* may be extended, e.g., for ECDH -- see [TLSECC] */
   } ServerKeyExchange;

   enum {
       rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
       rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
       fortezza_dms_RESERVED(20),
       (255)
   } ClientCertificateType;

   opaque DistinguishedName<1..2^16-1>;

   struct {
       ClientCertificateType certificate_types<1..2^8-1>;
       DistinguishedName certificate_authorities<0..2^16-1>;
   } CertificateRequest;

   struct { } ServerHelloDone;
















Dierks & Rescorla           Standards Track                    [Page 73]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


A.4.3.  Client Authentication and Key Exchange Messages

   struct {
       select (KeyExchangeAlgorithm) {
           case rsa:
               EncryptedPreMasterSecret;
           case dhe_dss:
           case dhe_rsa:
           case dh_dss:
           case dh_rsa:
           case dh_anon:
               ClientDiffieHellmanPublic;
       } exchange_keys;
   } ClientKeyExchange;

   struct {
       ProtocolVersion client_version;
       opaque random[46];
   } PreMasterSecret;

   struct {
       public-key-encrypted PreMasterSecret pre_master_secret;
   } EncryptedPreMasterSecret;

   enum { implicit, explicit } PublicValueEncoding;

   struct {
       select (PublicValueEncoding) {
           case implicit: struct {};
           case explicit: opaque DH_Yc<1..2^16-1>;
       } dh_public;
   } ClientDiffieHellmanPublic;

   struct {
        digitally-signed struct {
            opaque handshake_messages[handshake_messages_length];
        }
   } CertificateVerify;

A.4.4.  Handshake Finalization Message

   struct {
       opaque verify_data[verify_data_length];
   } Finished;







Dierks & Rescorla           Standards Track                    [Page 74]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


A.5.  The Cipher Suite

   The following values define the cipher suite codes used in the
   ClientHello and ServerHello messages.

   A cipher suite defines a cipher specification supported in TLS
   Version 1.2.

   TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a
   TLS connection during the first handshake on that channel, but MUST
   NOT be negotiated, as it provides no more protection than an
   unsecured connection.

      CipherSuite TLS_NULL_WITH_NULL_NULL               = { 0x00,0x00 };

   The following CipherSuite definitions require that the server provide
   an RSA certificate that can be used for key exchange.  The server may
   request any signature-capable certificate in the certificate request
   message.

      CipherSuite TLS_RSA_WITH_NULL_MD5                 = { 0x00,0x01 };
      CipherSuite TLS_RSA_WITH_NULL_SHA                 = { 0x00,0x02 };
      CipherSuite TLS_RSA_WITH_NULL_SHA256              = { 0x00,0x3B };
      CipherSuite TLS_RSA_WITH_RC4_128_MD5              = { 0x00,0x04 };
      CipherSuite TLS_RSA_WITH_RC4_128_SHA              = { 0x00,0x05 };
      CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA         = { 0x00,0x0A };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA          = { 0x00,0x2F };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA          = { 0x00,0x35 };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256       = { 0x00,0x3C };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256       = { 0x00,0x3D };

   The following cipher suite definitions are used for server-
   authenticated (and optionally client-authenticated) Diffie-Hellman.
   DH denotes cipher suites in which the server's certificate contains
   the Diffie-Hellman parameters signed by the certificate authority
   (CA).  DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman
   parameters are signed by a signature-capable certificate, which has
   been signed by the CA.  The signing algorithm used by the server is
   specified after the DHE component of the CipherSuite name.  The
   server can request any signature-capable certificate from the client
   for client authentication, or it may request a Diffie-Hellman
   certificate.  Any Diffie-Hellman certificate provided by the client
   must use the parameters (group and generator) described by the
   server.







Dierks & Rescorla           Standards Track                    [Page 75]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x0D };
      CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x10 };
      CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x13 };
      CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x16 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA       = { 0x00,0x30 };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA       = { 0x00,0x31 };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA      = { 0x00,0x32 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA      = { 0x00,0x33 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA       = { 0x00,0x36 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA       = { 0x00,0x37 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA      = { 0x00,0x38 };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA      = { 0x00,0x39 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256    = { 0x00,0x3E };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256    = { 0x00,0x3F };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256   = { 0x00,0x40 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256   = { 0x00,0x67 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256    = { 0x00,0x68 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256    = { 0x00,0x69 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256   = { 0x00,0x6A };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256   = { 0x00,0x6B };

   The following cipher suites are used for completely anonymous
   Diffie-Hellman communications in which neither party is
   authenticated.  Note that this mode is vulnerable to man-in-the-
   middle attacks.  Using this mode therefore is of limited use: These
   cipher suites MUST NOT be used by TLS 1.2 implementations unless the
   application layer has specifically requested to allow anonymous key
   exchange.  (Anonymous key exchange may sometimes be acceptable, for
   example, to support opportunistic encryption when no set-up for
   authentication is in place, or when TLS is used as part of more
   complex security protocols that have other means to ensure
   authentication.)

      CipherSuite TLS_DH_anon_WITH_RC4_128_MD5          = { 0x00,0x18 };
      CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x1B };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA      = { 0x00,0x34 };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA      = { 0x00,0x3A };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256   = { 0x00,0x6C };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256   = { 0x00,0x6D };

   Note that using non-anonymous key exchange without actually verifying
   the key exchange is essentially equivalent to anonymous key exchange,
   and the same precautions apply.  While non-anonymous key exchange
   will generally involve a higher computational and communicational
   cost than anonymous key exchange, it may be in the interest of
   interoperability not to disable non-anonymous key exchange when the
   application layer is allowing anonymous key exchange.




Dierks & Rescorla           Standards Track                    [Page 76]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   New cipher suite values have been assigned by IANA as described in
   Section 12.

   Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are
   reserved to avoid collision with Fortezza-based cipher suites in
   SSL 3.

A.6.  The Security Parameters

   These security parameters are determined by the TLS Handshake
   Protocol and provided as parameters to the TLS record layer in order
   to initialize a connection state.  SecurityParameters includes:

   enum { null(0), (255) } CompressionMethod;

   enum { server, client } ConnectionEnd;

   enum { tls_prf_sha256 } PRFAlgorithm;

   enum { null, rc4, 3des, aes } BulkCipherAlgorithm;

   enum { stream, block, aead } CipherType;

   enum { null, hmac_md5, hmac_sha1, hmac_sha256, hmac_sha384,
     hmac_sha512} MACAlgorithm;

   /* Other values may be added to the algorithms specified in
   CompressionMethod, PRFAlgorithm, BulkCipherAlgorithm, and
   MACAlgorithm. */

   struct {
       ConnectionEnd          entity;
       PRFAlgorithm           prf_algorithm;
       BulkCipherAlgorithm    bulk_cipher_algorithm;
       CipherType             cipher_type;
       uint8                  enc_key_length;
       uint8                  block_length;
       uint8                  fixed_iv_length;
       uint8                  record_iv_length;
       MACAlgorithm           mac_algorithm;
       uint8                  mac_length;
       uint8                  mac_key_length;
       CompressionMethod      compression_algorithm;
       opaque                 master_secret[48];
       opaque                 client_random[32];
       opaque                 server_random[32];
   } SecurityParameters;




Dierks & Rescorla           Standards Track                    [Page 77]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


A.7.  Changes to RFC 4492

   RFC 4492 [TLSECC] adds Elliptic Curve cipher suites to TLS.  This
   document changes some of the structures used in that document.  This
   section details the required changes for implementors of both RFC
   4492 and TLS 1.2.  Implementors of TLS 1.2 who are not implementing
   RFC 4492 do not need to read this section.

   This document adds a "signature_algorithm" field to the digitally-
   signed element in order to identify the signature and digest
   algorithms used to create a signature.  This change applies to
   digital signatures formed using ECDSA as well, thus allowing ECDSA
   signatures to be used with digest algorithms other than SHA-1,
   provided such use is compatible with the certificate and any
   restrictions imposed by future revisions of [PKIX].

   As described in Sections 7.4.2 and 7.4.6, the restrictions on the
   signature algorithms used to sign certificates are no longer tied to
   the cipher suite (when used by the server) or the
   ClientCertificateType (when used by the client).  Thus, the
   restrictions on the algorithm used to sign certificates specified in
   Sections 2 and 3 of RFC 4492 are also relaxed.  As in this document,
   the restrictions on the keys in the end-entity certificate remain.

Appendix B.  Glossary

   Advanced Encryption Standard (AES)
      AES [AES] is a widely used symmetric encryption algorithm.  AES is
      a block cipher with a 128-, 192-, or 256-bit keys and a 16-byte
      block size.  TLS currently only supports the 128- and 256-bit key
      sizes.

   application protocol
      An application protocol is a protocol that normally layers
      directly on top of the transport layer (e.g., TCP/IP).  Examples
      include HTTP, TELNET, FTP, and SMTP.

   asymmetric cipher
      See public key cryptography.

   authenticated encryption with additional data (AEAD)
      A symmetric encryption algorithm that simultaneously provides
      confidentiality and message integrity.

   authentication
      Authentication is the ability of one entity to determine the
      identity of another entity.




Dierks & Rescorla           Standards Track                    [Page 78]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   block cipher
      A block cipher is an algorithm that operates on plaintext in
      groups of bits, called blocks.  64 bits was, and 128 bits is, a
      common block size.

   bulk cipher
      A symmetric encryption algorithm used to encrypt large quantities
      of data.

   cipher block chaining (CBC)
      CBC is a mode in which every plaintext block encrypted with a
      block cipher is first exclusive-ORed with the previous ciphertext
      block (or, in the case of the first block, with the initialization
      vector).  For decryption, every block is first decrypted, then
      exclusive-ORed with the previous ciphertext block (or IV).

   certificate
      As part of the X.509 protocol (a.k.a. ISO Authentication
      framework), certificates are assigned by a trusted Certificate
      Authority and provide a strong binding between a party's identity
      or some other attributes and its public key.

   client
      The application entity that initiates a TLS connection to a
      server.  This may or may not imply that the client initiated the
      underlying transport connection.  The primary operational
      difference between the server and client is that the server is
      generally authenticated, while the client is only optionally
      authenticated.

   client write key
      The key used to encrypt data written by the client.

   client write MAC key
      The secret data used to authenticate data written by the client.

   connection
      A connection is a transport (in the OSI layering model definition)
      that provides a suitable type of service.  For TLS, such
      connections are peer-to-peer relationships.  The connections are
      transient.  Every connection is associated with one session.

   Data Encryption Standard
      DES [DES] still is a very widely used symmetric encryption
      algorithm although it is considered as rather weak now.  DES is a
      block cipher with a 56-bit key and an 8-byte block size.  Note
      that in TLS, for key generation purposes, DES is treated as having
      an 8-byte key length (64 bits), but it still only provides 56 bits



Dierks & Rescorla           Standards Track                    [Page 79]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      of protection.  (The low bit of each key byte is presumed to be
      set to produce odd parity in that key byte.)  DES can also be
      operated in a mode [3DES] where three independent keys and three
      encryptions are used for each block of data; this uses 168 bits of
      key (24 bytes in the TLS key generation method) and provides the
      equivalent of 112 bits of security.

   Digital Signature Standard (DSS)
      A standard for digital signing, including the Digital Signing
      Algorithm, approved by the National Institute of Standards and
      Technology, defined in NIST FIPS PUB 186-2, "Digital Signature
      Standard", published January 2000 by the U.S. Department of
      Commerce [DSS].  A significant update [DSS-3] has been drafted and
      was published in March 2006.

   digital signatures
      Digital signatures utilize public key cryptography and one-way
      hash functions to produce a signature of the data that can be
      authenticated, and is difficult to forge or repudiate.

   handshake An initial negotiation between client and server that
      establishes the parameters of their transactions.

   Initialization Vector (IV)
      When a block cipher is used in CBC mode, the initialization vector
      is exclusive-ORed with the first plaintext block prior to
      encryption.

   Message Authentication Code (MAC)
      A Message Authentication Code is a one-way hash computed from a
      message and some secret data.  It is difficult to forge without
      knowing the secret data.  Its purpose is to detect if the message
      has been altered.

   master secret
      Secure secret data used for generating encryption keys, MAC
      secrets, and IVs.

   MD5
      MD5 [MD5] is a hashing function that converts an arbitrarily long
      data stream into a hash of fixed size (16 bytes).  Due to
      significant progress in cryptanalysis, at the time of publication
      of this document, MD5 no longer can be considered a 'secure'
      hashing function.







Dierks & Rescorla           Standards Track                    [Page 80]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   public key cryptography
      A class of cryptographic techniques employing two-key ciphers.
      Messages encrypted with the public key can only be decrypted with
      the associated private key.  Conversely, messages signed with the
      private key can be verified with the public key.

   one-way hash function
      A one-way transformation that converts an arbitrary amount of data
      into a fixed-length hash.  It is computationally hard to reverse
      the transformation or to find collisions.  MD5 and SHA are
      examples of one-way hash functions.

   RC4
      A stream cipher invented by Ron Rivest.  A compatible cipher is
      described in [SCH].

   RSA
      A very widely used public key algorithm that can be used for
      either encryption or digital signing.  [RSA]

   server
      The server is the application entity that responds to requests for
      connections from clients.  See also "client".

   session
      A TLS session is an association between a client and a server.
      Sessions are created by the handshake protocol.  Sessions define a
      set of cryptographic security parameters that can be shared among
      multiple connections.  Sessions are used to avoid the expensive
      negotiation of new security parameters for each connection.

   session identifier
      A session identifier is a value generated by a server that
      identifies a particular session.

   server write key
      The key used to encrypt data written by the server.

   server write MAC key
      The secret data used to authenticate data written by the server.

   SHA
      The Secure Hash Algorithm [SHS] is defined in FIPS PUB 180-2.  It
      produces a 20-byte output.  Note that all references to SHA
      (without a numerical suffix) actually use the modified SHA-1
      algorithm.





Dierks & Rescorla           Standards Track                    [Page 81]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   SHA-256
      The 256-bit Secure Hash Algorithm is defined in FIPS PUB 180-2.
      It produces a 32-byte output.

   SSL
      Netscape's Secure Socket Layer protocol [SSL3].  TLS is based on
      SSL Version 3.0.

   stream cipher
      An encryption algorithm that converts a key into a
      cryptographically strong keystream, which is then exclusive-ORed
      with the plaintext.

   symmetric cipher
      See bulk cipher.

   Transport Layer Security (TLS)
      This protocol; also, the Transport Layer Security working group of
      the Internet Engineering Task Force (IETF).  See "Working Group
      Information" at the end of this document (see page 99).































Dierks & Rescorla           Standards Track                    [Page 82]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


Appendix C.  Cipher Suite Definitions

Cipher Suite                            Key        Cipher         Mac
                                        Exchange

TLS_NULL_WITH_NULL_NULL                 NULL         NULL         NULL
TLS_RSA_WITH_NULL_MD5                   RSA          NULL         MD5
TLS_RSA_WITH_NULL_SHA                   RSA          NULL         SHA
TLS_RSA_WITH_NULL_SHA256                RSA          NULL         SHA256
TLS_RSA_WITH_RC4_128_MD5                RSA          RC4_128      MD5
TLS_RSA_WITH_RC4_128_SHA                RSA          RC4_128      SHA
TLS_RSA_WITH_3DES_EDE_CBC_SHA           RSA          3DES_EDE_CBC SHA
TLS_RSA_WITH_AES_128_CBC_SHA            RSA          AES_128_CBC  SHA
TLS_RSA_WITH_AES_256_CBC_SHA            RSA          AES_256_CBC  SHA
TLS_RSA_WITH_AES_128_CBC_SHA256         RSA          AES_128_CBC  SHA256
TLS_RSA_WITH_AES_256_CBC_SHA256         RSA          AES_256_CBC  SHA256
TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS       3DES_EDE_CBC SHA
TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA       3DES_EDE_CBC SHA
TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS      3DES_EDE_CBC SHA
TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA      3DES_EDE_CBC SHA
TLS_DH_anon_WITH_RC4_128_MD5            DH_anon      RC4_128      MD5
TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon      3DES_EDE_CBC SHA
TLS_DH_DSS_WITH_AES_128_CBC_SHA         DH_DSS       AES_128_CBC  SHA
TLS_DH_RSA_WITH_AES_128_CBC_SHA         DH_RSA       AES_128_CBC  SHA
TLS_DHE_DSS_WITH_AES_128_CBC_SHA        DHE_DSS      AES_128_CBC  SHA
TLS_DHE_RSA_WITH_AES_128_CBC_SHA        DHE_RSA      AES_128_CBC  SHA
TLS_DH_anon_WITH_AES_128_CBC_SHA        DH_anon      AES_128_CBC  SHA
TLS_DH_DSS_WITH_AES_256_CBC_SHA         DH_DSS       AES_256_CBC  SHA
TLS_DH_RSA_WITH_AES_256_CBC_SHA         DH_RSA       AES_256_CBC  SHA
TLS_DHE_DSS_WITH_AES_256_CBC_SHA        DHE_DSS      AES_256_CBC  SHA
TLS_DHE_RSA_WITH_AES_256_CBC_SHA        DHE_RSA      AES_256_CBC  SHA
TLS_DH_anon_WITH_AES_256_CBC_SHA        DH_anon      AES_256_CBC  SHA
TLS_DH_DSS_WITH_AES_128_CBC_SHA256      DH_DSS       AES_128_CBC  SHA256
TLS_DH_RSA_WITH_AES_128_CBC_SHA256      DH_RSA       AES_128_CBC  SHA256
TLS_DHE_DSS_WITH_AES_128_CBC_SHA256     DHE_DSS      AES_128_CBC  SHA256
TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     DHE_RSA      AES_128_CBC  SHA256
TLS_DH_anon_WITH_AES_128_CBC_SHA256     DH_anon      AES_128_CBC  SHA256
TLS_DH_DSS_WITH_AES_256_CBC_SHA256      DH_DSS       AES_256_CBC  SHA256
TLS_DH_RSA_WITH_AES_256_CBC_SHA256      DH_RSA       AES_256_CBC  SHA256
TLS_DHE_DSS_WITH_AES_256_CBC_SHA256     DHE_DSS      AES_256_CBC  SHA256
TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     DHE_RSA      AES_256_CBC  SHA256
TLS_DH_anon_WITH_AES_256_CBC_SHA256     DH_anon      AES_256_CBC  SHA256









Dierks & Rescorla           Standards Track                    [Page 83]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


                        Key      IV   Block
Cipher        Type    Material  Size  Size
------------  ------  --------  ----  -----
NULL          Stream      0       0    N/A
RC4_128       Stream     16       0    N/A
3DES_EDE_CBC  Block      24       8      8
AES_128_CBC   Block      16      16     16
AES_256_CBC   Block      32      16     16


MAC       Algorithm    mac_length  mac_key_length
--------  -----------  ----------  --------------
NULL      N/A              0             0
MD5       HMAC-MD5        16            16
SHA       HMAC-SHA1       20            20
SHA256    HMAC-SHA256     32            32

   Type
      Indicates whether this is a stream cipher or a block cipher
      running in CBC mode.

   Key Material
      The number of bytes from the key_block that are used for
      generating the write keys.

   IV Size
      The amount of data needed to be generated for the initialization
      vector.  Zero for stream ciphers; equal to the block size for
      block ciphers (this is equal to
      SecurityParameters.record_iv_length).

   Block Size
      The amount of data a block cipher enciphers in one chunk; a block
      cipher running in CBC mode can only encrypt an even multiple of
      its block size.
















Dierks & Rescorla           Standards Track                    [Page 84]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


Appendix D.  Implementation Notes

   The TLS protocol cannot prevent many common security mistakes.  This
   section provides several recommendations to assist implementors.

D.1.  Random Number Generation and Seeding

   TLS requires a cryptographically secure pseudorandom number generator
   (PRNG).  Care must be taken in designing and seeding PRNGs.  PRNGs
   based on secure hash operations, most notably SHA-1, are acceptable,
   but cannot provide more security than the size of the random number
   generator state.

   To estimate the amount of seed material being produced, add the
   number of bits of unpredictable information in each seed byte.  For
   example, keystroke timing values taken from a PC compatible's 18.2 Hz
   timer provide 1 or 2 secure bits each, even though the total size of
   the counter value is 16 bits or more.  Seeding a 128-bit PRNG would
   thus require approximately 100 such timer values.

   [RANDOM] provides guidance on the generation of random values.

D.2.  Certificates and Authentication

   Implementations are responsible for verifying the integrity of
   certificates and should generally support certificate revocation
   messages.  Certificates should always be verified to ensure proper
   signing by a trusted Certificate Authority (CA).  The selection and
   addition of trusted CAs should be done very carefully.  Users should
   be able to view information about the certificate and root CA.

D.3.  Cipher Suites

   TLS supports a range of key sizes and security levels, including some
   that provide no or minimal security.  A proper implementation will
   probably not support many cipher suites.  For instance, anonymous
   Diffie-Hellman is strongly discouraged because it cannot prevent man-
   in-the-middle attacks.  Applications should also enforce minimum and
   maximum key sizes.  For example, certificate chains containing 512-
   bit RSA keys or signatures are not appropriate for high-security
   applications.

D.4.  Implementation Pitfalls

   Implementation experience has shown that certain parts of earlier TLS
   specifications are not easy to understand, and have been a source of
   interoperability and security problems.  Many of these areas have




Dierks & Rescorla           Standards Track                    [Page 85]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   been clarified in this document, but this appendix contains a short
   list of the most important things that require special attention from
   implementors.

   TLS protocol issues:

   -  Do you correctly handle handshake messages that are fragmented to
      multiple TLS records (see Section 6.2.1)? Including corner cases
      like a ClientHello that is split to several small fragments? Do
      you fragment handshake messages that exceed the maximum fragment
      size? In particular, the certificate and certificate request
      handshake messages can be large enough to require fragmentation.

   -  Do you ignore the TLS record layer version number in all TLS
      records before ServerHello (see Appendix E.1)?

   -  Do you handle TLS extensions in ClientHello correctly, including
      omitting the extensions field completely?

   -  Do you support renegotiation, both client and server initiated?
      While renegotiation is an optional feature, supporting it is
      highly recommended.

   -  When the server has requested a client certificate, but no
      suitable certificate is available, do you correctly send an empty
      Certificate message, instead of omitting the whole message (see
      Section 7.4.6)?

   Cryptographic details:

   -  In the RSA-encrypted Premaster Secret, do you correctly send and
      verify the version number? When an error is encountered, do you
      continue the handshake to avoid the Bleichenbacher attack (see
      Section 7.4.7.1)?

   -  What countermeasures do you use to prevent timing attacks against
      RSA decryption and signing operations (see Section 7.4.7.1)?

   -  When verifying RSA signatures, do you accept both NULL and missing
      parameters (see Section 4.7)? Do you verify that the RSA padding
      doesn't have additional data after the hash value?  [FI06]

   -  When using Diffie-Hellman key exchange, do you correctly strip
      leading zero bytes from the negotiated key (see Section 8.1.2)?

   -  Does your TLS client check that the Diffie-Hellman parameters sent
      by the server are acceptable (see Section F.1.1.3)?




Dierks & Rescorla           Standards Track                    [Page 86]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   -  How do you generate unpredictable IVs for CBC mode ciphers (see
      Section 6.2.3.2)?

   -  Do you accept long CBC mode padding (up to 255 bytes; see Section
      6.2.3.2)?

   -  How do you address CBC mode timing attacks (Section 6.2.3.2)?

   -  Do you use a strong and, most importantly, properly seeded random
      number generator (see Appendix D.1) for generating the premaster
      secret (for RSA key exchange), Diffie-Hellman private values, the
      DSA "k" parameter, and other security-critical values?

Appendix E.  Backward Compatibility

E.1.  Compatibility with TLS 1.0/1.1 and SSL 3.0

   Since there are various versions of TLS (1.0, 1.1, 1.2, and any
   future versions) and SSL (2.0 and 3.0), means are needed to negotiate
   the specific protocol version to use.  The TLS protocol provides a
   built-in mechanism for version negotiation so as not to bother other
   protocol components with the complexities of version selection.

   TLS versions 1.0, 1.1, and 1.2, and SSL 3.0 are very similar, and use
   compatible ClientHello messages; thus, supporting all of them is
   relatively easy.  Similarly, servers can easily handle clients trying
   to use future versions of TLS as long as the ClientHello format
   remains compatible, and the client supports the highest protocol
   version available in the server.

   A TLS 1.2 client who wishes to negotiate with such older servers will
   send a normal TLS 1.2 ClientHello, containing { 3, 3 } (TLS 1.2) in
   ClientHello.client_version.  If the server does not support this
   version, it will respond with a ServerHello containing an older
   version number.  If the client agrees to use this version, the
   negotiation will proceed as appropriate for the negotiated protocol.

   If the version chosen by the server is not supported by the client
   (or not acceptable), the client MUST send a "protocol_version" alert
   message and close the connection.

   If a TLS server receives a ClientHello containing a version number
   greater than the highest version supported by the server, it MUST
   reply according to the highest version supported by the server.

   A TLS server can also receive a ClientHello containing a version
   number smaller than the highest supported version.  If the server
   wishes to negotiate with old clients, it will proceed as appropriate



Dierks & Rescorla           Standards Track                    [Page 87]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   for the highest version supported by the server that is not greater
   than ClientHello.client_version.  For example, if the server supports
   TLS 1.0, 1.1, and 1.2, and client_version is TLS 1.0, the server will
   proceed with a TLS 1.0 ServerHello.  If server supports (or is
   willing to use) only versions greater than client_version, it MUST
   send a "protocol_version" alert message and close the connection.

   Whenever a client already knows the highest protocol version known to
   a server (for example, when resuming a session), it SHOULD initiate
   the connection in that native protocol.

   Note: some server implementations are known to implement version
   negotiation incorrectly.  For example, there are buggy TLS 1.0
   servers that simply close the connection when the client offers a
   version newer than TLS 1.0.  Also, it is known that some servers will
   refuse the connection if any TLS extensions are included in
   ClientHello.  Interoperability with such buggy servers is a complex
   topic beyond the scope of this document, and may require multiple
   connection attempts by the client.

   Earlier versions of the TLS specification were not fully clear on
   what the record layer version number (TLSPlaintext.version) should
   contain when sending ClientHello (i.e., before it is known which
   version of the protocol will be employed).  Thus, TLS servers
   compliant with this specification MUST accept any value {03,XX} as
   the record layer version number for ClientHello.

   TLS clients that wish to negotiate with older servers MAY send any
   value {03,XX} as the record layer version number.  Typical values
   would be {03,00}, the lowest version number supported by the client,
   and the value of ClientHello.client_version.  No single value will
   guarantee interoperability with all old servers, but this is a
   complex topic beyond the scope of this document.

E.2.  Compatibility with SSL 2.0

   TLS 1.2 clients that wish to support SSL 2.0 servers MUST send
   version 2.0 CLIENT-HELLO messages defined in [SSL2].  The message
   MUST contain the same version number as would be used for ordinary
   ClientHello, and MUST encode the supported TLS cipher suites in the
   CIPHER-SPECS-DATA field as described below.

   Warning: The ability to send version 2.0 CLIENT-HELLO messages will
   be phased out with all due haste, since the newer ClientHello format
   provides better mechanisms for moving to newer versions and
   negotiating extensions.  TLS 1.2 clients SHOULD NOT support SSL 2.0.





Dierks & Rescorla           Standards Track                    [Page 88]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   However, even TLS servers that do not support SSL 2.0 MAY accept
   version 2.0 CLIENT-HELLO messages.  The message is presented below in
   sufficient detail for TLS server implementors; the true definition is
   still assumed to be [SSL2].

   For negotiation purposes, 2.0 CLIENT-HELLO is interpreted the same
   way as a ClientHello with a "null" compression method and no
   extensions.  Note that this message MUST be sent directly on the
   wire, not wrapped as a TLS record.  For the purposes of calculating
   Finished and CertificateVerify, the msg_length field is not
   considered to be a part of the handshake message.

      uint8 V2CipherSpec[3];
      struct {
          uint16 msg_length;
          uint8 msg_type;
          Version version;
          uint16 cipher_spec_length;
          uint16 session_id_length;
          uint16 challenge_length;
          V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
          opaque session_id[V2ClientHello.session_id_length];
          opaque challenge[V2ClientHello.challenge_length;
      } V2ClientHello;

   msg_length
      The highest bit MUST be 1; the remaining bits contain the length
      of the following data in bytes.

   msg_type
      This field, in conjunction with the version field, identifies a
      version 2 ClientHello message.  The value MUST be 1.

   version
      Equal to ClientHello.client_version.

   cipher_spec_length
      This field is the total length of the field cipher_specs.  It
      cannot be zero and MUST be a multiple of the V2CipherSpec length
      (3).

   session_id_length
      This field MUST have a value of zero for a client that claims to
      support TLS 1.2.







Dierks & Rescorla           Standards Track                    [Page 89]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   challenge_length
      The length in bytes of the client's challenge to the server to
      authenticate itself.  Historically, permissible values are between
      16 and 32 bytes inclusive.  When using the SSLv2 backward-
      compatible handshake the client SHOULD use a 32-byte challenge.

   cipher_specs
      This is a list of all CipherSpecs the client is willing and able
      to use.  In addition to the 2.0 cipher specs defined in [SSL2],
      this includes the TLS cipher suites normally sent in
      ClientHello.cipher_suites, with each cipher suite prefixed by a
      zero byte.  For example, the TLS cipher suite {0x00,0x0A} would be
      sent as {0x00,0x00,0x0A}.

   session_id
      This field MUST be empty.

   challenge
      Corresponds to ClientHello.random.  If the challenge length is
      less than 32, the TLS server will pad the data with leading (note:
      not trailing) zero bytes to make it 32 bytes long.

   Note: Requests to resume a TLS session MUST use a TLS client hello.

E.3.  Avoiding Man-in-the-Middle Version Rollback

   When TLS clients fall back to Version 2.0 compatibility mode, they
   MUST use special PKCS#1 block formatting.  This is done so that TLS
   servers will reject Version 2.0 sessions with TLS-capable clients.

   When a client negotiates SSL 2.0 but also supports TLS, it MUST set
   the right-hand (least-significant) 8 random bytes of the PKCS padding
   (not including the terminal null of the padding) for the RSA
   encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY
   to 0x03 (the other padding bytes are random).

   When a TLS-capable server negotiates SSL 2.0 it SHOULD, after
   decrypting the ENCRYPTED-KEY-DATA field, check that these 8 padding
   bytes are 0x03.  If they are not, the server SHOULD generate a random
   value for SECRET-KEY-DATA, and continue the handshake (which will
   eventually fail since the keys will not match).  Note that reporting
   the error situation to the client could make the server vulnerable to
   attacks described in [BLEI].








Dierks & Rescorla           Standards Track                    [Page 90]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


Appendix F.  Security Analysis

   The TLS protocol is designed to establish a secure connection between
   a client and a server communicating over an insecure channel.  This
   document makes several traditional assumptions, including that
   attackers have substantial computational resources and cannot obtain
   secret information from sources outside the protocol.  Attackers are
   assumed to have the ability to capture, modify, delete, replay, and
   otherwise tamper with messages sent over the communication channel.
   This appendix outlines how TLS has been designed to resist a variety
   of attacks.

F.1.  Handshake Protocol

   The handshake protocol is responsible for selecting a cipher spec and
   generating a master secret, which together comprise the primary
   cryptographic parameters associated with a secure session.  The
   handshake protocol can also optionally authenticate parties who have
   certificates signed by a trusted certificate authority.

F.1.1.  Authentication and Key Exchange

   TLS supports three authentication modes: authentication of both
   parties, server authentication with an unauthenticated client, and
   total anonymity.  Whenever the server is authenticated, the channel
   is secure against man-in-the-middle attacks, but completely anonymous
   sessions are inherently vulnerable to such attacks.  Anonymous
   servers cannot authenticate clients.  If the server is authenticated,
   its certificate message must provide a valid certificate chain
   leading to an acceptable certificate authority.  Similarly,
   authenticated clients must supply an acceptable certificate to the
   server.  Each party is responsible for verifying that the other's
   certificate is valid and has not expired or been revoked.

   The general goal of the key exchange process is to create a
   pre_master_secret known to the communicating parties and not to
   attackers.  The pre_master_secret will be used to generate the
   master_secret (see Section 8.1).  The master_secret is required to
   generate the Finished messages, encryption keys, and MAC keys (see
   Sections 7.4.9 and 6.3).  By sending a correct Finished message,
   parties thus prove that they know the correct pre_master_secret.

F.1.1.1.  Anonymous Key Exchange

   Completely anonymous sessions can be established using Diffie-Hellman
   for key exchange.  The server's public parameters are contained in
   the server key exchange message, and the client's are sent in the




Dierks & Rescorla           Standards Track                    [Page 91]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   client key exchange message.  Eavesdroppers who do not know the
   private values should not be able to find the Diffie-Hellman result
   (i.e., the pre_master_secret).

   Warning: Completely anonymous connections only provide protection
   against passive eavesdropping.  Unless an independent tamper-proof
   channel is used to verify that the Finished messages were not
   replaced by an attacker, server authentication is required in
   environments where active man-in-the-middle attacks are a concern.

F.1.1.2.  RSA Key Exchange and Authentication

   With RSA, key exchange and server authentication are combined.  The
   public key is contained in the server's certificate.  Note that
   compromise of the server's static RSA key results in a loss of
   confidentiality for all sessions protected under that static key.
   TLS users desiring Perfect Forward Secrecy should use DHE cipher
   suites.  The damage done by exposure of a private key can be limited
   by changing one's private key (and certificate) frequently.

   After verifying the server's certificate, the client encrypts a
   pre_master_secret with the server's public key.  By successfully
   decoding the pre_master_secret and producing a correct Finished
   message, the server demonstrates that it knows the private key
   corresponding to the server certificate.

   When RSA is used for key exchange, clients are authenticated using
   the certificate verify message (see Section 7.4.8).  The client signs
   a value derived from all preceding handshake messages.  These
   handshake messages include the server certificate, which binds the
   signature to the server, and ServerHello.random, which binds the
   signature to the current handshake process.

F.1.1.3.  Diffie-Hellman Key Exchange with Authentication

   When Diffie-Hellman key exchange is used, the server can either
   supply a certificate containing fixed Diffie-Hellman parameters or
   use the server key exchange message to send a set of temporary
   Diffie-Hellman parameters signed with a DSA or RSA certificate.
   Temporary parameters are hashed with the hello.random values before
   signing to ensure that attackers do not replay old parameters.  In
   either case, the client can verify the certificate or signature to
   ensure that the parameters belong to the server.

   If the client has a certificate containing fixed Diffie-Hellman
   parameters, its certificate contains the information required to
   complete the key exchange.  Note that in this case the client and
   server will generate the same Diffie-Hellman result (i.e.,



Dierks & Rescorla           Standards Track                    [Page 92]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   pre_master_secret) every time they communicate.  To prevent the
   pre_master_secret from staying in memory any longer than necessary,
   it should be converted into the master_secret as soon as possible.
   Client Diffie-Hellman parameters must be compatible with those
   supplied by the server for the key exchange to work.

   If the client has a standard DSA or RSA certificate or is
   unauthenticated, it sends a set of temporary parameters to the server
   in the client key exchange message, then optionally uses a
   certificate verify message to authenticate itself.

   If the same DH keypair is to be used for multiple handshakes, either
   because the client or server has a certificate containing a fixed DH
   keypair or because the server is reusing DH keys, care must be taken
   to prevent small subgroup attacks.  Implementations SHOULD follow the
   guidelines found in [SUBGROUP].

   Small subgroup attacks are most easily avoided by using one of the
   DHE cipher suites and generating a fresh DH private key (X) for each
   handshake.  If a suitable base (such as 2) is chosen, g^X mod p can
   be computed very quickly; therefore, the performance cost is
   minimized.  Additionally, using a fresh key for each handshake
   provides Perfect Forward Secrecy.  Implementations SHOULD generate a
   new X for each handshake when using DHE cipher suites.

   Because TLS allows the server to provide arbitrary DH groups, the
   client should verify that the DH group is of suitable size as defined
   by local policy.  The client SHOULD also verify that the DH public
   exponent appears to be of adequate size.  [KEYSIZ] provides a useful
   guide to the strength of various group sizes.  The server MAY choose
   to assist the client by providing a known group, such as those
   defined in [IKEALG] or [MODP].  These can be verified by simple
   comparison.

F.1.2.  Version Rollback Attacks

   Because TLS includes substantial improvements over SSL Version 2.0,
   attackers may try to make TLS-capable clients and servers fall back
   to Version 2.0.  This attack can occur if (and only if) two TLS-
   capable parties use an SSL 2.0 handshake.

   Although the solution using non-random PKCS #1 block type 2 message
   padding is inelegant, it provides a reasonably secure way for Version
   3.0 servers to detect the attack.  This solution is not secure
   against attackers who can brute-force the key and substitute a new
   ENCRYPTED-KEY-DATA message containing the same key (but with normal
   padding) before the application-specified wait threshold has expired.
   Altering the padding of the least-significant 8 bytes of the PKCS



Dierks & Rescorla           Standards Track                    [Page 93]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   padding does not impact security for the size of the signed hashes
   and RSA key lengths used in the protocol, since this is essentially
   equivalent to increasing the input block size by 8 bytes.

F.1.3.  Detecting Attacks Against the Handshake Protocol

   An attacker might try to influence the handshake exchange to make the
   parties select different encryption algorithms than they would
   normally choose.

   For this attack, an attacker must actively change one or more
   handshake messages.  If this occurs, the client and server will
   compute different values for the handshake message hashes.  As a
   result, the parties will not accept each others' Finished messages.
   Without the master_secret, the attacker cannot repair the Finished
   messages, so the attack will be discovered.

F.1.4.  Resuming Sessions

   When a connection is established by resuming a session, new
   ClientHello.random and ServerHello.random values are hashed with the
   session's master_secret.  Provided that the master_secret has not
   been compromised and that the secure hash operations used to produce
   the encryption keys and MAC keys are secure, the connection should be
   secure and effectively independent from previous connections.
   Attackers cannot use known encryption keys or MAC secrets to
   compromise the master_secret without breaking the secure hash
   operations.

   Sessions cannot be resumed unless both the client and server agree.
   If either party suspects that the session may have been compromised,
   or that certificates may have expired or been revoked, it should
   force a full handshake.  An upper limit of 24 hours is suggested for
   session ID lifetimes, since an attacker who obtains a master_secret
   may be able to impersonate the compromised party until the
   corresponding session ID is retired.  Applications that may be run in
   relatively insecure environments should not write session IDs to
   stable storage.

F.2.  Protecting Application Data

   The master_secret is hashed with the ClientHello.random and
   ServerHello.random to produce unique data encryption keys and MAC
   secrets for each connection.

   Outgoing data is protected with a MAC before transmission.  To
   prevent message replay or modification attacks, the MAC is computed
   from the MAC key, the sequence number, the message length, the



Dierks & Rescorla           Standards Track                    [Page 94]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   message contents, and two fixed character strings.  The message type
   field is necessary to ensure that messages intended for one TLS
   record layer client are not redirected to another.  The sequence
   number ensures that attempts to delete or reorder messages will be
   detected.  Since sequence numbers are 64 bits long, they should never
   overflow.  Messages from one party cannot be inserted into the
   other's output, since they use independent MAC keys.  Similarly, the
   server write and client write keys are independent, so stream cipher
   keys are used only once.

   If an attacker does break an encryption key, all messages encrypted
   with it can be read.  Similarly, compromise of a MAC key can make
   message-modification attacks possible.  Because MACs are also
   encrypted, message-alteration attacks generally require breaking the
   encryption algorithm as well as the MAC.

   Note: MAC keys may be larger than encryption keys, so messages can
   remain tamper resistant even if encryption keys are broken.

F.3.  Explicit IVs

   [CBCATT] describes a chosen plaintext attack on TLS that depends on
   knowing the IV for a record.  Previous versions of TLS [TLS1.0] used
   the CBC residue of the previous record as the IV and therefore
   enabled this attack.  This version uses an explicit IV in order to
   protect against this attack.

F.4.  Security of Composite Cipher Modes

   TLS secures transmitted application data via the use of symmetric
   encryption and authentication functions defined in the negotiated
   cipher suite.  The objective is to protect both the integrity and
   confidentiality of the transmitted data from malicious actions by
   active attackers in the network.  It turns out that the order in
   which encryption and authentication functions are applied to the data
   plays an important role for achieving this goal [ENCAUTH].

   The most robust method, called encrypt-then-authenticate, first
   applies encryption to the data and then applies a MAC to the
   ciphertext.  This method ensures that the integrity and
   confidentiality goals are obtained with ANY pair of encryption and
   MAC functions, provided that the former is secure against chosen
   plaintext attacks and that the MAC is secure against chosen-message
   attacks.  TLS uses another method, called authenticate-then-encrypt,
   in which first a MAC is computed on the plaintext and then the
   concatenation of plaintext and MAC is encrypted.  This method has
   been proven secure for CERTAIN combinations of encryption functions
   and MAC functions, but it is not guaranteed to be secure in general.



Dierks & Rescorla           Standards Track                    [Page 95]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   In particular, it has been shown that there exist perfectly secure
   encryption functions (secure even in the information-theoretic sense)
   that combined with any secure MAC function, fail to provide the
   confidentiality goal against an active attack.  Therefore, new cipher
   suites and operation modes adopted into TLS need to be analyzed under
   the authenticate-then-encrypt method to verify that they achieve the
   stated integrity and confidentiality goals.

   Currently, the security of the authenticate-then-encrypt method has
   been proven for some important cases.  One is the case of stream
   ciphers in which a computationally unpredictable pad of the length of
   the message, plus the length of the MAC tag, is produced using a
   pseudorandom generator and this pad is exclusive-ORed with the
   concatenation of plaintext and MAC tag.  The other is the case of CBC
   mode using a secure block cipher.  In this case, security can be
   shown if one applies one CBC encryption pass to the concatenation of
   plaintext and MAC and uses a new, independent, and unpredictable IV
   for each new pair of plaintext and MAC.  In versions of TLS prior to
   1.1, CBC mode was used properly EXCEPT that it used a predictable IV
   in the form of the last block of the previous ciphertext.  This made
   TLS open to chosen plaintext attacks.  This version of the protocol
   is immune to those attacks.  For exact details in the encryption
   modes proven secure, see [ENCAUTH].

F.5.  Denial of Service

   TLS is susceptible to a number of denial-of-service (DoS) attacks.
   In particular, an attacker who initiates a large number of TCP
   connections can cause a server to consume large amounts of CPU for
   doing RSA decryption.  However, because TLS is generally used over
   TCP, it is difficult for the attacker to hide his point of origin if
   proper TCP SYN randomization is used [SEQNUM] by the TCP stack.

   Because TLS runs over TCP, it is also susceptible to a number of DoS
   attacks on individual connections.  In particular, attackers can
   forge RSTs, thereby terminating connections, or forge partial TLS
   records, thereby causing the connection to stall.  These attacks
   cannot in general be defended against by a TCP-using protocol.
   Implementors or users who are concerned with this class of attack
   should use IPsec AH [AH] or ESP [ESP].

F.6.  Final Notes

   For TLS to be able to provide a secure connection, both the client
   and server systems, keys, and applications must be secure.  In
   addition, the implementation must be free of security errors.





Dierks & Rescorla           Standards Track                    [Page 96]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The system is only as strong as the weakest key exchange and
   authentication algorithm supported, and only trustworthy
   cryptographic functions should be used.  Short public keys and
   anonymous servers should be used with great caution.  Implementations
   and users must be careful when deciding which certificates and
   certificate authorities are acceptable; a dishonest certificate
   authority can do tremendous damage.

Normative References

   [AES]      National Institute of Standards and Technology,
              "Specification for the Advanced Encryption Standard (AES)"
              FIPS 197.  November 26, 2001.

   [3DES]     National Institute of Standards and Technology,
              "Recommendation for the Triple Data Encryption Algorithm
              (TDEA) Block Cipher", NIST Special Publication 800-67, May
              2004.

   [DSS]      NIST FIPS PUB 186-2, "Digital Signature Standard",
              National Institute of Standards and Technology, U.S.
              Department of Commerce, 2000.

   [HMAC]     Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104, February
              1997.

   [MD5]      Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321,
              April 1992.

   [PKCS1]    Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications
              Version 2.1", RFC 3447, February 2003.

   [PKIX]     Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
              X.509 Public Key Infrastructure Certificate and
              Certificate Revocation List (CRL) Profile", RFC 3280,
              April 2002.

   [SCH]      B. Schneier. "Applied Cryptography: Protocols, Algorithms,
              and Source Code in C, 2nd ed.", Published by John Wiley &
              Sons, Inc. 1996.

   [SHS]      NIST FIPS PUB 180-2, "Secure Hash Standard", National
              Institute of Standards and Technology, U.S. Department of
              Commerce, August 2002.





Dierks & Rescorla           Standards Track                    [Page 97]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   [REQ]      Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2434]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 2434,
              October 1998.

   [X680]     ITU-T Recommendation X.680 (2002) | ISO/IEC 8824-1:2002,
              Information technology - Abstract Syntax Notation One
              (ASN.1): Specification of basic notation.

   [X690]     ITU-T Recommendation X.690 (2002) | ISO/IEC 8825-1:2002,
              Information technology - ASN.1 encoding Rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER).

Informative References

   [AEAD]     McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", RFC 5116, January 2008.

   [AH]       Kent, S., "IP Authentication Header", RFC 4302, December
              2005.

   [BLEI]     Bleichenbacher D., "Chosen Ciphertext Attacks against
              Protocols Based on RSA Encryption Standard PKCS #1" in
              Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462,
              pages:  1-12, 1998.

   [CBCATT]   Moeller, B., "Security of CBC Ciphersuites in SSL/TLS:
              Problems and Countermeasures",
              http://www.openssl.org/~bodo/tls-cbc.txt.

   [CBCTIME]  Canvel, B., Hiltgen, A., Vaudenay, S., and M. Vuagnoux,
              "Password Interception in a SSL/TLS Channel", Advances in
              Cryptology -- CRYPTO 2003, LNCS vol. 2729, 2003.

   [CCM]      "NIST Special Publication 800-38C: The CCM Mode for
              Authentication and Confidentiality",
              http://csrc.nist.gov/publications/nistpubs/800-38C/
              SP800-38C.pdf

   [DES]      National Institute of Standards and Technology, "Data
              Encryption Standard (DES)", FIPS PUB 46-3, October 1999.






Dierks & Rescorla           Standards Track                    [Page 98]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   [DSS-3]    NIST FIPS PUB 186-3 Draft, "Digital Signature Standard",
              National Institute of Standards and Technology, U.S.
              Department of Commerce, 2006.

   [ECDSA]    American National Standards Institute, "Public Key
              Cryptography for the Financial Services Industry: The
              Elliptic Curve Digital Signature Algorithm (ECDSA)", ANS
              X9.62-2005, November 2005.

   [ENCAUTH]  Krawczyk, H., "The Order of Encryption and Authentication
              for Protecting Communications (Or: How Secure is SSL?)",
              Crypto 2001.

   [ESP]      Kent, S., "IP Encapsulating Security Payload (ESP)", RFC
              4303, December 2005.

   [FI06]     Hal Finney, "Bleichenbacher's RSA signature forgery based
              on implementation error", ietf-openpgp@imc.org mailing
              list, 27 August 2006, http://www.imc.org/ietf-openpgp/
              mail-archive/msg14307.html.

   [GCM]      Dworkin, M., NIST Special Publication 800-38D,
              "Recommendation for Block Cipher Modes of Operation:
              Galois/Counter Mode (GCM) and GMAC", November 2007.

   [IKEALG]   Schiller, J., "Cryptographic Algorithms for Use in the
              Internet Key Exchange Version 2 (IKEv2)", RFC 4307,
              December 2005.

   [KEYSIZ]   Orman, H. and P. Hoffman, "Determining Strengths For
              Public Keys Used For Exchanging Symmetric Keys", BCP 86,
              RFC 3766, April 2004.

   [KPR03]    Klima, V., Pokorny, O., Rosa, T., "Attacking RSA-based
              Sessions in SSL/TLS", http://eprint.iacr.org/2003/052/,
              March 2003.

   [MODP]     Kivinen, T. and M. Kojo, "More Modular Exponential (MODP)
              Diffie-Hellman groups for Internet Key Exchange (IKE)",
              RFC 3526, May 2003.

   [PKCS6]    RSA Laboratories, "PKCS #6: RSA Extended Certificate
              Syntax Standard", version 1.5, November 1993.

   [PKCS7]    RSA Laboratories, "PKCS #7: RSA Cryptographic Message
              Syntax Standard", version 1.5, November 1993.





Dierks & Rescorla           Standards Track                    [Page 99]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   [RANDOM]   Eastlake, D., 3rd, Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              June 2005.

   [RFC3749]  Hollenbeck, S., "Transport Layer Security Protocol
              Compression Methods", RFC 3749, May 2004.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, April 2006.

   [RSA]      R. Rivest, A. Shamir, and L. M. Adleman, "A Method for
              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM, v. 21, n. 2,
              Feb 1978, pp. 120-126.

   [SEQNUM]   Bellovin, S., "Defending Against Sequence Number Attacks",
              RFC 1948, May 1996.

   [SSL2]     Hickman, Kipp, "The SSL Protocol", Netscape Communications
              Corp., Feb 9, 1995.

   [SSL3]     A. Freier, P. Karlton, and P. Kocher, "The SSL 3.0
              Protocol", Netscape Communications Corp., Nov 18, 1996.

   [SUBGROUP] Zuccherato, R., "Methods for Avoiding the "Small-Subgroup"
              Attacks on the Diffie-Hellman Key Agreement Method for
              S/MIME", RFC 2785, March 2000.

   [TCP]      Postel, J., "Transmission Control Protocol", STD 7, RFC
              793, September 1981.

   [TIMING]   Boneh, D., Brumley, D., "Remote timing attacks are
              practical", USENIX Security Symposium 2003.

   [TLSAES]   Chown, P., "Advanced Encryption Standard (AES)
              Ciphersuites for Transport Layer Security (TLS)", RFC
              3268, June 2002.

   [TLSECC]   Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", RFC 4492, May 2006.

   [TLSEXT]   Eastlake, D., 3rd, "Transport Layer Security (TLS)
              Extensions:  Extension Definitions", Work in Progress,
              February 2008.





Dierks & Rescorla           Standards Track                   [Page 100]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   [TLSPGP]   Mavrogiannopoulos, N., "Using OpenPGP Keys for Transport
              Layer Security (TLS) Authentication", RFC 5081, November
              2007.

   [TLSPSK]   Eronen, P., Ed., and H. Tschofenig, Ed., "Pre-Shared Key
              Ciphersuites for Transport Layer Security (TLS)", RFC
              4279, December 2005.

   [TLS1.0]   Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              RFC 2246, January 1999.

   [TLS1.1]   Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346, April 2006.

   [X501]     ITU-T Recommendation X.501: Information Technology - Open
              Systems Interconnection - The Directory: Models, 1993.

   [XDR]      Eisler, M., Ed., "XDR: External Data Representation
              Standard", STD 67, RFC 4506, May 2006.

Working Group Information

   The discussion list for the IETF TLS working group is located at the
   e-mail address <tls@ietf.org>. Information on the group and
   information on how to subscribe to the list is at
   <https://www1.ietf.org/mailman/listinfo/tls>

   Archives of the list can be found at:
   <http://www.ietf.org/mail-archive/web/tls/current/index.html>

Contributors

   Christopher Allen (co-editor of TLS 1.0)
   Alacrity Ventures
   ChristopherA@AlacrityManagement.com

   Martin Abadi
   University of California, Santa Cruz
   abadi@cs.ucsc.edu

   Steven M. Bellovin
   Columbia University
   smb@cs.columbia.edu

   Simon Blake-Wilson
   BCI
   sblakewilson@bcisse.com




Dierks & Rescorla           Standards Track                   [Page 101]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Ran Canetti
   IBM
   canetti@watson.ibm.com

   Pete Chown
   Skygate Technology Ltd
   pc@skygate.co.uk

   Taher Elgamal
   taher@securify.com
   Securify

   Pasi Eronen
   pasi.eronen@nokia.com
   Nokia

   Anil Gangolli
   anil@busybuddha.org

   Kipp Hickman

   Alfred Hoenes

   David Hopwood
   Independent Consultant
   david.hopwood@blueyonder.co.uk

   Phil Karlton (co-author of SSLv3)

   Paul Kocher (co-author of SSLv3)
   Cryptography Research
   paul@cryptography.com

   Hugo Krawczyk
   IBM
   hugo@ee.technion.ac.il

   Jan Mikkelsen
   Transactionware
   janm@transactionware.com

   Magnus Nystrom
   RSA Security
   magnus@rsasecurity.com

   Robert Relyea
   Netscape Communications
   relyea@netscape.com



Dierks & Rescorla           Standards Track                   [Page 102]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Jim Roskind
   Netscape Communications
   jar@netscape.com

   Michael Sabin

   Dan Simon
   Microsoft, Inc.
   dansimon@microsoft.com

   Tom Weinstein

   Tim Wright
   Vodafone
   timothy.wright@vodafone.com

Editors' Addresses

   Tim Dierks
   Independent
   EMail: tim@dierks.org

   Eric Rescorla
   RTFM, Inc.
   EMail: ekr@rtfm.com


























Dierks & Rescorla           Standards Track                   [Page 103]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












Dierks & Rescorla           Standards Track                   [Page 104]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-salowey-t...] [Tracker] [Diff1] [Diff2] [IPR]
   [Errata]
   Obsoleted by: 8446 PROPOSED STANDARD
   Updated by: 8447 Errata Exist
Network Working Group                                         J. Salowey
Request for Comments: 5077                                       H. Zhou
Obsoletes: 4507                                            Cisco Systems
Category: Standards Track                                      P. Eronen
                                                                   Nokia
                                                           H. Tschofenig
                                                  Nokia Siemens Networks
                                                            January 2008


       Transport Layer Security (TLS) Session Resumption without
                           Server-Side State

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   This document describes a mechanism that enables the Transport Layer
   Security (TLS) server to resume sessions and avoid keeping per-client
   session state.  The TLS server encapsulates the session state into a
   ticket and forwards it to the client.  The client can subsequently
   resume a session using the obtained ticket.  This document obsoletes
   RFC 4507.






















Salowey, et al.             Standards Track                     [Page 1]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  3
   3.  Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . .  3
     3.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . .  4
     3.2.  SessionTicket TLS Extension  . . . . . . . . . . . . . . .  7
     3.3.  NewSessionTicket Handshake Message . . . . . . . . . . . .  8
     3.4.  Interaction with TLS Session ID  . . . . . . . . . . . . .  9
   4.  Recommended Ticket Construction  . . . . . . . . . . . . . . . 10
   5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 12
     5.1.  Invalidating Sessions  . . . . . . . . . . . . . . . . . . 12
     5.2.  Stolen Tickets . . . . . . . . . . . . . . . . . . . . . . 12
     5.3.  Forged Tickets . . . . . . . . . . . . . . . . . . . . . . 12
     5.4.  Denial of Service Attacks  . . . . . . . . . . . . . . . . 12
     5.5.  Ticket Protection Key Management . . . . . . . . . . . . . 13
     5.6.  Ticket Lifetime  . . . . . . . . . . . . . . . . . . . . . 13
     5.7.  Alternate Ticket Formats and Distribution Schemes  . . . . 13
     5.8.  Identity Privacy, Anonymity, and Unlinkability . . . . . . 14
   6.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 14
   7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 15
   8.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 15
     8.1.  Normative References . . . . . . . . . . . . . . . . . . . 15
     8.2.  Informative References . . . . . . . . . . . . . . . . . . 15
   Appendix A.  Discussion of Changes to RFC 4507 . . . . . . . . . . 17


























Salowey, et al.             Standards Track                     [Page 2]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


1.  Introduction

   This document defines a way to resume a Transport Layer Security
   (TLS) session without requiring session-specific state at the TLS
   server.  This mechanism may be used with any TLS ciphersuite.  This
   document applies to both TLS 1.0 defined in [RFC2246], and TLS 1.1
   defined in [RFC4346].  The mechanism makes use of TLS extensions
   defined in [RFC4366] and defines a new TLS message type.

   This mechanism is useful in the following situations:

   1.  servers that handle a large number of transactions from different
       users

   2.  servers that desire to cache sessions for a long time

   3.  ability to load balance requests across servers

   4.  embedded servers with little memory

   This document obsoletes RFC 4507 [RFC4507] to correct an error in the
   encoding that caused the specification to differ from deployed
   implementations.  At the time of this writing, there are no known
   implementations that follow the encoding specified in RFC 4507.  This
   update to RFC 4507 aligns the document with currently deployed
   implementations.  More details of the change are given in Appendix A.

2.  Terminology

   Within this document, the term 'ticket' refers to a cryptographically
   protected data structure that is created and consumed by the server
   to rebuild session-specific state.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

3.  Protocol

   This specification describes a mechanism to distribute encrypted
   session-state information to the client in the form of a ticket and a
   mechanism to present the ticket back to the server.  The ticket is
   created by a TLS server and sent to a TLS client.  The TLS client
   presents the ticket to the TLS server to resume a session.
   Implementations of this specification are expected to support both
   mechanisms.  Other specifications can take advantage of the session
   tickets, perhaps specifying alternative means for distribution or
   selection.  For example, a separate specification may describe an



Salowey, et al.             Standards Track                     [Page 3]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   alternate way to distribute a ticket and use the TLS extension in
   this document to resume the session.  This behavior is beyond the
   scope of the document and would need to be described in a separate
   specification.

3.1.  Overview

   The client indicates that it supports this mechanism by including a
   SessionTicket TLS extension in the ClientHello message.  The
   extension will be empty if the client does not already possess a
   ticket for the server.  The server sends an empty SessionTicket
   extension to indicate that it will send a new session ticket using
   the NewSessionTicket handshake message.  The extension is described
   in Section 3.2.

   If the server wants to use this mechanism, it stores its session
   state (such as ciphersuite and master secret) to a ticket that is
   encrypted and integrity-protected by a key known only to the server.
   The ticket is distributed to the client using the NewSessionTicket
   TLS handshake message described in Section 3.3.  This message is sent
   during the TLS handshake before the ChangeCipherSpec message, after
   the server has successfully verified the client's Finished message.

         Client                                               Server

         ClientHello
        (empty SessionTicket extension)-------->
                                                         ServerHello
                                     (empty SessionTicket extension)
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                      <--------      ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         [ChangeCipherSpec]
         Finished                     -------->
                                                    NewSessionTicket
                                                  [ChangeCipherSpec]
                                      <--------             Finished
         Application Data             <------->     Application Data

   Figure 1: Message Flow for Full Handshake Issuing New Session Ticket







Salowey, et al.             Standards Track                     [Page 4]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   The client caches this ticket along with the master secret and other
   parameters associated with the current session.  When the client
   wishes to resume the session, it includes the ticket in the
   SessionTicket extension within the ClientHello message.  Appendix A
   provides a detailed description of the encoding of the extension and
   changes from RFC 4507.  The server then decrypts the received ticket,
   verifies the ticket's validity, retrieves the session state from the
   contents of the ticket, and uses this state to resume the session.
   The interaction with the TLS Session ID is described in Section 3.4.
   If the server successfully verifies the client's ticket, then it may
   renew the ticket by including a NewSessionTicket handshake message
   after the ServerHello.

         Client                                                Server
         ClientHello
         (SessionTicket extension)      -------->
                                                          ServerHello
                                      (empty SessionTicket extension)
                                                     NewSessionTicket
                                                   [ChangeCipherSpec]
                                       <--------             Finished
         [ChangeCipherSpec]
         Finished                      -------->
         Application Data              <------->     Application Data

    Figure 2: Message Flow for Abbreviated Handshake Using New Session
                                  Ticket

   A recommended ticket format is given in Section 4.

   If the server cannot or does not want to honor the ticket, then it
   can initiate a full handshake with the client.

   In the case that the server does not wish to issue a new ticket at
   this time, it just completes the handshake without including a
   SessionTicket extension or NewSessionTicket handshake message.  This
   is shown below (this flow is identical to Figure 1 in RFC 4346,
   except for the SessionTicket extension in the first message):













Salowey, et al.             Standards Track                     [Page 5]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


         Client                                               Server

         ClientHello
         (SessionTicket extension)    -------->
                                                         ServerHello
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                      <--------      ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         [ChangeCipherSpec]
         Finished                     -------->
                                                  [ChangeCipherSpec]
                                      <--------             Finished
         Application Data             <------->     Application Data

    Figure 3: Message Flow for Server Completing Full Handshake Without
                        Issuing New Session Ticket

   It is also permissible to have an exchange similar to Figure 3 using
   the abbreviated handshake defined in Figure 2 of RFC 4346, where the
   client uses the SessionTicket extension to resume the session, but
   the server does not wish to issue a new ticket, and therefore does
   not send a SessionTicket extension.

   If the server rejects the ticket, it may still wish to issue a new
   ticket after performing the full handshake as shown below (this flow
   is identical to Figure 1, except the SessionTicket extension in the
   ClientHello is not empty):




















Salowey, et al.             Standards Track                     [Page 6]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


         Client                                               Server

         ClientHello
         (SessionTicket extension) -------->
                                                         ServerHello
                                     (empty SessionTicket extension)
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                  <--------          ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         [ChangeCipherSpec]
         Finished                 -------->
                                                    NewSessionTicket
                                                  [ChangeCipherSpec]
                                  <--------                 Finished
         Application Data         <------->         Application Data

    Figure 4: Message Flow for Server Rejecting Ticket, Performing Full
                 Handshake, and Issuing New Session Ticket

3.2.  SessionTicket TLS Extension

   The SessionTicket TLS extension is based on [RFC4366].  The format of
   the ticket is an opaque structure used to carry session-specific
   state information.  This extension may be sent in the ClientHello and
   ServerHello.

   If the client possesses a ticket that it wants to use to resume a
   session, then it includes the ticket in the SessionTicket extension
   in the ClientHello.  If the client does not have a ticket and is
   prepared to receive one in the NewSessionTicket handshake message,
   then it MUST include a zero-length ticket in the SessionTicket
   extension.  If the client is not prepared to receive a ticket in the
   NewSessionTicket handshake message, then it MUST NOT include a
   SessionTicket extension unless it is sending a non-empty ticket it
   received through some other means from the server.

   The server uses a zero-length SessionTicket extension to indicate to
   the client that it will send a new session ticket using the
   NewSessionTicket handshake message described in Section 3.3.  The
   server MUST send this extension in the ServerHello if it wishes to
   issue a new ticket to the client using the NewSessionTicket handshake
   message.  The server MUST NOT send this extension if it does not
   receive one in the ClientHello.




Salowey, et al.             Standards Track                     [Page 7]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   If the server fails to verify the ticket, then it falls back to
   performing a full handshake.  If the ticket is accepted by the server
   but the handshake fails, the client SHOULD delete the ticket.

   The SessionTicket extension has been assigned the number 35.  The
   extension_data field of SessionTicket extension contains the ticket.

3.3.  NewSessionTicket Handshake Message

   This message is sent by the server during the TLS handshake before
   the ChangeCipherSpec message.  This message MUST be sent if the
   server included a SessionTicket extension in the ServerHello.  This
   message MUST NOT be sent if the server did not include a
   SessionTicket extension in the ServerHello.  This message is included
   in the hash used to create and verify the Finished message.  In the
   case of a full handshake, the server MUST verify the client's
   Finished message before sending the ticket.  The client MUST NOT
   treat the ticket as valid until it has verified the server's Finished
   message.  If the server determines that it does not want to include a
   ticket after it has included the SessionTicket extension in the
   ServerHello, then it sends a zero-length ticket in the
   NewSessionTicket handshake message.

   If the server successfully verifies the client's ticket, then it MAY
   renew the ticket by including a NewSessionTicket handshake message
   after the ServerHello in the abbreviated handshake.  The client
   should start using the new ticket as soon as possible after it
   verifies the server's Finished message for new connections.  Note
   that since the updated ticket is issued before the handshake
   completes, it is possible that the client may not put the new ticket
   into use before it initiates new connections.  The server MUST NOT
   assume that the client actually received the updated ticket until it
   successfully verifies the client's Finished message.

   The NewSessionTicket handshake message has been assigned the number 4
   and its definition is given at the end of this section.  The
   ticket_lifetime_hint field contains a hint from the server about how
   long the ticket should be stored.  The value indicates the lifetime
   in seconds as a 32-bit unsigned integer in network byte order
   relative to when the ticket is received.  A value of zero is reserved
   to indicate that the lifetime of the ticket is unspecified.  A client
   SHOULD delete the ticket and associated state when the time expires.
   It MAY delete the ticket earlier based on local policy.  A server MAY
   treat a ticket as valid for a shorter or longer period of time than
   what is stated in the ticket_lifetime_hint.






Salowey, et al.             Standards Track                     [Page 8]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


      struct {
          HandshakeType msg_type;
          uint24 length;
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
              case session_ticket:      NewSessionTicket; /* NEW */
          } body;
      } Handshake;


      struct {
          uint32 ticket_lifetime_hint;
          opaque ticket<0..2^16-1>;
      } NewSessionTicket;

3.4.  Interaction with TLS Session ID

   If a server is planning on issuing a session ticket to a client that
   does not present one, it SHOULD include an empty Session ID in the
   ServerHello.  If the server rejects the ticket and falls back to the
   full handshake then it may include a non-empty Session ID to indicate
   its support for stateful session resumption.  If the client receives
   a session ticket from the server, then it discards any Session ID
   that was sent in the ServerHello.

   When presenting a ticket, the client MAY generate and include a
   Session ID in the TLS ClientHello.  If the server accepts the ticket
   and the Session ID is not empty, then it MUST respond with the same
   Session ID present in the ClientHello.  This allows the client to
   easily differentiate when the server is resuming a session from when
   it is falling back to a full handshake.  Since the client generates a
   Session ID, the server MUST NOT rely upon the Session ID having a
   particular value when validating the ticket.  If a ticket is
   presented by the client, the server MUST NOT attempt to use the
   Session ID in the ClientHello for stateful session resumption.
   Alternatively, the client MAY include an empty Session ID in the
   ClientHello.  In this case, the client ignores the Session ID sent in
   the ServerHello and determines if the server is resuming a session by
   the subsequent handshake messages.



Salowey, et al.             Standards Track                     [Page 9]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


4.  Recommended Ticket Construction

   This section describes a recommended format and protection for the
   ticket.  Note that the ticket is opaque to the client, so the
   structure is not subject to interoperability concerns, and
   implementations may diverge from this format.  If implementations do
   diverge from this format, they must take security concerns seriously.
   Clients MUST NOT examine the ticket under the assumption that it
   complies with this document.

   The server uses two different keys: one 128-bit key for Advanced
   Encryption Standard (AES) [AES] in Cipher Block Chaining (CBC) mode
   [CBC] encryption and one 256-bit key for HMAC-SHA-256 [RFC4634].

   The ticket is structured as follows:

      struct {
          opaque key_name[16];
          opaque iv[16];
          opaque encrypted_state<0..2^16-1>;
          opaque mac[32];
      } ticket;

   Here, key_name serves to identify a particular set of keys used to
   protect the ticket.  It enables the server to easily recognize
   tickets it has issued.  The key_name should be randomly generated to
   avoid collisions between servers.  One possibility is to generate new
   random keys and key_name every time the server is started.

   The actual state information in encrypted_state is encrypted using
   128-bit AES in CBC mode with the given IV.  The Message
   Authentication Code (MAC) is calculated using HMAC-SHA-256 over
   key_name (16 octets) and IV (16 octets), followed by the length of
   the encrypted_state field (2 octets) and its contents (variable
   length).
















Salowey, et al.             Standards Track                    [Page 10]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


      struct {
          ProtocolVersion protocol_version;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          opaque master_secret[48];
          ClientIdentity client_identity;
          uint32 timestamp;
      } StatePlaintext;

      enum {
         anonymous(0),
         certificate_based(1),
         psk(2)
     } ClientAuthenticationType;

      struct {
          ClientAuthenticationType client_authentication_type;
          select (ClientAuthenticationType) {
              case anonymous: struct {};
              case certificate_based:
                  ASN.1Cert certificate_list<0..2^24-1>;
              case psk:
                  opaque psk_identity<0..2^16-1>;   /* from [RFC4279] */
          };
       } ClientIdentity;

   The structure StatePlaintext stores the TLS session state including
   the master_secret.  The timestamp within this structure allows the
   TLS server to expire tickets.  To cover the authentication and key
   exchange protocols provided by TLS, the ClientIdentity structure
   contains the authentication type of the client used in the initial
   exchange (see ClientAuthenticationType).  To offer the TLS server
   with the same capabilities for authentication and authorization, a
   certificate list is included in case of public-key-based
   authentication.  The TLS server is therefore able to inspect a number
   of different attributes within these certificates.  A specific
   implementation might choose to store a subset of this information or
   additional information.  Other authentication mechanisms, such as
   Kerberos [RFC2712], would require different client identity data.
   Other TLS extensions may require the inclusion of additional data in
   the StatePlaintext structure.










Salowey, et al.             Standards Track                    [Page 11]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


5.  Security Considerations

   This section addresses security issues related to the usage of a
   ticket.  Tickets must be authenticated and encrypted to prevent
   modification or eavesdropping by an attacker.  Several attacks
   described below will be possible if this is not carefully done.

   Implementations should take care to ensure that the processing of
   tickets does not increase the chance of denial of service as
   described below.

5.1.  Invalidating Sessions

   The TLS specification requires that TLS sessions be invalidated when
   errors occur.  [CSSC] discusses the security implications of this in
   detail.  In the analysis within this paper, failure to invalidate
   sessions does not pose a security risk.  This is because the TLS
   handshake uses a non-reversible function to derive keys for a session
   so information about one session does not provide an advantage to
   attack the master secret or a different session.  If a session
   invalidation scheme is used, the implementation should verify the
   integrity of the ticket before using the contents to invalidate a
   session to ensure that an attacker cannot invalidate a chosen
   session.

5.2.  Stolen Tickets

   An eavesdropper or man-in-the-middle may obtain the ticket and
   attempt to use it to establish a session with the server; however,
   since the ticket is encrypted and the attacker does not know the
   secret key, a stolen ticket does not help an attacker resume a
   session.  A TLS server MUST use strong encryption and integrity
   protection for the ticket to prevent an attacker from using a brute
   force mechanism to obtain the ticket's contents.

5.3.  Forged Tickets

   A malicious user could forge or alter a ticket in order to resume a
   session, to extend its lifetime, to impersonate another user, or to
   gain additional privileges.  This attack is not possible if the
   ticket is protected using a strong integrity protection algorithm
   such as a keyed HMAC-SHA-256.

5.4.  Denial of Service Attacks

   The key_name field defined in the recommended ticket format helps the
   server efficiently reject tickets that it did not issue.  However, an
   adversary could store or generate a large number of tickets to send



Salowey, et al.             Standards Track                    [Page 12]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   to the TLS server for verification.  To minimize the possibility of a
   denial of service, the verification of the ticket should be
   lightweight (e.g., using efficient symmetric key cryptographic
   algorithms).

5.5.  Ticket Protection Key Management

   A full description of the management of the keys used to protect the
   ticket is beyond the scope of this document.  A list of RECOMMENDED
   practices is given below.

   o  The keys should be generated securely following the randomness
      recommendations in [RFC4086].

   o  The keys and cryptographic protection algorithms should be at
      least 128 bits in strength.  Some ciphersuites and applications
      may require cryptographic protection greater than 128 bits in
      strength.

   o  The keys should not be used for any purpose other than generating
      and verifying tickets.

   o  The keys should be changed regularly.

   o  The keys should be changed if the ticket format or cryptographic
      protection algorithms change.

5.6.  Ticket Lifetime

   The TLS server controls the lifetime of the ticket.  Servers
   determine the acceptable lifetime based on the operational and
   security requirements of the environments in which they are deployed.
   The ticket lifetime may be longer than the 24-hour lifetime
   recommended in [RFC4346].  TLS clients may be given a hint of the
   lifetime of the ticket.  Since the lifetime of a ticket may be
   unspecified, a client has its own local policy that determines when
   it discards tickets.

5.7.  Alternate Ticket Formats and Distribution Schemes

   If the ticket format or distribution scheme defined in this document
   is not used, then great care must be taken in analyzing the security
   of the solution.  In particular, if confidential information, such as
   a secret key, is transferred to the client, it MUST be done using
   secure communication so as to prevent attackers from obtaining or
   modifying the key.  Also, the ticket MUST have its integrity and
   confidentiality protected with strong cryptographic techniques to
   prevent a breach in the security of the system.



Salowey, et al.             Standards Track                    [Page 13]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


5.8.  Identity Privacy, Anonymity, and Unlinkability

   This document mandates that the content of the ticket is
   confidentiality protected in order to avoid leakage of its content,
   such as user-relevant information.  As such, it prevents disclosure
   of potentially sensitive information carried within the ticket.

   The initial handshake exchange, which was used to obtain the ticket,
   might not provide identity confidentiality of the client based on the
   properties of TLS.  Another relevant security threat is the ability
   for an on-path adversary to observe multiple TLS handshakes where the
   same ticket is used, therefore concluding they belong to the same
   communication endpoints.  Application designers that use the ticket
   mechanism described in this document should consider that
   unlinkability [ANON] is not necessarily provided.

   While a full discussion of these topics is beyond the scope of this
   document, it should be noted that it is possible to issue a ticket
   using a TLS renegotiation handshake that occurs after a secure tunnel
   has been established by a previous handshake.  This may help address
   some privacy and unlinkability issues in some environments.

6.  Acknowledgements

   The authors would like to thank the following people for their help
   with preparing and reviewing this document: Eric Rescorla, Mohamad
   Badra, Tim Dierks, Nelson Bolyard, Nancy Cam-Winget, David McGrew,
   Rob Dugal, Russ Housley, Amir Herzberg, Bernard Aboba, and members of
   the TLS working group.

   [CSSC] describes a solution that is very similar to the one described
   in this document and gives a detailed analysis of the security
   considerations involved.  [RFC2712] describes a mechanism for using
   Kerberos [RFC4120] in TLS ciphersuites, which helped inspire the use
   of tickets to avoid server state.  [RFC4851] makes use of a similar
   mechanism to avoid maintaining server state for the cryptographic
   tunnel.  [SC97] also investigates the concept of stateless sessions.

   The authors would also like to thank Jan Nordqvist, who found the
   encoding error in RFC 4507, corrected by this document.  In addition
   Nagendra Modadugu, Wan-Teh Chang, and Michael D'Errico provided
   useful feedback during the review of this document.









Salowey, et al.             Standards Track                    [Page 14]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


7.  IANA Considerations

   IANA has assigned a TLS extension number of 35 to the SessionTicket
   TLS extension from the TLS registry of ExtensionType values defined
   in [RFC4366].

   IANA has assigned a TLS HandshakeType number 4 to the
   NewSessionTicket handshake type from the TLS registry of
   HandshakeType values defined in [RFC4346].

   This document does not require any actions or assignments from IANA.

8.  References

8.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2246]  Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              RFC 2246, January 1999.

   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346, April 2006.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, April 2006.

   [RFC4507]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
              "Transport Layer Security (TLS) Session Resumption without
              Server-Side State", RFC 4507, May 2006.

8.2.  Informative References

   [AES]      National Institute of Standards and Technology, "Advanced
              Encryption Standard (AES)", Federal Information Processing
              Standards (FIPS) Publication 197, November 2001.

   [ANON]     Pfitzmann, A. and M. Hansen, "Anonymity, Unlinkability,
              Unobservability, Pseudonymity, and Identity Management - A
              Consolidated Proposal for Terminology", http://
              dud.inf.tu-dresden.de/literatur/
              Anon_Terminology_v0.26-1.pdf Version 0.26, December 2005.







Salowey, et al.             Standards Track                    [Page 15]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   [CBC]      National Institute of Standards and Technology,
              "Recommendation for Block Cipher Modes of Operation -
              Methods and Techniques", NIST Special Publication 800-38A,
              December 2001.

   [CSSC]     Shacham, H., Boneh, D., and E. Rescorla, "Client-side
              caching for TLS", Transactions on Information and System
              Security (TISSEC) , Volume 7, Issue 4, November 2004.

   [RFC2712]  Medvinsky, A. and M. Hur, "Addition of Kerberos Cipher
              Suites to Transport Layer Security (TLS)", RFC 2712,
              October 1999.

   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, "Randomness
              Requirements for Security", BCP 106, RFC 4086, June 2005.

   [RFC4120]  Neuman, C., Yu, T., Hartman, S., and K. Raeburn, "The
              Kerberos Network Authentication Service (V5)", RFC 4120,
              July 2005.

   [RFC4279]  Eronen, P. and H. Tschofenig, "Pre-Shared Key Ciphersuites
              for Transport Layer Security (TLS)", RFC 4279,
              December 2005.

   [RFC4634]  Eastlake, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and HMAC-SHA)", RFC 4634, July 2006.

   [RFC4851]  Cam-Winget, N., McGrew, D., Salowey, J., and H. Zhou, "The
              Flexible Authentication via Secure Tunneling Extensible
              Authentication Protocol Method (EAP-FAST)", RFC 4851,
              May 2007.

   [SC97]     Aura, T. and P. Nikander, "Stateless Connections",
              Proceedings of the First International Conference on
              Information and Communication Security (ICICS '97) , 1997.
















Salowey, et al.             Standards Track                    [Page 16]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


Appendix A.  Discussion of Changes to RFC 4507

   RFC 4507 [RFC4507] defines a mechanism to resume a TLS session
   without maintaining server side state by specifying an encrypted
   ticket that is maintained on the client.  The client presents this
   ticket to the server in a SessionTicket hello extension.  The
   encoding in RFC 4507 used the XDR style encoding specified in TLS
   [RFC4346].

   An error in the encoding caused the specification to differ from
   deployed implementations.  At the time of this writing there are no
   known implementations that follow the encoding specified in RFC 4507.
   This update to RFC 4507 aligns the document with these currently
   deployed implementations.

   Erroneous encoding in RFC 4507 resulted in two length fields; one for
   the extension contents and one for the ticket itself.  Hence, for a
   ticket that is 256 bytes long and begins with the hex value FF FF,
   the encoding of the extension would be as follows according to RFC
   4507:

        00 23          Ticket Extension type 35
        01 02          Length of extension contents
        01 00          Length of ticket
        FF FF .. ..    Actual ticket

   The update proposed in this document reflects what implementations
   actually encode, namely it removes the redundant length field.  So,
   for a ticket that is 256 bytes long and begins with the hex value FF
   FF, the encoding of the extension would be as follows according to
   this update:

        00 23          Extension type 35
        01 00          Length of extension contents (ticket)
        FF FF .. ..    Actual ticket

   A server implemented according to RFC 4507 receiving a ticket
   extension from a client conforming to this document would interpret
   the first two bytes of the ticket as the length of this ticket.  This
   will result in either an inconsistent length field or in the
   processing of a ticket missing the first two bytes.  In the first
   case, the server should reject the request based on a malformed
   length.  In the second case, the server should reject the ticket
   based on a malformed ticket, incorrect key version, or failed
   decryption.  A server implementation based on this update receiving
   an RFC 4507 extension would interpret the first length field as the





Salowey, et al.             Standards Track                    [Page 17]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   length of the ticket and include the second two length bytes as the
   first bytes in the ticket, resulting in the ticket being rejected
   based on a malformed ticket, incorrect key version, or failed
   decryption.

   Note that the encoding of an empty SessionTicket extension was
   ambiguous in RFC 4507.  An RFC 4507 implementation may have encoded
   it as:

        00 23      Extension type 35
        00 02      Length of extension contents
        00 00      Length of ticket

   or it may have encoded it the same way as this update:

        00 23      Extension type 35
        00 00      Length of extension contents

   A server wishing to support RFC 4507 clients should respond to an
   empty SessionTicket extension encoded the same way as it received it.

   A server implementation can construct tickets such that it can detect
   an RFC 4507 implementation, if one existed, by including a cookie at
   the beginning of the tickets that can be differentiated from a valid
   length.  For example, if an implementation constructed tickets to
   start with the hex values FF FF, then it could determine where the
   ticket begins and determine the length correctly from the type of
   length fields present.

   This document makes a few additional changes to RFC 4507 listed
   below.

   o  Clarifying that the server can allow session resumption using a
      ticket without issuing a new ticket in Section 3.1.

   o  Clarifying that the lifetime is relative to when the ticket is
      received in section 3.3.

   o  Clarifying that the NewSessionTicket handshake message is included
      in the hash generated for the Finished messages in Section 3.3.

   o  Clarifying the interaction with TLS Session ID in Section 3.4.

   o  Recommending the use of SHA-256 for the integrity protection of
      the ticket in Section 4.

   o  Clarifying that additional data can be included in the
      StatePlaintext structure in Section 4.



Salowey, et al.             Standards Track                    [Page 18]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


Authors' Addresses

   Joseph Salowey
   Cisco Systems
   2901 3rd Ave
   Seattle, WA  98121
   US

   EMail: jsalowey@cisco.com


   Hao Zhou
   Cisco Systems
   4125 Highlander Parkway
   Richfield, OH  44286
   US

   EMail: hzhou@cisco.com


   Pasi Eronen
   Nokia Research Center
   P.O. Box 407
   FIN-00045 Nokia Group
   Finland

   EMail: pasi.eronen@nokia.com


   Hannes Tschofenig
   Nokia Siemens Networks
   Otto-Hahn-Ring 6
   Munich, Bayern  81739
   Germany

   EMail: Hannes.Tschofenig@nsn.com















Salowey, et al.             Standards Track                    [Page 19]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












Salowey, et al.             Standards Track                    [Page 20]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2] [IPR]
   [Errata]
   Updated by: 8446, 8447 PROPOSED STANDARD
   Errata Exist
Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 5705                                    RTFM, Inc.
Category: Standards Track                                     March 2010
ISSN: 2070-1721


      Keying Material Exporters for Transport Layer Security (TLS)

Abstract

   A number of protocols wish to leverage Transport Layer Security (TLS)
   to perform key establishment but then use some of the keying material
   for their own purposes.  This document describes a general mechanism
   for allowing that.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/5705.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow



Rescorla                     Standards Track                    [Page 1]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . 2
   2.  Conventions Used In This Document . . . . . . . . . . . . . . . 3
   3.  Binding to Application Contexts . . . . . . . . . . . . . . . . 3
   4.  Exporter Definition . . . . . . . . . . . . . . . . . . . . . . 4
   5.  Security Considerations . . . . . . . . . . . . . . . . . . . . 5
   6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . . . 6
   7.  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . 6
   8.  References  . . . . . . . . . . . . . . . . . . . . . . . . . . 7
     8.1.  Normative References  . . . . . . . . . . . . . . . . . . . 7
     8.2.  Informative References  . . . . . . . . . . . . . . . . . . 7

1.  Introduction

   Note:  The mechanism described in this document was previously known
          as "TLS Extractors" but was changed to avoid a name conflict
          with the use of the term "Extractor" in the cryptographic
          community.

   A number of protocols wish to leverage Transport Layer Security (TLS)
   [RFC5246] or Datagram TLS (DTLS) [RFC4347] to perform key
   establishment but then use some of the keying material for their own
   purposes.  A typical example is DTLS-SRTP [DTLS-SRTP], a key
   management scheme for the Secure Real-time Transport Protocol (SRTP)
   that uses DTLS to perform a key exchange and negotiate the SRTP
   [RFC3711] protection suite and then uses the DTLS master_secret to
   generate the SRTP keys.

   These applications imply a need to be able to export keying material
   (later called Exported Keying Material or EKM) from TLS/DTLS to an
   application or protocol residing at an upper layer, and to securely
   agree on the upper-layer context where the keying material will be
   used.  The mechanism for exporting the keying material has the
   following requirements:

   o  Both client and server need to be able to export the same EKM
      value.





Rescorla                     Standards Track                    [Page 2]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


   o  EKM values should be indistinguishable from random data to
      attackers who don't know the master_secret.

   o  It should be possible to export multiple EKM values from the same
      TLS/DTLS association.

   o  Knowing one EKM value should not reveal any useful information
      about the master_secret or about other EKM values.

   The mechanism described in this document is intended to fulfill these
   requirements.  This mechanism is compatible with all versions of TLS.

2.  Conventions Used In This Document

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

3.  Binding to Application Contexts

   In addition to using an exporter to obtain keying material, an
   application using the keying material has to securely establish the
   upper-layer context where the keying material will be used.  The
   details of this context depend on the application, but it could
   include things such as algorithms and parameters that will be used
   with the keys, identifier(s) for the endpoint(s) who will use the
   keys, identifier(s) for the session(s) where the keys will be used,
   and the lifetime(s) for the context and/or keys.  At a minimum, there
   should be some mechanism for signaling that an exporter will be used.

   This specification does not mandate a single mechanism for agreeing
   on such context; instead, there are several possibilities that can be
   used (and can complement each other).  For example:

   o  Information about the upper-layer context can be included in the
      optional data after the exporter label (see Section 4).

   o  Information about the upper-layer context can be exchanged in TLS
      extensions included in the ClientHello and ServerHello messages.
      This approach is used in [DTLS-SRTP].  The handshake messages are
      protected by the Finished messages, so once the handshake
      completes, the peers will have the same view of the information.
      Extensions also allow a limited form of negotiation: for example,
      the TLS client could propose several alternatives for some context
      parameters, and the TLS server could select one of them.

   o  The upper-layer protocol can include its own handshake, which can
      be protected using the keys exported by TLS.



Rescorla                     Standards Track                    [Page 3]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


   No matter how the context is agreed, it is required that it has one
   part that indicates which application will use the exported keys.
   This part is the disambiguating label string (see Section 4).

   It is important to note that just embedding TLS messages in the
   upper-layer protocol may not automatically secure all the important
   context information, since the upper-layer messages are not covered
   by TLS Finished messages.

4.  Exporter Definition

   The output of the exporter is intended to be used in a single scope,
   which is associated with the TLS session, the label, and the context
   value.

   The exporter takes three input values:

   o  a disambiguating label string,

   o  a per-association context value provided by the application using
      the exporter, and

   o  a length value.

   If no context is provided, it then computes:

           PRF(SecurityParameters.master_secret, label,
               SecurityParameters.client_random +
               SecurityParameters.server_random
               )[length]

   If context is provided, it computes:

           PRF(SecurityParameters.master_secret, label,
               SecurityParameters.client_random +
               SecurityParameters.server_random +
               context_value_length + context_value
               )[length]

   Where PRF is the TLS Pseudorandom Function in use for the session.
   The output is a pseudorandom bit string of length bytes generated
   from the master_secret.  (This construction allows for
   interoperability with older exporter-type constructions which do not
   use context values, e.g., [RFC5281]).

   Labels here have the same definition as in TLS, i.e., an ASCII string
   with no terminating NULL.  Label values beginning with "EXPERIMENTAL"
   MAY be used for private use without registration.  All other label



Rescorla                     Standards Track                    [Page 4]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


   values MUST be registered via Specification Required as described by
   RFC 5226 [RFC5226].  Note that exporter labels have the potential to
   collide with existing PRF labels.  In order to prevent this, labels
   SHOULD begin with "EXPORTER".  This is not a MUST because there are
   existing uses that have labels which do not begin with this prefix.

   The context value allows the application using the exporter to mix
   its own data with the TLS PRF for the exporter output.  One example
   of where this might be useful is an authentication setting where the
   client credentials are valid for more than one identity; the context
   value could then be used to mix the expected identity into the keying
   material, thus preventing substitution attacks.  The context value
   length is encoded as an unsigned, 16-bit quantity (uint16; see
   [RFC5246], Section 4.4) representing the length of the context value.
   The context MAY be zero length.  Because the context value is mixed
   with the master_secret via the PRF, it is safe to mix confidential
   information into the exporter, provided that the master_secret will
   not be known to the attacker.

5.  Security Considerations

   The prime security requirement for exporter outputs is that they be
   independent.  More formally, after a particular TLS session, if an
   adversary is allowed to choose multiple (label, context value) pairs
   and is given the output of the PRF for those values, the attacker is
   still unable to distinguish between the output of the PRF for a
   (label, context value) pair (different from the ones that it
   submitted) and a random value of the same length.  In particular,
   there may be settings, such as the one described in Section 4, where
   the attacker can control the context value; such an attacker MUST NOT
   be able to predict the output of the exporter.  Similarly, an
   attacker who does not know the master secret should not be able to
   distinguish valid exporter outputs from random values.  The current
   set of TLS PRFs is believed to meet this objective, provided the
   master secret is randomly generated.

   Because an exporter produces the same value if applied twice with the
   same label to the same master_secret, it is critical that two EKM
   values generated with the same label not be used for two different
   purposes -- hence, the requirement for IANA registration.  However,
   because exporters depend on the TLS PRF, it is not a threat to the
   use of an EKM value generated from one label to reveal an EKM value
   generated from another label.

   With certain TLS cipher suites, the TLS master secret is not
   necessarily unique to a single TLS session.  In particular, with RSA
   key exchange, a malicious party acting as TLS server in one session
   and as TLS client in another session can cause those two sessions to



Rescorla                     Standards Track                    [Page 5]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


   have the same TLS master secret (though the sessions must be
   established simultaneously to get adequate control of the Random
   values).  Applications using the EKM need to consider this in how
   they use the EKM; in some cases, requiring the use of other cipher
   suites (such as those using a Diffie-Hellman key exchange) may be
   advisable.

   Designing a secure mechanism that uses exporters is not necessarily
   straightforward.  This document only provides the exporter mechanism,
   but the problem of agreeing on the surrounding context and the
   meaning of the information passed to and from the exporter remains.
   Any new uses of the exporter mechanism should be subject to careful
   review.

6.  IANA Considerations

   IANA has created a TLS Exporter Label registry for this purpose.  The
   initial contents of the registry are given below:

        Value                          Reference  Note
        -----------------------------  ---------  ----
        client finished                [RFC5246]  (1)
        server finished                [RFC5246]  (1)
        master secret                  [RFC5246]  (1)
        key expansion                  [RFC5246]  (1)
        client EAP encryption          [RFC5216]
        ttls keying material           [RFC5281]
        ttls challenge                 [RFC5281]

   Note: (1) These entries are reserved and MUST NOT be used for the
   purpose described in RFC 5705, in order to avoid confusion with
   similar, but distinct, use in RFC 5246.

   Future values are allocated via the RFC 5226 Specification Required
   policy.  The label is a string consisting of printable ASCII
   characters.  IANA MUST also verify that one label is not a prefix of
   any other label.  For example, labels "key" or "master secretary" are
   forbidden.

7.  Acknowledgments

   Thanks to Pasi Eronen for valuable comments and for the contents of
   the IANA section and Section 3.  Thanks to David McGrew for helpful
   discussion of the security considerations and to Vijay Gurbani and
   Alfred Hoenes for editorial comments.






Rescorla                     Standards Track                    [Page 6]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


8.  References

8.1.  Normative References

   [RFC2119]    Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC5226]    Narten, T. and H. Alvestrand, "Guidelines for Writing an
                IANA Considerations Section in RFCs", BCP 26, RFC 5226,
                May 2008.

   [RFC5246]    Dierks, T. and E. Rescorla, "The Transport Layer
                Security (TLS) Protocol Version 1.2", RFC 5246,
                August 2008.

8.2.  Informative References

   [DTLS-SRTP]  McGrew, D. and E. Rescorla, "Datagram Transport Layer
                Security (DTLS) Extension to Establish Keys for Secure
                Real-time Transport Protocol (SRTP)", Work in Progress,
                February 2009.

   [RFC3711]    Baugher, M., McGrew, D., Naslund, M., Carrara, E., and
                K. Norrman, "The Secure Real-time Transport Protocol
                (SRTP)", RFC 3711, March 2004.

   [RFC4347]    Rescorla, E. and N. Modadugu, "Datagram Transport Layer
                Security", RFC 4347, April 2006.

   [RFC5216]    Simon, D., Aboba, B., and R. Hurst, "The EAP-TLS
                Authentication Protocol", RFC 5216, March 2008.

   [RFC5281]    Funk, P. and S. Blake-Wilson, "Extensible Authentication
                Protocol Tunneled Transport Layer Security Authenticated
                Protocol Version 0 (EAP-TTLSv0)", RFC 5281, August 2008.

Author's Address

   Eric Rescorla
   RTFM, Inc.
   2064 Edgewood Drive
   Palo Alto, CA  94303
   USA

   EMail: ekr@rtfm.com






Rescorla                     Standards Track                    [Page 7]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-irtf-cfrg...] [Tracker] [Diff1] [Diff2]
   [Errata]
   INFORMATIONAL
   Errata Exist
Internet Research Task Force (IRTF)                         S. Josefsson
Request for Comments: 8032                                        SJD AB
Category: Informational                                     I. Liusvaara
ISSN: 2070-1721                                              Independent
                                                            January 2017


           Edwards-Curve Digital Signature Algorithm (EdDSA)

Abstract

   This document describes elliptic curve signature scheme Edwards-curve
   Digital Signature Algorithm (EdDSA).  The algorithm is instantiated
   with recommended parameters for the edwards25519 and edwards448
   curves.  An example implementation and test vectors are provided.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Research Task Force
   (IRTF).  The IRTF publishes the results of Internet-related research
   and development activities.  These results might not be suitable for
   deployment.  This RFC represents the consensus of the Crypto Forum
   Research Group of the Internet Research Task Force (IRTF).  Documents
   approved for publication by the IRSG are not a candidate for any
   level of Internet Standard; see Section 2 of RFC 7841.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc8032.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.







Josefsson & Liusvaara         Informational                     [Page 1]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Notation and Conventions  . . . . . . . . . . . . . . . . . .   4
   3.  EdDSA Algorithm . . . . . . . . . . . . . . . . . . . . . . .   5
     3.1.  Encoding  . . . . . . . . . . . . . . . . . . . . . . . .   7
     3.2.  Keys  . . . . . . . . . . . . . . . . . . . . . . . . . .   7
     3.3.  Sign  . . . . . . . . . . . . . . . . . . . . . . . . . .   8
     3.4.  Verify  . . . . . . . . . . . . . . . . . . . . . . . . .   8
   4.  PureEdDSA, HashEdDSA, and Naming  . . . . . . . . . . . . . .   8
   5.  EdDSA Instances . . . . . . . . . . . . . . . . . . . . . . .   9
     5.1.  Ed25519ph, Ed25519ctx, and Ed25519  . . . . . . . . . . .   9
       5.1.1.  Modular Arithmetic  . . . . . . . . . . . . . . . . .  10
       5.1.2.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  10
       5.1.3.  Decoding  . . . . . . . . . . . . . . . . . . . . . .  11
       5.1.4.  Point Addition  . . . . . . . . . . . . . . . . . . .  11
       5.1.5.  Key Generation  . . . . . . . . . . . . . . . . . . .  13
       5.1.6.  Sign  . . . . . . . . . . . . . . . . . . . . . . . .  13
       5.1.7.  Verify  . . . . . . . . . . . . . . . . . . . . . . .  14
     5.2.  Ed448ph and Ed448 . . . . . . . . . . . . . . . . . . . .  15
       5.2.1.  Modular Arithmetic  . . . . . . . . . . . . . . . . .  16
       5.2.2.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  16
       5.2.3.  Decoding  . . . . . . . . . . . . . . . . . . . . . .  16
       5.2.4.  Point Addition  . . . . . . . . . . . . . . . . . . .  17
       5.2.5.  Key Generation  . . . . . . . . . . . . . . . . . . .  18
       5.2.6.  Sign  . . . . . . . . . . . . . . . . . . . . . . . .  19
       5.2.7.  Verify  . . . . . . . . . . . . . . . . . . . . . . .  19
   6.  Ed25519 Python Illustration . . . . . . . . . . . . . . . . .  20
   7.  Test Vectors  . . . . . . . . . . . . . . . . . . . . . . . .  23
     7.1.  Test Vectors for Ed25519  . . . . . . . . . . . . . . . .  24
     7.2.  Test Vectors for Ed25519ctx . . . . . . . . . . . . . . .  27
     7.3.  Test Vectors for Ed25519ph  . . . . . . . . . . . . . . .  30
     7.4.  Test Vectors for Ed448  . . . . . . . . . . . . . . . . .  30
     7.5.  Test Vectors for Ed448ph  . . . . . . . . . . . . . . . .  38
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  40
     8.1.  Side-Channel Leaks  . . . . . . . . . . . . . . . . . . .  40
     8.2.  Randomness Considerations . . . . . . . . . . . . . . . .  40
     8.3.  Use of Contexts . . . . . . . . . . . . . . . . . . . . .  41
     8.4.  Signature Malleability  . . . . . . . . . . . . . . . . .  41
     8.5.  Choice of Signature Primitive . . . . . . . . . . . . . .  41
     8.6.  Mixing Different Prehashes  . . . . . . . . . . . . . . .  42
     8.7.  Signing Large Amounts of Data at Once . . . . . . . . . .  42
     8.8.  Multiplication by Cofactor in Verification  . . . . . . .  43
     8.9.  Use of SHAKE256 as a Hash Function  . . . . . . . . . . .  43
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  43
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  43
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  44




Josefsson & Liusvaara         Informational                     [Page 2]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   Appendix A.  Ed25519/Ed448 Python Library . . . . . . . . . . . .  46
   Appendix B.  Library Driver . . . . . . . . . . . . . . . . . . .  58
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  60
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  60

1.  Introduction

   The Edwards-curve Digital Signature Algorithm (EdDSA) is a variant of
   Schnorr's signature system with (possibly twisted) Edwards curves.
   EdDSA needs to be instantiated with certain parameters, and this
   document describes some recommended variants.

   To facilitate adoption of EdDSA in the Internet community, this
   document describes the signature scheme in an implementation-oriented
   way and provides sample code and test vectors.

   The advantages with EdDSA are as follows:

   1.  EdDSA provides high performance on a variety of platforms;

   2.  The use of a unique random number for each signature is not
       required;

   3.  It is more resilient to side-channel attacks;

   4.  EdDSA uses small public keys (32 or 57 bytes) and signatures (64
       or 114 bytes) for Ed25519 and Ed448, respectively;

   5.  The formulas are "complete", i.e., they are valid for all points
       on the curve, with no exceptions.  This obviates the need for
       EdDSA to perform expensive point validation on untrusted public
       values; and

   6.  EdDSA provides collision resilience, meaning that hash-function
       collisions do not break this system (only holds for PureEdDSA).

   The original EdDSA paper [EDDSA] and the generalized version
   described in "EdDSA for more curves" [EDDSA2] provide further
   background.  RFC 7748 [RFC7748] discusses specific curves, including
   Curve25519 [CURVE25519] and Ed448-Goldilocks [ED448].

   Ed25519 is intended to operate at around the 128-bit security level
   and Ed448 at around the 224-bit security level.  A sufficiently large
   quantum computer would be able to break both.  Reasonable projections
   of the abilities of classical computers conclude that Ed25519 is
   perfectly safe.  Ed448 is provided for those applications with
   relaxed performance requirements and where there is a desire to hedge
   against analytical attacks on elliptic curves.



Josefsson & Liusvaara         Informational                     [Page 3]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


2.  Notation and Conventions

   The following notation is used throughout the document:

   p              Denotes the prime number defining the underlying field

   GF(p)          Finite field with p elements

   x^y            x multiplied by itself y times

   B              Generator of the group or subgroup of interest

   [n]X           X added to itself n times

   h[i]           The i'th octet of octet string

   h_i            The i'th bit of h

   a || b         (bit-)string a concatenated with (bit-)string b

   a <= b         a is less than or equal to b

   a >= b         a is greater than or equal to b

   i+j            Sum of i and j

   i*j            Multiplication of i and j

   i-j            Subtraction of j from i

   i/j            Division of i by j

   i x j          Cartesian product of i and j

   (u,v)          Elliptic curve point with x-coordinate u and
                  y-coordinate v

   SHAKE256(x, y) The y first octets of SHAKE256 [FIPS202] output for
                  input x

   OCTET(x)       The octet with value x

   OLEN(x)        The number of octets in string x








Josefsson & Liusvaara         Informational                     [Page 4]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   dom2(x, y)     The blank octet string when signing or verifying
                  Ed25519.  Otherwise, the octet string: "SigEd25519 no
                  Ed25519 collisions" || octet(x) || octet(OLEN(y)) ||
                  y, where x is in range 0-255 and y is an octet string
                  of at most 255 octets.  "SigEd25519 no Ed25519
                  collisions" is in ASCII (32 octets).

   dom4(x, y)     The octet string "SigEd448" || octet(x) ||
                  octet(OLEN(y)) || y, where x is in range 0-255 and y
                  is an octet string of at most 255 octets.  "SigEd448"
                  is in ASCII (8 octets).

   Parentheses (i.e., '(' and ')') are used to group expressions, in
   order to avoid having the description depend on a binding order
   between operators.

   Bit strings are converted to octet strings by taking bits from left
   to right, packing those from the least significant bit of each octet
   to the most significant bit, and moving to the next octet when each
   octet fills up.  The conversion from octet string to bit string is
   the reverse of this process; for example, the 16-bit bit string

             b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15

   is converted into two octets x0 and x1 (in this order) as

             x0 = b7*128+b6*64+b5*32+b4*16+b3*8+b2*4+b1*2+b0
             x1 = b15*128+b14*64+b13*32+b12*16+b11*8+b10*4+b9*2+b8

   Little-endian encoding into bits places bits from left to right and
   from least significant to most significant.  If combined with
   bit-string-to-octet-string conversion defined above, this results in
   little-endian encoding into octets (if length is not a multiple of 8,
   the most significant bits of the last octet remain unused).

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

3.  EdDSA Algorithm

   EdDSA is a digital signature system with 11 parameters.

   The generic EdDSA digital signature system with its 11 input
   parameters is not intended to be implemented directly.  Choosing
   parameters is critical for secure and efficient operation.  Instead,
   you would implement a particular parameter choice for EdDSA (such as




Josefsson & Liusvaara         Informational                     [Page 5]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   Ed25519 or Ed448), sometimes slightly generalized to achieve code
   reuse to cover Ed25519 and Ed448.

   Therefore, a precise explanation of the generic EdDSA is thus not
   particularly useful for implementers.  For background and
   completeness, a succinct description of the generic EdDSA algorithm
   is given here.

   The definition of some parameters, such as n and c, may help to
   explain some steps of the algorithm that are not intuitive.

   This description closely follows [EDDSA2].

   EdDSA has 11 parameters:

   1.   An odd prime power p.  EdDSA uses an elliptic curve over the
        finite field GF(p).

   2.   An integer b with 2^(b-1) > p.  EdDSA public keys have exactly b
        bits, and EdDSA signatures have exactly 2*b bits.  b is
        recommended to be a multiple of 8, so public key and signature
        lengths are an integral number of octets.

   3.   A (b-1)-bit encoding of elements of the finite field GF(p).

   4.   A cryptographic hash function H producing 2*b-bit output.
        Conservative hash functions (i.e., hash functions where it is
        infeasible to create collisions) are recommended and do not have
        much impact on the total cost of EdDSA.

   5.   An integer c that is 2 or 3.  Secret EdDSA scalars are multiples
        of 2^c.  The integer c is the base-2 logarithm of the so-called
        cofactor.

   6.   An integer n with c <= n < b.  Secret EdDSA scalars have exactly
        n + 1 bits, with the top bit (the 2^n position) always set and
        the bottom c bits always cleared.

   7.   A non-square element d of GF(p).  The usual recommendation is to
        take it as the value nearest to zero that gives an acceptable
        curve.

   8.   A non-zero square element a of GF(p).  The usual recommendation
        for best performance is a = -1 if p mod 4 = 1, and a = 1 if
        p mod 4 = 3.

   9.   An element B != (0,1) of the set E = { (x,y) is a member of
        GF(p) x GF(p) such that a * x^2 + y^2 = 1 + d * x^2 * y^2 }.



Josefsson & Liusvaara         Informational                     [Page 6]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   10.  An odd prime L such that [L]B = 0 and 2^c * L = #E.  The number
        #E (the number of points on the curve) is part of the standard
        data provided for an elliptic curve E, or it can be computed as
        cofactor * order.

   11.  A "prehash" function PH.  PureEdDSA means EdDSA where PH is the
        identity function, i.e., PH(M) = M.  HashEdDSA means EdDSA where
        PH generates a short output, no matter how long the message is;
        for example, PH(M) = SHA-512(M).

   Points on the curve form a group under addition, (x3, y3) = (x1, y1)
   + (x2, y2), with the formulas

             x1 * y2 + x2 * y1                y1 * y2 - a * x1 * x2
   x3 = --------------------------,   y3 = ---------------------------
         1 + d * x1 * x2 * y1 * y2          1 - d * x1 * x2 * y1 * y2

   The neutral element in the group is (0,1).

   Unlike many other curves used for cryptographic applications, these
   formulas are "complete"; they are valid for all points on the curve,
   with no exceptions.  In particular, the denominators are non-zero for
   all input points.

   There are more efficient formulas, which are still complete, that use
   homogeneous coordinates to avoid the expensive modulo p inversions.
   See [Faster-ECC] and [Edwards-revisited].

3.1.  Encoding

   An integer 0 < S < L - 1 is encoded in little-endian form as a b-bit
   string ENC(S).

   An element (x,y) of E is encoded as a b-bit string called ENC(x,y),
   which is the (b-1)-bit encoding of y concatenated with one bit that
   is 1 if x is negative and 0 if x is not negative.

   The encoding of GF(p) is used to define "negative" elements of GF(p):
   specifically, x is negative if the (b-1)-bit encoding of x is
   lexicographically larger than the (b-1)-bit encoding of -x.

3.2.  Keys

   An EdDSA private key is a b-bit string k.  Let the hash H(k) =
   (h_0, h_1, ..., h_(2b-1)) determine an integer s, which is 2^n plus
   the sum of m = 2^i * h_i for all integer i, c <= i < n.  Let s
   determine the multiple A = [s]B.  The EdDSA public key is ENC(A).
   The bits h_b, ..., h_(2b-1) are used below during signing.



Josefsson & Liusvaara         Informational                     [Page 7]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


3.3.  Sign

   The EdDSA signature of a message M under a private key k is defined
   as the PureEdDSA signature of PH(M).  In other words, EdDSA simply
   uses PureEdDSA to sign PH(M).

   The PureEdDSA signature of a message M under a private key k is the
   2*b-bit string ENC(R) || ENC(S).  R and S are derived as follows.
   First define r = H(h_b || ... || h_(2b-1) || M) interpreting 2*b-bit
   strings in little-endian form as integers in {0, 1, ..., 2^(2*b) -
   1}.  Let R = [r]B and S = (r + H(ENC(R) || ENC(A) || PH(M)) * s) mod
   L.  The s used here is from the previous section.

3.4.  Verify

   To verify a PureEdDSA signature ENC(R) || ENC(S) on a message M under
   a public key ENC(A), proceed as follows.  Parse the inputs so that A
   and R are elements of E, and S is a member of the set {0, 1, ...,
   L-1}.  Compute h = H(ENC(R) || ENC(A) || M), and check the group
   equation [2^c * S] B = 2^c * R + [2^c * h] A in E.  The signature is
   rejected if parsing fails (including S being out of range) or if the
   group equation does not hold.

   EdDSA verification for a message M is defined as PureEdDSA
   verification for PH(M).

4.  PureEdDSA, HashEdDSA, and Naming

   One of the parameters of the EdDSA algorithm is the "prehash"
   function.  This may be the identity function, resulting in an
   algorithm called PureEdDSA, or a collision-resistant hash function
   such as SHA-512, resulting in an algorithm called HashEdDSA.

   Choosing which variant to use depends on which property is deemed to
   be more important between 1) collision resilience and 2) a single-
   pass interface for creating signatures.  The collision resilience
   property means EdDSA is secure even if it is feasible to compute
   collisions for the hash function.  The single-pass interface property
   means that only one pass over the input message is required to create
   a signature.  PureEdDSA requires two passes over the input.  Many
   existing APIs, protocols, and environments assume digital signature
   algorithms only need one pass over the input and may have API or
   bandwidth concerns supporting anything else.

   Note that single-pass verification is not possible with most uses of
   signatures, no matter which signature algorithm is chosen.  This is
   because most of the time, one can't process the message until the
   signature is validated, which needs a pass on the entire message.



Josefsson & Liusvaara         Informational                     [Page 8]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   This document specifies parameters resulting in the HashEdDSA
   variants Ed25519ph and Ed448ph and the PureEdDSA variants Ed25519 and
   Ed448.

5.  EdDSA Instances

   This section instantiates the general EdDSA algorithm for the
   edwards25519 and edwards448 curves, each for the PureEdDSA and
   HashEdDSA variants (plus a contextualized extension of the Ed25519
   scheme).  Thus, five different parameter sets are described.

5.1.  Ed25519ph, Ed25519ctx, and Ed25519

   Ed25519 is EdDSA instantiated with:

   +-----------+-------------------------------------------------------+
   | Parameter | Value                                                 |
   +-----------+-------------------------------------------------------+
   |     p     | p of edwards25519 in [RFC7748] (i.e., 2^255 - 19)     |
   |     b     | 256                                                   |
   |  encoding | 255-bit little-endian encoding of {0, 1, ..., p-1}    |
   |  of GF(p) |                                                       |
   |    H(x)   | SHA-512(dom2(phflag,context)||x) [RFC6234]            |
   |     c     | base 2 logarithm of cofactor of edwards25519 in       |
   |           | [RFC7748] (i.e., 3)                                   |
   |     n     | 254                                                   |
   |     d     | d of edwards25519 in [RFC7748] (i.e., -121665/121666  |
   |           | = 370957059346694393431380835087545651895421138798432 |
   |           | 19016388785533085940283555)                           |
   |     a     | -1                                                    |
   |     B     | (X(P),Y(P)) of edwards25519 in [RFC7748] (i.e., (1511 |
   |           | 22213495354007725011514095885315114540126930418572060 |
   |           | 46113283949847762202, 4631683569492647816942839400347 |
   |           | 5163141307993866256225615783033603165251855960))      |
   |     L     | order of edwards25519 in [RFC7748] (i.e.,             |
   |           | 2^252+27742317777372353535851937790883648493).        |
   |   PH(x)   | x (i.e., the identity function)                       |
   +-----------+-------------------------------------------------------+

                      Table 1: Parameters of Ed25519

   For Ed25519, dom2(f,c) is the empty string.  The phflag value is
   irrelevant.  The context (if present at all) MUST be empty.  This
   causes the scheme to be one and the same with the Ed25519 scheme
   published earlier.

   For Ed25519ctx, phflag=0.  The context input SHOULD NOT be empty.




Josefsson & Liusvaara         Informational                     [Page 9]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   For Ed25519ph, phflag=1 and PH is SHA512 instead.  That is, the input
   is hashed using SHA-512 before signing with Ed25519.

   Value of context is set by the signer and verifier (maximum of 255
   octets; the default is empty string, except for Ed25519, which can't
   have context) and has to match octet by octet for verification to be
   successful.

   The curve used is equivalent to Curve25519 [CURVE25519], under a
   change of coordinates, which means that the difficulty of the
   discrete logarithm problem is the same as for Curve25519.

5.1.1.  Modular Arithmetic

   For advice on how to implement arithmetic modulo p = 2^255 - 19
   efficiently and securely, see Curve25519 [CURVE25519].  For inversion
   modulo p, it is recommended to use the identity x^-1 = x^(p-2) (mod
   p).  Inverting zero should never happen, as it would require invalid
   input, which would have been detected before, or would be a
   calculation error.

   For point decoding or "decompression", square roots modulo p are
   needed.  They can be computed using the Tonelli-Shanks algorithm or
   the special case for p = 5 (mod 8).  To find a square root of a,
   first compute the candidate root x = a^((p+3)/8) (mod p).  Then there
   are three cases:

      x^2 = a (mod p).  Then x is a square root.

      x^2 = -a (mod p).  Then 2^((p-1)/4) * x is a square root.

      a is not a square modulo p.

5.1.2.  Encoding

   All values are coded as octet strings, and integers are coded using
   little-endian convention, i.e., a 32-octet string h h[0],...h[31]
   represents the integer h[0] + 2^8 * h[1] + ... + 2^248 * h[31].

   A curve point (x,y), with coordinates in the range 0 <= x,y < p, is
   coded as follows.  First, encode the y-coordinate as a little-endian
   string of 32 octets.  The most significant bit of the final octet is
   always zero.  To form the encoding of the point, copy the least
   significant bit of the x-coordinate to the most significant bit of
   the final octet.






Josefsson & Liusvaara         Informational                    [Page 10]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


5.1.3.  Decoding

   Decoding a point, given as a 32-octet string, is a little more
   complicated.

   1.  First, interpret the string as an integer in little-endian
       representation.  Bit 255 of this number is the least significant
       bit of the x-coordinate and denote this value x_0.  The
       y-coordinate is recovered simply by clearing this bit.  If the
       resulting value is >= p, decoding fails.

   2.  To recover the x-coordinate, the curve equation implies
       x^2 = (y^2 - 1) / (d y^2 + 1) (mod p).  The denominator is always
       non-zero mod p.  Let u = y^2 - 1 and v = d y^2 + 1.  To compute
       the square root of (u/v), the first step is to compute the
       candidate root x = (u/v)^((p+3)/8).  This can be done with the
       following trick, using a single modular powering for both the
       inversion of v and the square root:

                          (p+3)/8      3        (p-5)/8
                 x = (u/v)        = u v  (u v^7)         (mod p)

   3.  Again, there are three cases:

       1.  If v x^2 = u (mod p), x is a square root.

       2.  If v x^2 = -u (mod p), set x <-- x * 2^((p-1)/4), which is a
           square root.

       3.  Otherwise, no square root exists for modulo p, and decoding
           fails.

   4.  Finally, use the x_0 bit to select the right square root.  If
       x = 0, and x_0 = 1, decoding fails.  Otherwise, if x_0 != x mod
       2, set x <-- p - x.  Return the decoded point (x,y).

5.1.4.  Point Addition

   For point addition, the following method is recommended.  A point
   (x,y) is represented in extended homogeneous coordinates (X, Y, Z,
   T), with x = X/Z, y = Y/Z, x * y = T/Z.

   The neutral point is (0,1), or equivalently in extended homogeneous
   coordinates (0, Z, Z, 0) for any non-zero Z.







Josefsson & Liusvaara         Informational                    [Page 11]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   The following formulas for adding two points, (x3,y3) =
   (x1,y1)+(x2,y2), on twisted Edwards curves with a=-1, square a, and
   non-square d are described in Section 3.1 of [Edwards-revisited] and
   in [EFD-TWISTED-ADD].  They are complete, i.e., they work for any
   pair of valid input points.

                 A = (Y1-X1)*(Y2-X2)
                 B = (Y1+X1)*(Y2+X2)
                 C = T1*2*d*T2
                 D = Z1*2*Z2
                 E = B-A
                 F = D-C
                 G = D+C
                 H = B+A
                 X3 = E*F
                 Y3 = G*H
                 T3 = E*H
                 Z3 = F*G

   For point doubling, (x3,y3) = (x1,y1)+(x1,y1), one could just
   substitute equal points in the above (because of completeness, such
   substitution is valid) and observe that four multiplications turn
   into squares.  However, using the formulas described in Section 3.2
   of [Edwards-revisited] and in [EFD-TWISTED-DBL] saves a few smaller
   operations.

                 A = X1^2
                 B = Y1^2
                 C = 2*Z1^2
                 H = A+B
                 E = H-(X1+Y1)^2
                 G = A-B
                 F = C+G
                 X3 = E*F
                 Y3 = G*H
                 T3 = E*H
                 Z3 = F*G














Josefsson & Liusvaara         Informational                    [Page 12]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


5.1.5.  Key Generation

   The private key is 32 octets (256 bits, corresponding to b) of
   cryptographically secure random data.  See [RFC4086] for a discussion
   about randomness.

   The 32-byte public key is generated by the following steps.

   1.  Hash the 32-byte private key using SHA-512, storing the digest in
       a 64-octet large buffer, denoted h.  Only the lower 32 bytes are
       used for generating the public key.

   2.  Prune the buffer: The lowest three bits of the first octet are
       cleared, the highest bit of the last octet is cleared, and the
       second highest bit of the last octet is set.

   3.  Interpret the buffer as the little-endian integer, forming a
       secret scalar s.  Perform a fixed-base scalar multiplication
       [s]B.

   4.  The public key A is the encoding of the point [s]B.  First,
       encode the y-coordinate (in the range 0 <= y < p) as a little-
       endian string of 32 octets.  The most significant bit of the
       final octet is always zero.  To form the encoding of the point
       [s]B, copy the least significant bit of the x coordinate to the
       most significant bit of the final octet.  The result is the
       public key.

5.1.6.  Sign

   The inputs to the signing procedure is the private key, a 32-octet
   string, and a message M of arbitrary size.  For Ed25519ctx and
   Ed25519ph, there is additionally a context C of at most 255 octets
   and a flag F, 0 for Ed25519ctx and 1 for Ed25519ph.

   1.  Hash the private key, 32 octets, using SHA-512.  Let h denote the
       resulting digest.  Construct the secret scalar s from the first
       half of the digest, and the corresponding public key A, as
       described in the previous section.  Let prefix denote the second
       half of the hash digest, h[32],...,h[63].

   2.  Compute SHA-512(dom2(F, C) || prefix || PH(M)), where M is the
       message to be signed.  Interpret the 64-octet digest as a little-
       endian integer r.

   3.  Compute the point [r]B.  For efficiency, do this by first
       reducing r modulo L, the group order of B.  Let the string R be
       the encoding of this point.



Josefsson & Liusvaara         Informational                    [Page 13]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   4.  Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the
       64-octet digest as a little-endian integer k.

   5.  Compute S = (r + k * s) mod L.  For efficiency, again reduce k
       modulo L first.

   6.  Form the signature of the concatenation of R (32 octets) and the
       little-endian encoding of S (32 octets; the three most
       significant bits of the final octet are always zero).

5.1.7.  Verify

   1.  To verify a signature on a message M using public key A, with F
       being 0 for Ed25519ctx, 1 for Ed25519ph, and if Ed25519ctx or
       Ed25519ph is being used, C being the context, first split the
       signature into two 32-octet halves.  Decode the first half as a
       point R, and the second half as an integer S, in the range
       0 <= s < L.  Decode the public key A as point A'.  If any of the
       decodings fail (including S being out of range), the signature is
       invalid.

   2.  Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the
       64-octet digest as a little-endian integer k.

   3.  Check the group equation [8][S]B = [8]R + [8][k]A'.  It's
       sufficient, but not required, to instead check [S]B = R + [k]A'.

























Josefsson & Liusvaara         Informational                    [Page 14]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


5.2.  Ed448ph and Ed448

   Ed448 is EdDSA instantiated with:

   +-----------+-------------------------------------------------------+
   | Parameter | Value                                                 |
   +-----------+-------------------------------------------------------+
   |     p     | p of edwards448 in [RFC7748] (i.e., 2^448 - 2^224 -   |
   |           | 1)                                                    |
   |     b     | 456                                                   |
   |  encoding | 455-bit little-endian encoding of {0, 1, ..., p-1}    |
   |  of GF(p) |                                                       |
   |    H(x)   | SHAKE256(dom4(phflag,context)||x, 114)                |
   |   phflag  | 0                                                     |
   |     c     | base 2 logarithm of cofactor of edwards448 in         |
   |           | [RFC7748] (i.e., 2)                                   |
   |     n     | 447                                                   |
   |     d     | d of edwards448 in [RFC7748] (i.e., -39081)           |
   |     a     | 1                                                     |
   |     B     | (X(P),Y(P)) of edwards448 in [RFC7748] (i.e., (224580 |
   |           | 04029592430018760433409989603624678964163256413424612 |
   |           | 54616869504154674060329090291928693579532825780320751 |
   |           | 46446173674602635247710, 2988192100784814926760179304 |
   |           | 43930673437544040154080242095928241372331506189835876 |
   |           | 00353687865541878473398230323350346250053154506283266 |
   |           | 0))                                                   |
   |     L     | order of edwards448 in [RFC7748] (i.e., 2^446 - 13818 |
   |           | 06680989511535200738674851542688033669247488217860989 |
   |           | 4547503885).                                          |
   |   PH(x)   | x (i.e., the identity function)                       |
   +-----------+-------------------------------------------------------+

                       Table 2: Parameters of Ed448

   Ed448ph is the same but with PH being SHAKE256(x, 64) and phflag
   being 1, i.e., the input is hashed before signing with Ed448 with a
   hash constant modified.

   Value of context is set by signer and verifier (maximum of 255
   octets; the default is empty string) and has to match octet by octet
   for verification to be successful.

   The curve is equivalent to Ed448-Goldilocks under change of the
   basepoint, which preserves difficulty of the discrete logarithm.







Josefsson & Liusvaara         Informational                    [Page 15]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


5.2.1.  Modular Arithmetic

   For advice on how to implement arithmetic modulo p = 2^448 - 2^224 -
   1 efficiently and securely, see [ED448].  For inversion modulo p, it
   is recommended to use the identity x^-1 = x^(p-2) (mod p).  Inverting
   zero should never happen, as it would require invalid input, which
   would have been detected before, or would be a calculation error.

   For point decoding or "decompression", square roots modulo p are
   needed.  They can be computed by first computing candidate root
   x = a ^ (p+1)/4 (mod p) and then checking if x^2 = a.  If it is, then
   x is the square root of a; if it isn't, then a does not have a square
   root.

5.2.2.  Encoding

   All values are coded as octet strings, and integers are coded using
   little-endian convention, i.e., a 57-octet string h h[0],...h[56]
   represents the integer h[0] + 2^8 * h[1] + ... + 2^448 * h[56].

   A curve point (x,y), with coordinates in the range 0 <= x,y < p, is
   coded as follows.  First, encode the y-coordinate as a little-endian
   string of 57 octets.  The final octet is always zero.  To form the
   encoding of the point, copy the least significant bit of the
   x-coordinate to the most significant bit of the final octet.

5.2.3.  Decoding

   Decoding a point, given as a 57-octet string, is a little more
   complicated.

   1.  First, interpret the string as an integer in little-endian
       representation.  Bit 455 of this number is the least significant
       bit of the x-coordinate, and denote this value x_0.  The
       y-coordinate is recovered simply by clearing this bit.  If the
       resulting value is >= p, decoding fails.

   2.  To recover the x-coordinate, the curve equation implies
       x^2 = (y^2 - 1) / (d y^2 - 1) (mod p).  The denominator is always
       non-zero mod p.  Let u = y^2 - 1 and v = d y^2 - 1.  To compute
       the square root of (u/v), the first step is to compute the
       candidate root x = (u/v)^((p+1)/4).  This can be done using the
       following trick, to use a single modular powering for both the
       inversion of v and the square root:

                          (p+1)/4    3            (p-3)/4
                 x = (u/v)        = u  v (u^5 v^3)         (mod p)




Josefsson & Liusvaara         Informational                    [Page 16]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   3.  If v * x^2 = u, the recovered x-coordinate is x.  Otherwise, no
       square root exists, and the decoding fails.

   4.  Finally, use the x_0 bit to select the right square root.  If
       x = 0, and x_0 = 1, decoding fails.  Otherwise, if x_0 != x mod
       2, set x <-- p - x.  Return the decoded point (x,y).

5.2.4.  Point Addition

   For point addition, the following method is recommended.  A point
   (x,y) is represented in projective coordinates (X, Y, Z), with
   x = X/Z, y = Y/Z.

   The neutral point is (0,1), or equivalently in projective coordinates
   (0, Z, Z) for any non-zero Z.

   The following formulas for adding two points, (x3,y3) =
   (x1,y1)+(x2,y2) on untwisted Edwards curve (i.e., a=1) with non-
   square d, are described in Section 4 of [Faster-ECC] and in
   [EFD-ADD].  They are complete, i.e., they work for any pair of valid
   input points.

                 A = Z1*Z2
                 B = A^2
                 C = X1*X2
                 D = Y1*Y2
                 E = d*C*D
                 F = B-E
                 G = B+E
                 H = (X1+Y1)*(X2+Y2)
                 X3 = A*F*(H-C-D)
                 Y3 = A*G*(D-C)
                 Z3 = F*G


















Josefsson & Liusvaara         Informational                    [Page 17]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   Again, similar to the other curve, doubling formulas can be obtained
   by substituting equal points, turning four multiplications into
   squares.  However, this is not even nearly optimal; the following
   formulas described in Section 4 of [Faster-ECC] and in [EFD-DBL] save
   multiple multiplications.

                 B = (X1+Y1)^2
                 C = X1^2
                 D = Y1^2
                 E = C+D
                 H = Z1^2
                 J = E-2*H
                 X3 = (B-E)*J
                 Y3 = E*(C-D)
                 Z3 = E*J

5.2.5.  Key Generation

   The private key is 57 octets (456 bits, corresponding to b) of
   cryptographically secure random data.  See [RFC4086] for a discussion
   about randomness.

   The 57-byte public key is generated by the following steps:

   1.  Hash the 57-byte private key using SHAKE256(x, 114), storing the
       digest in a 114-octet large buffer, denoted h.  Only the lower 57
       bytes are used for generating the public key.

   2.  Prune the buffer: The two least significant bits of the first
       octet are cleared, all eight bits the last octet are cleared, and
       the highest bit of the second to last octet is set.

   3.  Interpret the buffer as the little-endian integer, forming a
       secret scalar s.  Perform a known-base-point scalar
       multiplication [s]B.

   4.  The public key A is the encoding of the point [s]B.  First encode
       the y-coordinate (in the range 0 <= y < p) as a little-endian
       string of 57 octets.  The most significant bit of the final octet
       is always zero.  To form the encoding of the point [s]B, copy the
       least significant bit of the x coordinate to the most significant
       bit of the final octet.  The result is the public key.









Josefsson & Liusvaara         Informational                    [Page 18]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


5.2.6.  Sign

   The inputs to the signing procedure is the private key, a 57-octet
   string, a flag F, which is 0 for Ed448, 1 for Ed448ph, context C of
   at most 255 octets, and a message M of arbitrary size.

   1.  Hash the private key, 57 octets, using SHAKE256(x, 114).  Let h
       denote the resulting digest.  Construct the secret scalar s from
       the first half of the digest, and the corresponding public key A,
       as described in the previous section.  Let prefix denote the
       second half of the hash digest, h[57],...,h[113].

   2.  Compute SHAKE256(dom4(F, C) || prefix || PH(M), 114), where M is
       the message to be signed, F is 1 for Ed448ph, 0 for Ed448, and C
       is the context to use.  Interpret the 114-octet digest as a
       little-endian integer r.

   3.  Compute the point [r]B.  For efficiency, do this by first
       reducing r modulo L, the group order of B.  Let the string R be
       the encoding of this point.

   4.  Compute SHAKE256(dom4(F, C) || R || A || PH(M), 114), and
       interpret the 114-octet digest as a little-endian integer k.

   5.  Compute S = (r + k * s) mod L.  For efficiency, again reduce k
       modulo L first.

   6.  Form the signature of the concatenation of R (57 octets) and the
       little-endian encoding of S (57 octets; the ten most significant
       bits of the final octets are always zero).

5.2.7.  Verify

   1.  To verify a signature on a message M using context C and public
       key A, with F being 0 for Ed448 and 1 for Ed448ph, first split
       the signature into two 57-octet halves.  Decode the first half as
       a point R, and the second half as an integer S, in the range 0 <=
       s < L.  Decode the public key A as point A'.  If any of the
       decodings fail (including S being out of range), the signature is
       invalid.

   2.  Compute SHAKE256(dom4(F, C) || R || A || PH(M), 114), and
       interpret the 114-octet digest as a little-endian integer k.

   3.  Check the group equation [4][S]B = [4]R + [4][k]A'.  It's
       sufficient, but not required, to instead check [S]B = R + [k]A'.





Josefsson & Liusvaara         Informational                    [Page 19]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


6.  Ed25519 Python Illustration

   The rest of this section describes how Ed25519 can be implemented in
   Python (version 3.2 or later) for illustration.  See Appendix A for
   the complete implementation and Appendix B for a test-driver to run
   it through some test vectors.

   Note that this code is not intended for production as it is not
   proven to be correct for all inputs, nor does it protect against
   side-channel attacks.  The purpose is to illustrate the algorithm to
   help implementers with their own implementation.

## First, some preliminaries that will be needed.

import hashlib

def sha512(s):
    return hashlib.sha512(s).digest()

# Base field Z_p
p = 2**255 - 19

def modp_inv(x):
    return pow(x, p-2, p)

# Curve constant
d = -121665 * modp_inv(121666) % p

# Group order
q = 2**252 + 27742317777372353535851937790883648493

def sha512_modq(s):
    return int.from_bytes(sha512(s), "little") % q

## Then follows functions to perform point operations.

# Points are represented as tuples (X, Y, Z, T) of extended
# coordinates, with x = X/Z, y = Y/Z, x*y = T/Z

def point_add(P, Q):
    A, B = (P[1]-P[0]) * (Q[1]-Q[0]) % p, (P[1]+P[0]) * (Q[1]+Q[0]) % p;
    C, D = 2 * P[3] * Q[3] * d % p, 2 * P[2] * Q[2] % p;
    E, F, G, H = B-A, D-C, D+C, B+A;
    return (E*F, G*H, F*G, E*H);







Josefsson & Liusvaara         Informational                    [Page 20]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


# Computes Q = s * Q
def point_mul(s, P):
    Q = (0, 1, 1, 0)  # Neutral element
    while s > 0:
        if s & 1:
            Q = point_add(Q, P)
        P = point_add(P, P)
        s >>= 1
    return Q

def point_equal(P, Q):
    # x1 / z1 == x2 / z2  <==>  x1 * z2 == x2 * z1
    if (P[0] * Q[2] - Q[0] * P[2]) % p != 0:
        return False
    if (P[1] * Q[2] - Q[1] * P[2]) % p != 0:
        return False
    return True

## Now follows functions for point compression.

# Square root of -1
modp_sqrt_m1 = pow(2, (p-1) // 4, p)

# Compute corresponding x-coordinate, with low bit corresponding to
# sign, or return None on failure
def recover_x(y, sign):
    if y >= p:
        return None
    x2 = (y*y-1) * modp_inv(d*y*y+1)
    if x2 == 0:
        if sign:
            return None
        else:
            return 0

    # Compute square root of x2
    x = pow(x2, (p+3) // 8, p)
    if (x*x - x2) % p != 0:
        x = x * modp_sqrt_m1 % p
    if (x*x - x2) % p != 0:
        return None

    if (x & 1) != sign:
        x = p - x
    return x






Josefsson & Liusvaara         Informational                    [Page 21]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


# Base point
g_y = 4 * modp_inv(5) % p
g_x = recover_x(g_y, 0)
G = (g_x, g_y, 1, g_x * g_y % p)

def point_compress(P):
    zinv = modp_inv(P[2])
    x = P[0] * zinv % p
    y = P[1] * zinv % p
    return int.to_bytes(y | ((x & 1) << 255), 32, "little")

def point_decompress(s):
    if len(s) != 32:
        raise Exception("Invalid input length for decompression")
    y = int.from_bytes(s, "little")
    sign = y >> 255
    y &= (1 << 255) - 1

    x = recover_x(y, sign)
    if x is None:
        return None
    else:
        return (x, y, 1, x*y % p)

## These are functions for manipulating the private key.

def secret_expand(secret):
    if len(secret) != 32:
        raise Exception("Bad size of private key")
    h = sha512(secret)
    a = int.from_bytes(h[:32], "little")
    a &= (1 << 254) - 8
    a |= (1 << 254)
    return (a, h[32:])

def secret_to_public(secret):
    (a, dummy) = secret_expand(secret)
    return point_compress(point_mul(a, G))













Josefsson & Liusvaara         Informational                    [Page 22]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


## The signature function works as below.

def sign(secret, msg):
    a, prefix = secret_expand(secret)
    A = point_compress(point_mul(a, G))
    r = sha512_modq(prefix + msg)
    R = point_mul(r, G)
    Rs = point_compress(R)
    h = sha512_modq(Rs + A + msg)
    s = (r + h * a) % q
    return Rs + int.to_bytes(s, 32, "little")

## And finally the verification function.

def verify(public, msg, signature):
    if len(public) != 32:
        raise Exception("Bad public key length")
    if len(signature) != 64:
        Exception("Bad signature length")
    A = point_decompress(public)
    if not A:
        return False
    Rs = signature[:32]
    R = point_decompress(Rs)
    if not R:
        return False
    s = int.from_bytes(signature[32:], "little")
    if s >= q: return False
    h = sha512_modq(Rs + public + msg)
    sB = point_mul(s, G)
    hA = point_mul(h, A)
    return point_equal(sB, point_add(R, hA))

7.  Test Vectors

   This section contains test vectors for Ed25519ph, Ed25519ctx,
   Ed448ph, Ed25519, and Ed448.

   Each section contains a sequence of test vectors.  The octets are hex
   encoded, and whitespace is inserted for readability.  Ed25519,
   Ed25519ctx, and Ed25519ph private and public keys are 32 octets;
   signatures are 64 octets.  Ed448 and Ed448ph private and public keys
   are 57 octets; signatures are 114 octets.  Messages are of arbitrary
   length.  If the context is non-empty, it is given as 1-255 octets.







Josefsson & Liusvaara         Informational                    [Page 23]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


7.1.  Test Vectors for Ed25519

   These test vectors are taken from [ED25519-TEST-VECTORS] (but we
   removed the public key as a suffix of the private key and removed the
   message from the signature) and [ED25519-LIBGCRYPT-TEST-VECTORS].

   -----TEST 1

   ALGORITHM:
   Ed25519

   SECRET KEY:
   9d61b19deffd5a60ba844af492ec2cc4
   4449c5697b326919703bac031cae7f60

   PUBLIC KEY:
   d75a980182b10ab7d54bfed3c964073a
   0ee172f3daa62325af021a68f707511a

   MESSAGE (length 0 bytes):

   SIGNATURE:
   e5564300c360ac729086e2cc806e828a
   84877f1eb8e5d974d873e06522490155
   5fb8821590a33bacc61e39701cf9b46b
   d25bf5f0595bbe24655141438e7a100b

   -----TEST 2

   ALGORITHM:
   Ed25519

   SECRET KEY:
   4ccd089b28ff96da9db6c346ec114e0f
   5b8a319f35aba624da8cf6ed4fb8a6fb

   PUBLIC KEY:
   3d4017c3e843895a92b70aa74d1b7ebc
   9c982ccf2ec4968cc0cd55f12af4660c

   MESSAGE (length 1 byte):
   72

   SIGNATURE:
   92a009a9f0d4cab8720e820b5f642540
   a2b27b5416503f8fb3762223ebdb69da
   085ac1e43e15996e458f3613d0f11d8c
   387b2eaeb4302aeeb00d291612bb0c00



Josefsson & Liusvaara         Informational                    [Page 24]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   -----TEST 3

   ALGORITHM:
   Ed25519

   SECRET KEY:
   c5aa8df43f9f837bedb7442f31dcb7b1
   66d38535076f094b85ce3a2e0b4458f7

   PUBLIC KEY:
   fc51cd8e6218a1a38da47ed00230f058
   0816ed13ba3303ac5deb911548908025

   MESSAGE (length 2 bytes):
   af82

   SIGNATURE:
   6291d657deec24024827e69c3abe01a3
   0ce548a284743a445e3680d7db5ac3ac
   18ff9b538d16f290ae67f760984dc659
   4a7c15e9716ed28dc027beceea1ec40a

   -----TEST 1024

   ALGORITHM:
   Ed25519

   SECRET KEY:
   f5e5767cf153319517630f226876b86c
   8160cc583bc013744c6bf255f5cc0ee5

   PUBLIC KEY:
   278117fc144c72340f67d0f2316e8386
   ceffbf2b2428c9c51fef7c597f1d426e

   MESSAGE (length 1023 bytes):
   08b8b2b733424243760fe426a4b54908
   632110a66c2f6591eabd3345e3e4eb98
   fa6e264bf09efe12ee50f8f54e9f77b1
   e355f6c50544e23fb1433ddf73be84d8
   79de7c0046dc4996d9e773f4bc9efe57
   38829adb26c81b37c93a1b270b20329d
   658675fc6ea534e0810a4432826bf58c
   941efb65d57a338bbd2e26640f89ffbc
   1a858efcb8550ee3a5e1998bd177e93a
   7363c344fe6b199ee5d02e82d522c4fe
   ba15452f80288a821a579116ec6dad2b
   3b310da903401aa62100ab5d1a36553e



Josefsson & Liusvaara         Informational                    [Page 25]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   06203b33890cc9b832f79ef80560ccb9
   a39ce767967ed628c6ad573cb116dbef
   efd75499da96bd68a8a97b928a8bbc10
   3b6621fcde2beca1231d206be6cd9ec7
   aff6f6c94fcd7204ed3455c68c83f4a4
   1da4af2b74ef5c53f1d8ac70bdcb7ed1
   85ce81bd84359d44254d95629e9855a9
   4a7c1958d1f8ada5d0532ed8a5aa3fb2
   d17ba70eb6248e594e1a2297acbbb39d
   502f1a8c6eb6f1ce22b3de1a1f40cc24
   554119a831a9aad6079cad88425de6bd
   e1a9187ebb6092cf67bf2b13fd65f270
   88d78b7e883c8759d2c4f5c65adb7553
   878ad575f9fad878e80a0c9ba63bcbcc
   2732e69485bbc9c90bfbd62481d9089b
   eccf80cfe2df16a2cf65bd92dd597b07
   07e0917af48bbb75fed413d238f5555a
   7a569d80c3414a8d0859dc65a46128ba
   b27af87a71314f318c782b23ebfe808b
   82b0ce26401d2e22f04d83d1255dc51a
   ddd3b75a2b1ae0784504df543af8969b
   e3ea7082ff7fc9888c144da2af58429e
   c96031dbcad3dad9af0dcbaaaf268cb8
   fcffead94f3c7ca495e056a9b47acdb7
   51fb73e666c6c655ade8297297d07ad1
   ba5e43f1bca32301651339e22904cc8c
   42f58c30c04aafdb038dda0847dd988d
   cda6f3bfd15c4b4c4525004aa06eeff8
   ca61783aacec57fb3d1f92b0fe2fd1a8
   5f6724517b65e614ad6808d6f6ee34df
   f7310fdc82aebfd904b01e1dc54b2927
   094b2db68d6f903b68401adebf5a7e08
   d78ff4ef5d63653a65040cf9bfd4aca7
   984a74d37145986780fc0b16ac451649
   de6188a7dbdf191f64b5fc5e2ab47b57
   f7f7276cd419c17a3ca8e1b939ae49e4
   88acba6b965610b5480109c8b17b80e1
   b7b750dfc7598d5d5011fd2dcc5600a3
   2ef5b52a1ecc820e308aa342721aac09
   43bf6686b64b2579376504ccc493d97e
   6aed3fb0f9cd71a43dd497f01f17c0e2
   cb3797aa2a2f256656168e6c496afc5f
   b93246f6b1116398a346f1a641f3b041
   e989f7914f90cc2c7fff357876e506b5
   0d334ba77c225bc307ba537152f3f161
   0e4eafe595f6d9d90d11faa933a15ef1
   369546868a7f3a45a96768d40fd9d034
   12c091c6315cf4fde7cb68606937380d



Josefsson & Liusvaara         Informational                    [Page 26]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   b2eaaa707b4c4185c32eddcdd306705e
   4dc1ffc872eeee475a64dfac86aba41c
   0618983f8741c5ef68d3a101e8a3b8ca
   c60c905c15fc910840b94c00a0b9d0

   SIGNATURE:
   0aab4c900501b3e24d7cdf4663326a3a
   87df5e4843b2cbdb67cbf6e460fec350
   aa5371b1508f9f4528ecea23c436d94b
   5e8fcd4f681e30a6ac00a9704a188a03

   -----TEST SHA(abc)

   ALGORITHM:
   Ed25519

   SECRET KEY:
   833fe62409237b9d62ec77587520911e
   9a759cec1d19755b7da901b96dca3d42

   PUBLIC KEY:
   ec172b93ad5e563bf4932c70e1245034
   c35467ef2efd4d64ebf819683467e2bf

   MESSAGE (length 64 bytes):
   ddaf35a193617abacc417349ae204131
   12e6fa4e89a97ea20a9eeee64b55d39a
   2192992a274fc1a836ba3c23a3feebbd
   454d4423643ce80e2a9ac94fa54ca49f

   SIGNATURE:
   dc2a4459e7369633a52b1bf277839a00
   201009a3efbf3ecb69bea2186c26b589
   09351fc9ac90b3ecfdfbc7c66431e030
   3dca179c138ac17ad9bef1177331a704
   -----

7.2.  Test Vectors for Ed25519ctx

   -----foo

   ALGORITHM:
   Ed25519ctx

   SECRET KEY:
   0305334e381af78f141cb666f6199f57
   bc3495335a256a95bd2a55bf546663f6




Josefsson & Liusvaara         Informational                    [Page 27]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   PUBLIC KEY:
   dfc9425e4f968f7f0c29f0259cf5f9ae
   d6851c2bb4ad8bfb860cfee0ab248292

   MESSAGE (length 16 bytes):
   f726936d19c800494e3fdaff20b276a8

   CONTEXT:
   666f6f

   SIGNATURE:
   55a4cc2f70a54e04288c5f4cd1e45a7b
   b520b36292911876cada7323198dd87a
   8b36950b95130022907a7fb7c4e9b2d5
   f6cca685a587b4b21f4b888e4e7edb0d

   -----bar

   ALGORITHM:
   Ed25519ctx

   SECRET KEY:
   0305334e381af78f141cb666f6199f57
   bc3495335a256a95bd2a55bf546663f6

   PUBLIC KEY:
   dfc9425e4f968f7f0c29f0259cf5f9ae
   d6851c2bb4ad8bfb860cfee0ab248292

   MESSAGE (length 16 bytes):
   f726936d19c800494e3fdaff20b276a8

   CONTEXT:
   626172

   SIGNATURE:
   fc60d5872fc46b3aa69f8b5b4351d580
   8f92bcc044606db097abab6dbcb1aee3
   216c48e8b3b66431b5b186d1d28f8ee1
   5a5ca2df6668346291c2043d4eb3e90d

   -----foo2

   ALGORITHM:
   Ed25519ctx






Josefsson & Liusvaara         Informational                    [Page 28]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SECRET KEY:
   0305334e381af78f141cb666f6199f57
   bc3495335a256a95bd2a55bf546663f6

   PUBLIC KEY:
   dfc9425e4f968f7f0c29f0259cf5f9ae
   d6851c2bb4ad8bfb860cfee0ab248292

   MESSAGE (length 16 bytes):
   508e9e6882b979fea900f62adceaca35

   CONTEXT:
   666f6f

   SIGNATURE:
   8b70c1cc8310e1de20ac53ce28ae6e72
   07f33c3295e03bb5c0732a1d20dc6490
   8922a8b052cf99b7c4fe107a5abb5b2c
   4085ae75890d02df26269d8945f84b0b

   -----foo3

   ALGORITHM:
   Ed25519ctx

   SECRET KEY:
   ab9c2853ce297ddab85c993b3ae14bca
   d39b2c682beabc27d6d4eb20711d6560

   PUBLIC KEY:
   0f1d1274943b91415889152e893d80e9
   3275a1fc0b65fd71b4b0dda10ad7d772

   MESSAGE (length 16 bytes):
   f726936d19c800494e3fdaff20b276a8

   CONTEXT:
   666f6f

   SIGNATURE:
   21655b5f1aa965996b3f97b3c849eafb
   a922a0a62992f73b3d1b73106a84ad85
   e9b86a7b6005ea868337ff2d20a7f5fb
   d4cd10b0be49a68da2b2e0dc0ad8960f
   -----






Josefsson & Liusvaara         Informational                    [Page 29]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


7.3.  Test Vectors for Ed25519ph

   -----TEST abc

   ALGORITHM:
   Ed25519ph

   SECRET KEY:
   833fe62409237b9d62ec77587520911e
   9a759cec1d19755b7da901b96dca3d42

   PUBLIC KEY:
   ec172b93ad5e563bf4932c70e1245034
   c35467ef2efd4d64ebf819683467e2bf

   MESSAGE (length 3 bytes):
   616263

   SIGNATURE:
   98a70222f0b8121aa9d30f813d683f80
   9e462b469c7ff87639499bb94e6dae41
   31f85042463c2a355a2003d062adf5aa
   a10b8c61e636062aaad11c2a26083406
   -----

7.4.  Test Vectors for Ed448

   -----Blank

   ALGORITHM:
   Ed448

   SECRET KEY:
   6c82a562cb808d10d632be89c8513ebf
   6c929f34ddfa8c9f63c9960ef6e348a3
   528c8a3fcc2f044e39a3fc5b94492f8f
   032e7549a20098f95b

   PUBLIC KEY:
   5fd7449b59b461fd2ce787ec616ad46a
   1da1342485a70e1f8a0ea75d80e96778
   edf124769b46c7061bd6783df1e50f6c
   d1fa1abeafe8256180

   MESSAGE (length 0 bytes):






Josefsson & Liusvaara         Informational                    [Page 30]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SIGNATURE:
   533a37f6bbe457251f023c0d88f976ae
   2dfb504a843e34d2074fd823d41a591f
   2b233f034f628281f2fd7a22ddd47d78
   28c59bd0a21bfd3980ff0d2028d4b18a
   9df63e006c5d1c2d345b925d8dc00b41
   04852db99ac5c7cdda8530a113a0f4db
   b61149f05a7363268c71d95808ff2e65
   2600

   -----1 octet

   ALGORITHM:
   Ed448

   SECRET KEY:
   c4eab05d357007c632f3dbb48489924d
   552b08fe0c353a0d4a1f00acda2c463a
   fbea67c5e8d2877c5e3bc397a659949e
   f8021e954e0a12274e

   PUBLIC KEY:
   43ba28f430cdff456ae531545f7ecd0a
   c834a55d9358c0372bfa0c6c6798c086
   6aea01eb00742802b8438ea4cb82169c
   235160627b4c3a9480

   MESSAGE (length 1 byte):
   03

   SIGNATURE:
   26b8f91727bd62897af15e41eb43c377
   efb9c610d48f2335cb0bd0087810f435
   2541b143c4b981b7e18f62de8ccdf633
   fc1bf037ab7cd779805e0dbcc0aae1cb
   cee1afb2e027df36bc04dcecbf154336
   c19f0af7e0a6472905e799f1953d2a0f
   f3348ab21aa4adafd1d234441cf807c0
   3a00

   -----1 octet (with context)

   ALGORITHM:
   Ed448







Josefsson & Liusvaara         Informational                    [Page 31]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SECRET KEY:
   c4eab05d357007c632f3dbb48489924d
   552b08fe0c353a0d4a1f00acda2c463a
   fbea67c5e8d2877c5e3bc397a659949e
   f8021e954e0a12274e

   PUBLIC KEY:
   43ba28f430cdff456ae531545f7ecd0a
   c834a55d9358c0372bfa0c6c6798c086
   6aea01eb00742802b8438ea4cb82169c
   235160627b4c3a9480

   MESSAGE (length 1 byte):
   03

   CONTEXT:
   666f6f

   SIGNATURE:
   d4f8f6131770dd46f40867d6fd5d5055
   de43541f8c5e35abbcd001b32a89f7d2
   151f7647f11d8ca2ae279fb842d60721
   7fce6e042f6815ea000c85741de5c8da
   1144a6a1aba7f96de42505d7a7298524
   fda538fccbbb754f578c1cad10d54d0d
   5428407e85dcbc98a49155c13764e66c
   3c00

   -----11 octets

   ALGORITHM:
   Ed448

   SECRET KEY:
   cd23d24f714274e744343237b93290f5
   11f6425f98e64459ff203e8985083ffd
   f60500553abc0e05cd02184bdb89c4cc
   d67e187951267eb328

   PUBLIC KEY:
   dcea9e78f35a1bf3499a831b10b86c90
   aac01cd84b67a0109b55a36e9328b1e3
   65fce161d71ce7131a543ea4cb5f7e9f
   1d8b00696447001400

   MESSAGE (length 11 bytes):
   0c3e544074ec63b0265e0c




Josefsson & Liusvaara         Informational                    [Page 32]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SIGNATURE:
   1f0a8888ce25e8d458a21130879b840a
   9089d999aaba039eaf3e3afa090a09d3
   89dba82c4ff2ae8ac5cdfb7c55e94d5d
   961a29fe0109941e00b8dbdeea6d3b05
   1068df7254c0cdc129cbe62db2dc957d
   bb47b51fd3f213fb8698f064774250a5
   028961c9bf8ffd973fe5d5c206492b14
   0e00

   -----12 octets

   ALGORITHM:
   Ed448

   SECRET KEY:
   258cdd4ada32ed9c9ff54e63756ae582
   fb8fab2ac721f2c8e676a72768513d93
   9f63dddb55609133f29adf86ec9929dc
   cb52c1c5fd2ff7e21b

   PUBLIC KEY:
   3ba16da0c6f2cc1f30187740756f5e79
   8d6bc5fc015d7c63cc9510ee3fd44adc
   24d8e968b6e46e6f94d19b945361726b
   d75e149ef09817f580

   MESSAGE (length 12 bytes):
   64a65f3cdedcdd66811e2915

   SIGNATURE:
   7eeeab7c4e50fb799b418ee5e3197ff6
   bf15d43a14c34389b59dd1a7b1b85b4a
   e90438aca634bea45e3a2695f1270f07
   fdcdf7c62b8efeaf00b45c2c96ba457e
   b1a8bf075a3db28e5c24f6b923ed4ad7
   47c3c9e03c7079efb87cb110d3a99861
   e72003cbae6d6b8b827e4e6c143064ff
   3c00

   -----13 octets

   ALGORITHM:
   Ed448







Josefsson & Liusvaara         Informational                    [Page 33]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SECRET KEY:
   7ef4e84544236752fbb56b8f31a23a10
   e42814f5f55ca037cdcc11c64c9a3b29
   49c1bb60700314611732a6c2fea98eeb
   c0266a11a93970100e

   PUBLIC KEY:
   b3da079b0aa493a5772029f0467baebe
   e5a8112d9d3a22532361da294f7bb381
   5c5dc59e176b4d9f381ca0938e13c6c0
   7b174be65dfa578e80

   MESSAGE (length 13 bytes):
   64a65f3cdedcdd66811e2915e7

   SIGNATURE:
   6a12066f55331b6c22acd5d5bfc5d712
   28fbda80ae8dec26bdd306743c5027cb
   4890810c162c027468675ecf645a8317
   6c0d7323a2ccde2d80efe5a1268e8aca
   1d6fbc194d3f77c44986eb4ab4177919
   ad8bec33eb47bbb5fc6e28196fd1caf5
   6b4e7e0ba5519234d047155ac727a105
   3100

   -----64 octets

   ALGORITHM:
   Ed448

   SECRET KEY:
   d65df341ad13e008567688baedda8e9d
   cdc17dc024974ea5b4227b6530e339bf
   f21f99e68ca6968f3cca6dfe0fb9f4fa
   b4fa135d5542ea3f01

   PUBLIC KEY:
   df9705f58edbab802c7f8363cfe5560a
   b1c6132c20a9f1dd163483a26f8ac53a
   39d6808bf4a1dfbd261b099bb03b3fb5
   0906cb28bd8a081f00

   MESSAGE (length 64 bytes):
   bd0f6a3747cd561bdddf4640a332461a
   4a30a12a434cd0bf40d766d9c6d458e5
   512204a30c17d1f50b5079631f64eb31
   12182da3005835461113718d1a5ef944




Josefsson & Liusvaara         Informational                    [Page 34]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SIGNATURE:
   554bc2480860b49eab8532d2a533b7d5
   78ef473eeb58c98bb2d0e1ce488a98b1
   8dfde9b9b90775e67f47d4a1c3482058
   efc9f40d2ca033a0801b63d45b3b722e
   f552bad3b4ccb667da350192b61c508c
   f7b6b5adadc2c8d9a446ef003fb05cba
   5f30e88e36ec2703b349ca229c267083
   3900

   -----256 octets

   ALGORITHM:
   Ed448

   SECRET KEY:
   2ec5fe3c17045abdb136a5e6a913e32a
   b75ae68b53d2fc149b77e504132d3756
   9b7e766ba74a19bd6162343a21c8590a
   a9cebca9014c636df5

   PUBLIC KEY:
   79756f014dcfe2079f5dd9e718be4171
   e2ef2486a08f25186f6bff43a9936b9b
   fe12402b08ae65798a3d81e22e9ec80e
   7690862ef3d4ed3a00

   MESSAGE (length 256 bytes):
   15777532b0bdd0d1389f636c5f6b9ba7
   34c90af572877e2d272dd078aa1e567c
   fa80e12928bb542330e8409f31745041
   07ecd5efac61ae7504dabe2a602ede89
   e5cca6257a7c77e27a702b3ae39fc769
   fc54f2395ae6a1178cab4738e543072f
   c1c177fe71e92e25bf03e4ecb72f47b6
   4d0465aaea4c7fad372536c8ba516a60
   39c3c2a39f0e4d832be432dfa9a706a6
   e5c7e19f397964ca4258002f7c0541b5
   90316dbc5622b6b2a6fe7a4abffd9610
   5eca76ea7b98816af0748c10df048ce0
   12d901015a51f189f3888145c03650aa
   23ce894c3bd889e030d565071c59f409
   a9981b51878fd6fc110624dcbcde0bf7
   a69ccce38fabdf86f3bef6044819de11







Josefsson & Liusvaara         Informational                    [Page 35]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SIGNATURE:
   c650ddbb0601c19ca11439e1640dd931
   f43c518ea5bea70d3dcde5f4191fe53f
   00cf966546b72bcc7d58be2b9badef28
   743954e3a44a23f880e8d4f1cfce2d7a
   61452d26da05896f0a50da66a239a8a1
   88b6d825b3305ad77b73fbac0836ecc6
   0987fd08527c1a8e80d5823e65cafe2a
   3d00

   -----1023 octets

   ALGORITHM:
   Ed448

   SECRET KEY:
   872d093780f5d3730df7c212664b37b8
   a0f24f56810daa8382cd4fa3f77634ec
   44dc54f1c2ed9bea86fafb7632d8be19
   9ea165f5ad55dd9ce8

   PUBLIC KEY:
   a81b2e8a70a5ac94ffdbcc9badfc3feb
   0801f258578bb114ad44ece1ec0e799d
   a08effb81c5d685c0c56f64eecaef8cd
   f11cc38737838cf400

   MESSAGE (length 1023 bytes):
   6ddf802e1aae4986935f7f981ba3f035
   1d6273c0a0c22c9c0e8339168e675412
   a3debfaf435ed651558007db4384b650
   fcc07e3b586a27a4f7a00ac8a6fec2cd
   86ae4bf1570c41e6a40c931db27b2faa
   15a8cedd52cff7362c4e6e23daec0fbc
   3a79b6806e316efcc7b68119bf46bc76
   a26067a53f296dafdbdc11c77f7777e9
   72660cf4b6a9b369a6665f02e0cc9b6e
   dfad136b4fabe723d2813db3136cfde9
   b6d044322fee2947952e031b73ab5c60
   3349b307bdc27bc6cb8b8bbd7bd32321
   9b8033a581b59eadebb09b3c4f3d2277
   d4f0343624acc817804728b25ab79717
   2b4c5c21a22f9c7839d64300232eb66e
   53f31c723fa37fe387c7d3e50bdf9813
   a30e5bb12cf4cd930c40cfb4e1fc6225
   92a49588794494d56d24ea4b40c89fc0
   596cc9ebb961c8cb10adde976a5d602b
   1c3f85b9b9a001ed3c6a4d3b1437f520



Josefsson & Liusvaara         Informational                    [Page 36]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   96cd1956d042a597d561a596ecd3d173
   5a8d570ea0ec27225a2c4aaff26306d1
   526c1af3ca6d9cf5a2c98f47e1c46db9
   a33234cfd4d81f2c98538a09ebe76998
   d0d8fd25997c7d255c6d66ece6fa56f1
   1144950f027795e653008f4bd7ca2dee
   85d8e90f3dc315130ce2a00375a318c7
   c3d97be2c8ce5b6db41a6254ff264fa6
   155baee3b0773c0f497c573f19bb4f42
   40281f0b1f4f7be857a4e59d416c06b4
   c50fa09e1810ddc6b1467baeac5a3668
   d11b6ecaa901440016f389f80acc4db9
   77025e7f5924388c7e340a732e554440
   e76570f8dd71b7d640b3450d1fd5f041
   0a18f9a3494f707c717b79b4bf75c984
   00b096b21653b5d217cf3565c9597456
   f70703497a078763829bc01bb1cbc8fa
   04eadc9a6e3f6699587a9e75c94e5bab
   0036e0b2e711392cff0047d0d6b05bd2
   a588bc109718954259f1d86678a579a3
   120f19cfb2963f177aeb70f2d4844826
   262e51b80271272068ef5b3856fa8535
   aa2a88b2d41f2a0e2fda7624c2850272
   ac4a2f561f8f2f7a318bfd5caf969614
   9e4ac824ad3460538fdc25421beec2cc
   6818162d06bbed0c40a387192349db67
   a118bada6cd5ab0140ee273204f628aa
   d1c135f770279a651e24d8c14d75a605
   9d76b96a6fd857def5e0b354b27ab937
   a5815d16b5fae407ff18222c6d1ed263
   be68c95f32d908bd895cd76207ae7264
   87567f9a67dad79abec316f683b17f2d
   02bf07e0ac8b5bc6162cf94697b3c27c
   d1fea49b27f23ba2901871962506520c
   392da8b6ad0d99f7013fbc06c2c17a56
   9500c8a7696481c1cd33e9b14e40b82e
   79a5f5db82571ba97bae3ad3e0479515
   bb0e2b0f3bfcd1fd33034efc6245eddd
   7ee2086ddae2600d8ca73e214e8c2b0b
   db2b047c6a464a562ed77b73d2d841c4
   b34973551257713b753632efba348169
   abc90a68f42611a40126d7cb21b58695
   568186f7e569d2ff0f9e745d0487dd2e
   b997cafc5abf9dd102e62ff66cba87







Josefsson & Liusvaara         Informational                    [Page 37]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   SIGNATURE:
   e301345a41a39a4d72fff8df69c98075
   a0cc082b802fc9b2b6bc503f926b65bd
   df7f4c8f1cb49f6396afc8a70abe6d8a
   ef0db478d4c6b2970076c6a0484fe76d
   76b3a97625d79f1ce240e7c576750d29
   5528286f719b413de9ada3e8eb78ed57
   3603ce30d8bb761785dc30dbc320869e
   1a00
   -----

7.5.  Test Vectors for Ed448ph

   -----TEST abc

   ALGORITHM:
   Ed448ph

   SECRET KEY:
   833fe62409237b9d62ec77587520911e
   9a759cec1d19755b7da901b96dca3d42
   ef7822e0d5104127dc05d6dbefde69e3
   ab2cec7c867c6e2c49

   PUBLIC KEY:
   259b71c19f83ef77a7abd26524cbdb31
   61b590a48f7d17de3ee0ba9c52beb743
   c09428a131d6b1b57303d90d8132c276
   d5ed3d5d01c0f53880

   MESSAGE (length 3 bytes):
   616263

   SIGNATURE:
   822f6901f7480f3d5f562c592994d969
   3602875614483256505600bbc281ae38
   1f54d6bce2ea911574932f52a4e6cadd
   78769375ec3ffd1b801a0d9b3f4030cd
   433964b6457ea39476511214f97469b5
   7dd32dbc560a9a94d00bff07620464a3
   ad203df7dc7ce360c3cd3696d9d9fab9
   0f00









Josefsson & Liusvaara         Informational                    [Page 38]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   -----TEST abc (with context)

   ALGORITHM:
   Ed448ph

   SECRET KEY:
   833fe62409237b9d62ec77587520911e
   9a759cec1d19755b7da901b96dca3d42
   ef7822e0d5104127dc05d6dbefde69e3
   ab2cec7c867c6e2c49

   PUBLIC KEY:
   259b71c19f83ef77a7abd26524cbdb31
   61b590a48f7d17de3ee0ba9c52beb743
   c09428a131d6b1b57303d90d8132c276
   d5ed3d5d01c0f53880

   MESSAGE (length 3 bytes):
   616263

   CONTEXT:
   666f6f

   SIGNATURE:
   c32299d46ec8ff02b54540982814dce9
   a05812f81962b649d528095916a2aa48
   1065b1580423ef927ecf0af5888f90da
   0f6a9a85ad5dc3f280d91224ba9911a3
   653d00e484e2ce232521481c8658df30
   4bb7745a73514cdb9bf3e15784ab7128
   4f8d0704a608c54a6b62d97beb511d13
   2100
   -----


















Josefsson & Liusvaara         Informational                    [Page 39]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


8.  Security Considerations

8.1.  Side-Channel Leaks

   For implementations performing signatures, secrecy of the private key
   is fundamental.  It is possible to protect against some side-channel
   attacks by ensuring that the implementation executes exactly the same
   sequence of instructions and performs exactly the same memory
   accesses, for any value of the private key.

   To make an implementation side-channel silent in this way, the modulo
   p arithmetic must not use any data-dependent branches, e.g., related
   to carry propagation.  Side-channel silent point addition is
   straightforward, thanks to the unified formulas.

   Scalar multiplication, multiplying a point by an integer, needs some
   additional effort to implement in a side-channel silent manner.  One
   simple approach is to implement a side-channel silent conditional
   assignment, and use it together with the binary algorithm to examine
   one bit of the integer at a time.

   Compared to other signature schemes, avoiding data-dependent branches
   is easier due to side-channel silent modulo p arithmetic being easier
   (with recommended curves) and having complete addition formulas
   instead of having a number of special cases.

   Note that the example implementations in this document do not attempt
   to be side-channel silent.

8.2.  Randomness Considerations

   EdDSA signatures are deterministic.  This protects against attacks
   arising from signing with bad randomness; the effects of which can,
   depending on the algorithm, range up to full private key compromise.
   It can be surprisingly hard to ensure good-quality random numbers,
   and there have been numerous security failures relating to this.

   Obviously, private key generation requires randomness, but due to the
   fact that the private key is hashed before use, a few missing bits of
   entropy doesn't constitute a disaster.

   The basic signature verification is also deterministic.  However,
   some speedups by verifying multiple signatures at once do require
   random numbers.







Josefsson & Liusvaara         Informational                    [Page 40]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


8.3.  Use of Contexts

   Contexts can be used to separate uses of the protocol between
   different protocols (which is very hard to reliably do otherwise) and
   between different uses within the same protocol.  However, the
   following SHOULD be kept in mind when using this facility:

      The context SHOULD be a constant string specified by the protocol
      using it.  It SHOULD NOT incorporate variable elements from the
      message itself.

      Contexts SHOULD NOT be used opportunistically, as that kind of use
      is very error prone.  If contexts are used, one SHOULD require all
      signature schemes available for use in that purpose support
      contexts.

      Contexts are an extra input, which percolate out of APIs; as such,
      even if the signature scheme supports contexts, those may not be
      available for use.  This problem is compounded by the fact that
      many times the application is not invoking the signing and
      verification functions directly but via some other protocol.

8.4.  Signature Malleability

   Some systems assume signatures are not malleable: that is, given a
   valid signature for some message under some key, the attacker can't
   produce another valid signature for the same message and key.

   Ed25519 and Ed448 signatures are not malleable due to the
   verification check that decoded S is smaller than l.  Without this
   check, one can add a multiple of l into a scalar part and still pass
   signature verification, resulting in malleable signatures.

8.5.  Choice of Signature Primitive

   Ed25519 and Ed25519ph have a nominal strength of 128 bits, whereas
   Ed448 and Ed448ph have the strength of 224.  While the lower strength
   is sufficient for the foreseeable future, the higher level brings
   some defense against possible future cryptographic advances.  Both
   are demolished by quantum computers just about the same.

   The Ed25519ph and Ed448ph variants are prehashed.  This is mainly
   useful for interoperation with legacy APIs, since in most of the
   cases, either the amount of data signed is not large or the protocol
   is in the position to do digesting in ways better than just
   prehashing (e.g., tree hashing or splitting the data).  The





Josefsson & Liusvaara         Informational                    [Page 41]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   prehashing also makes the functions greatly more vulnerable to
   weaknesses in hash functions used.  These variants SHOULD NOT be
   used.

   Ed25519ctx and Ed448 have contexts.  However, this is balanced by the
   problems noted in Section 8.3 about contexts.

   On the implementation front, Ed25519 is widely implemented and has
   many high-quality implementations.  The others have much worse
   support.

   In summary, if a high 128-bit security level is enough, use of
   Ed25519 is RECOMMENDED; otherwise, Ed448 is RECOMMENDED.

8.6.  Mixing Different Prehashes

   The schemes described in this document are designed to be resistant
   to mixing prehashes.  That is, it is infeasible to find a message
   that verifies using the same signature under another scheme, even if
   the original signed message was chosen.  Thus, one can use the same
   key pair for Ed25519, Ed25519ctx, and Ed25519ph and correspondingly
   with Ed448 and Ed448ph.

   The "SigEd25519 no Ed25519 collisions" constant is chosen to be a
   textual string such that it does not decode as a point.  Because the
   inner hash input in the Ed25519 signature always starts with a valid
   point, there is no way trivial collision can be constructed.  In the
   case of seed hash, trivial collisions are so unlikely, even with an
   attacker choosing all inputs, that it is much more probable that
   something else goes catastrophically wrong.

8.7.  Signing Large Amounts of Data at Once

   Avoid signing large amounts of data at once (where "large" depends on
   the expected verifier).  In particular, unless the underlying
   protocol does not require it, the receiver MUST buffer the entire
   message (or enough information to reconstruct it, e.g., compressed or
   encrypted version) to be verified.

   This is needed because most of the time, it is unsafe to process
   unverified data, and verifying the signature makes a pass through the
   whole message, causing ultimately at least two passes through.

   As an API consideration, this means that any Initialize Update
   Finalize (IFU) verification interface is prone to misuse.






Josefsson & Liusvaara         Informational                    [Page 42]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   It is a bad idea to modify Ed25519 or Ed448 signing to be able to
   create valid Ed25519/Ed448 signatures using an IUF interface with
   only constant buffering.  Pretty much any error in such would cause
   catastrophic security failure.

8.8.  Multiplication by Cofactor in Verification

   The given verification formulas for both Ed25519 and Ed448 multiply
   points by the cofactor.  While this is not strictly necessary for
   security (in fact, any signature that meets the non-multiplied
   equation will satisfy the multiplied one), in some applications it is
   undesirable for implementations to disagree about the exact set of
   valid signatures.  Such disagreements could open up, e.g.,
   fingerprinting attacks.

8.9.  Use of SHAKE256 as a Hash Function

   Ed448 uses SHAKE256 as a hash function, even if SHAKE256 is
   specifically defined not to be a hash function.

   The first potentially troublesome property is that shorter outputs
   are prefixes of longer ones.  This is acceptable because output
   lengths are fixed.

   The second potentially troublesome property is failing to meet
   standard hash security notions (especially with preimages).  However,
   the estimated 256-bit security level against collisions and preimages
   is sufficient to pair with a 224-bit level elliptic curve.

9.  References

9.1.  Normative References

   [FIPS202]  National Institute of Standards and Technology, "SHA-3
              Standard: Permutation-Based Hash and Extendable-Output
              Functions", FIPS PUB 202, August 2015,
              <http://dx.doi.org/10.6028/NIST.FIPS.202>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, DOI
              10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <http://www.rfc-editor.org/info/rfc6234>.




Josefsson & Liusvaara         Informational                    [Page 43]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <http://www.rfc-editor.org/info/rfc7748>.

9.2.  Informative References

   [CURVE25519]
              Bernstein, D., "Curve25519: new Diffie-Hellman speed
              records", DOI 10.1007/11745853_14, February 2006,
              <http://cr.yp.to/ecdh.html>.

   [ED25519-LIBGCRYPT-TEST-VECTORS]
              Koch, W., "Ed25519 Libgcrypt test vectors", July 2014,
              <http://git.gnupg.org/cgi-bin/
              gitweb.cgi?p=libgcrypt.git;a=blob;f=tests/t-ed25519.inp;
              h=e13566f826321eece65e02c593bc7d885b3dbe23;hb=refs/
              heads/master>.

   [ED25519-TEST-VECTORS]
              Bernstein, D., Duif, N., Lange, T., Schwabe, P., and B.
              Yang, "Ed25519 test vectors", July 2011,
              <http://ed25519.cr.yp.to/python/sign.input>.

   [ED448]    Hamburg, M., "Ed448-Goldilocks, a new elliptic curve",
              June 2015, <http://eprint.iacr.org/2015/625>.

   [EDDSA]    Bernstein, D., Duif, N., Lange, T., Schwabe, P., and B.
              Yang, "High-speed high-security signatures",
              DOI 10.1007/978-3-642-23951-9_9, September 2011,
              <http://ed25519.cr.yp.to/ed25519-20110926.pdf>.

   [EDDSA2]   Bernstein, D., Josefsson, S., Lange, T., Schwabe, P., and
              B. Yang, "EdDSA for more curves", July 2015,
              <http://ed25519.cr.yp.to/eddsa-20150704.pdf>.

   [Edwards-revisited]
              Hisil, H., Wong, K., Carter, G., and E. Dawson, "Twisted
              Edwards Curves Revisited",
              DOI 10.1007/978-3-540-89255-7_20, December 2008,
              <http://eprint.iacr.org/2008/522>.

   [EFD-ADD]  Bernstein, D. and T. Lange, "Projective coordinates for
              Edwards curves", The 'add-2007-bl' addition formulas,
              2007, <http://www.hyperelliptic.org/EFD/g1p/
              auto-edwards-projective.html#addition-add-2007-bl>.






Josefsson & Liusvaara         Informational                    [Page 44]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


   [EFD-DBL]  Bernstein, D. and T. Lange, "Projective coordinates for
              Edwards curves", The 'dbl-2007-bl' doubling formulas,
              2007, <http://www.hyperelliptic.org/EFD/g1p/
              auto-edwards-projective.html#doubling-dbl-2007-bl>.

   [EFD-TWISTED-ADD]
              Hisil, H., Wong, K., Carter, G., and E. Dawson, "Extended
              coordinates with a=-1 for twisted Edwards curves", The
              'add-2008-hwcd-3' addition formulas, December 2008,
              <http://www.hyperelliptic.org/EFD/g1p/
              auto-twisted-extended-1.html#addition-add-2008-hwcd-3>.

   [EFD-TWISTED-DBL]
              Hisil, H., Wong, K., Carter, G., and E. Dawson, "Extended
              coordinates with a=-1 for twisted Edwards curves", The
              'dbl-2008-hwcd' doubling formulas, December 2008,
              <http://www.hyperelliptic.org/EFD/g1p/
              auto-twisted-extended-1.html#doubling-dbl-2008-hwcd>.

   [Faster-ECC]
              Bernstein, D. and T. Lange, "Faster addition and doubling
              on elliptic curves", DOI 10.1007/978-3-540-76900-2_3,
              July 2007, <http://eprint.iacr.org/2007/286>.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <http://www.rfc-editor.org/info/rfc4086>.























Josefsson & Liusvaara         Informational                    [Page 45]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


Appendix A.  Ed25519/Ed448 Python Library

   Below is an example implementation of Ed25519/Ed448 written in
   Python; version 3.2 or higher is required.

   Note: This code is not intended for production.  Although it should
   produce correct results for every input, it is slow and makes no
   attempt to avoid side-channel attacks.

import hashlib;
import os;

#Compute candidate square root of x modulo p, with p = 3 (mod 4).
def sqrt4k3(x,p): return pow(x,(p + 1)//4,p)

#Compute candidate square root of x modulo p, with p = 5 (mod 8).
def sqrt8k5(x,p):
    y = pow(x,(p+3)//8,p)
    #If the square root exists, it is either y or y*2^(p-1)/4.
    if (y * y) % p == x % p: return y
    else:
        z = pow(2,(p - 1)//4,p)
        return (y * z) % p

#Decode a hexadecimal string representation of the integer.
def hexi(s): return int.from_bytes(bytes.fromhex(s),byteorder="big")

#Rotate a word x by b places to the left.
def rol(x,b): return ((x << b) | (x >> (64 - b))) & (2**64-1)

#From little endian.
def from_le(s): return int.from_bytes(s, byteorder="little")

#Do the SHA-3 state transform on state s.
def sha3_transform(s):
    ROTATIONS = [0,1,62,28,27,36,44,6,55,20,3,10,43,25,39,41,45,15,\
                 21,8,18,2,61,56,14]
    PERMUTATION = [1,6,9,22,14,20,2,12,13,19,23,15,4,24,21,8,16,5,3,\
                   18,17,11,7,10]
    RC = [0x0000000000000001,0x0000000000008082,0x800000000000808a,\
          0x8000000080008000,0x000000000000808b,0x0000000080000001,\
          0x8000000080008081,0x8000000000008009,0x000000000000008a,\
          0x0000000000000088,0x0000000080008009,0x000000008000000a,\
          0x000000008000808b,0x800000000000008b,0x8000000000008089,\
          0x8000000000008003,0x8000000000008002,0x8000000000000080,\
          0x000000000000800a,0x800000008000000a,0x8000000080008081,\
          0x8000000000008080,0x0000000080000001,0x8000000080008008]




Josefsson & Liusvaara         Informational                    [Page 46]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    for rnd in range(0,24):
        #AddColumnParity (Theta)
        c = [0]*5;
        d = [0]*5;
        for i in range(0,25): c[i%5]^=s[i]
        for i in range(0,5): d[i]=c[(i+4)%5]^rol(c[(i+1)%5],1)
        for i in range(0,25): s[i]^=d[i%5]
        #RotateWords (Rho)
        for i in range(0,25): s[i]=rol(s[i],ROTATIONS[i])
        #PermuteWords (Pi)
        t = s[PERMUTATION[0]]
        for i in range(0,len(PERMUTATION)-1):
            s[PERMUTATION[i]]=s[PERMUTATION[i+1]]
        s[PERMUTATION[-1]]=t;
        #NonlinearMixRows (Chi)
        for i in range(0,25,5):
            t=[s[i],s[i+1],s[i+2],s[i+3],s[i+4],s[i],s[i+1]]
            for j in range(0,5): s[i+j]=t[j]^((~t[j+1])&(t[j+2]))
        #AddRoundConstant (Iota)
        s[0]^=RC[rnd]

#Reinterpret octet array b to word array and XOR it to state s.
def reinterpret_to_words_and_xor(s,b):
    for j in range(0,len(b)//8):
        s[j]^=from_le(b[8*j:][:8])

#Reinterpret word array w to octet array and return it.
def reinterpret_to_octets(w):
    mp=bytearray()
    for j in range(0,len(w)):
        mp+=w[j].to_bytes(8,byteorder="little")
    return mp



















Josefsson & Liusvaara         Informational                    [Page 47]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


#(semi-)generic SHA-3 implementation
def sha3_raw(msg,r_w,o_p,e_b):
    r_b=8*r_w
    s=[0]*25
    #Handle whole blocks.
    idx=0
    blocks=len(msg)//r_b
    for i in range(0,blocks):
        reinterpret_to_words_and_xor(s,msg[idx:][:r_b])
        idx+=r_b
        sha3_transform(s)
    #Handle last block padding.
    m=bytearray(msg[idx:])
    m.append(o_p)
    while len(m) < r_b: m.append(0)
    m[len(m)-1]|=128
    #Handle padded last block.
    reinterpret_to_words_and_xor(s,m)
    sha3_transform(s)
    #Output.
    out = bytearray()
    while len(out)<e_b:
        out+=reinterpret_to_octets(s[:r_w])
        sha3_transform(s)
    return out[:e_b]

#Implementation of SHAKE256 functions.
def shake256(msg,olen): return sha3_raw(msg,17,31,olen)























Josefsson & Liusvaara         Informational                    [Page 48]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


#A (prime) field element.
class Field:
    #Construct number x (mod p).
    def __init__(self,x,p):
        self.__x=x%p
        self.__p=p
    #Check that fields of self and y are the same.
    def __check_fields(self,y):
        if type(y) is not Field or self.__p!=y.__p:
            raise ValueError("Fields don't match")
    #Field addition.  The fields must match.
    def __add__(self,y):
        self.__check_fields(y)
        return Field(self.__x+y.__x,self.__p)
    #Field subtraction.  The fields must match.
    def __sub__(self,y):
        self.__check_fields(y)
        return Field(self.__p+self.__x-y.__x,self.__p)
    #Field negation.
    def __neg__(self):
        return Field(self.__p-self.__x,self.__p)
    #Field multiplication.  The fields must match.
    def __mul__(self,y):
        self.__check_fields(y)
        return Field(self.__x*y.__x,self.__p)
    #Field division.  The fields must match.
    def __truediv__(self,y):
        return self*y.inv()
    #Field inverse (inverse of 0 is 0).
    def inv(self):
        return Field(pow(self.__x,self.__p-2,self.__p),self.__p)
    #Field square root.  Returns none if square root does not exist.
    #Note: not presently implemented for p mod 8 = 1 case.
    def sqrt(self):
        #Compute candidate square root.
        if self.__p%4==3: y=sqrt4k3(self.__x,self.__p)
        elif self.__p%8==5: y=sqrt8k5(self.__x,self.__p)
        else: raise NotImplementedError("sqrt(_,8k+1)")
        _y=Field(y,self.__p);
        #Check square root candidate valid.
        return _y if _y*_y==self else None
    #Make the field element with the same field as this, but
    #with a different value.
    def make(self,ival): return Field(ival,self.__p)
    #Is the field element the additive identity?
    def iszero(self): return self.__x==0
    #Are field elements equal?
    def __eq__(self,y): return self.__x==y.__x and self.__p==y.__p



Josefsson & Liusvaara         Informational                    [Page 49]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    #Are field elements not equal?
    def __ne__(self,y): return not (self==y)
    #Serialize number to b-1 bits.
    def tobytes(self,b):
        return self.__x.to_bytes(b//8,byteorder="little")
    #Unserialize number from bits.
    def frombytes(self,x,b):
        rv=from_le(x)%(2**(b-1))
        return Field(rv,self.__p) if rv<self.__p else None
    #Compute sign of number, 0 or 1.  The sign function
    #has the following property:
    #sign(x) = 1 - sign(-x) if x != 0.
    def sign(self): return self.__x%2

#A point on (twisted) Edwards curve.
class EdwardsPoint:
    #base_field = None
    #x = None
    #y = None
    #z = None
    def initpoint(self, x, y):
        self.x=x
        self.y=y
        self.z=self.base_field.make(1)
    def decode_base(self,s,b):
        #Check that point encoding is the correct length.
        if len(s)!=b//8: return (None,None)
        #Extract signbit.
        xs=s[(b-1)//8]>>((b-1)&7)
        #Decode y.  If this fails, fail.
        y = self.base_field.frombytes(s,b)
        if y is None: return (None,None)
        #Try to recover x.  If it does not exist, or if zero and xs
        #are wrong, fail.
        x=self.solve_x2(y).sqrt()
        if x is None or (x.iszero() and xs!=x.sign()):
            return (None,None)
        #If sign of x isn't correct, flip it.
        if x.sign()!=xs: x=-x
        # Return the constructed point.
        return (x,y)
    def encode_base(self,b):
        xp,yp=self.x/self.z,self.y/self.z
        #Encode y.
        s=bytearray(yp.tobytes(b))
        #Add sign bit of x to encoding.
        if xp.sign()!=0: s[(b-1)//8]|=1<<(b-1)%8
        return s



Josefsson & Liusvaara         Informational                    [Page 50]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    def __mul__(self,x):
        r=self.zero_elem()
        s=self
        while x > 0:
            if (x%2)>0:
                r=r+s
            s=s.double()
            x=x//2
        return r
    #Check that two points are equal.
    def __eq__(self,y):
        #Need to check x1/z1 == x2/z2 and similarly for y, so cross
        #multiply to eliminate divisions.
        xn1=self.x*y.z
        xn2=y.x*self.z
        yn1=self.y*y.z
        yn2=y.y*self.z
        return xn1==xn2 and yn1==yn2
    #Check if two points are not equal.
    def __ne__(self,y): return not (self==y)

#A point on Edwards25519.
class Edwards25519Point(EdwardsPoint):
    #Create a new point on the curve.
    base_field=Field(1,2**255-19)
    d=-base_field.make(121665)/base_field.make(121666)
    f0=base_field.make(0)
    f1=base_field.make(1)
    xb=base_field.make(hexi("216936D3CD6E53FEC0A4E231FDD6DC5C692CC76"+\
        "09525A7B2C9562D608F25D51A"))
    yb=base_field.make(hexi("666666666666666666666666666666666666666"+\
        "6666666666666666666666658"))
    #The standard base point.
    @staticmethod
    def stdbase():
        return Edwards25519Point(Edwards25519Point.xb,\
            Edwards25519Point.yb)
    def __init__(self,x,y):
        #Check the point is actually on the curve.
        if y*y-x*x!=self.f1+self.d*x*x*y*y:
            raise ValueError("Invalid point")
        self.initpoint(x, y)
        self.t=x*y
    #Decode a point representation.
    def decode(self,s):
        x,y=self.decode_base(s,256);
        return Edwards25519Point(x, y) if x is not None else None




Josefsson & Liusvaara         Informational                    [Page 51]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    #Encode a point representation.
    def encode(self):
        return self.encode_base(256)
    #Construct a neutral point on this curve.
    def zero_elem(self):
        return Edwards25519Point(self.f0,self.f1)
    #Solve for x^2.
    def solve_x2(self,y):
        return ((y*y-self.f1)/(self.d*y*y+self.f1))
    #Point addition.
    def __add__(self,y):
        #The formulas are from EFD.
        tmp=self.zero_elem()
        zcp=self.z*y.z
        A=(self.y-self.x)*(y.y-y.x)
        B=(self.y+self.x)*(y.y+y.x)
        C=(self.d+self.d)*self.t*y.t
        D=zcp+zcp
        E,H=B-A,B+A
        F,G=D-C,D+C
        tmp.x,tmp.y,tmp.z,tmp.t=E*F,G*H,F*G,E*H
        return tmp
    #Point doubling.
    def double(self):
        #The formulas are from EFD (with assumption a=-1 propagated).
        tmp=self.zero_elem()
        A=self.x*self.x
        B=self.y*self.y
        Ch=self.z*self.z
        C=Ch+Ch
        H=A+B
        xys=self.x+self.y
        E=H-xys*xys
        G=A-B
        F=C+G
        tmp.x,tmp.y,tmp.z,tmp.t=E*F,G*H,F*G,E*H
        return tmp
    #Order of basepoint.
    def l(self):
        return hexi("1000000000000000000000000000000014def9dea2f79cd"+\
            "65812631a5cf5d3ed")
    #The logarithm of cofactor.
    def c(self): return 3
    #The highest set bit
    def n(self): return 254
    #The coding length
    def b(self): return 256




Josefsson & Liusvaara         Informational                    [Page 52]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    #Validity check (for debugging)
    def is_valid_point(self):
        x,y,z,t=self.x,self.y,self.z,self.t
        x2=x*x
        y2=y*y
        z2=z*z
        lhs=(y2-x2)*z2
        rhs=z2*z2+self.d*x2*y2
        assert(lhs == rhs)
        assert(t*z == x*y)

#A point on Edwards448.
class Edwards448Point(EdwardsPoint):
    #Create a new point on the curve.
    base_field=Field(1,2**448-2**224-1)
    d=base_field.make(-39081)
    f0=base_field.make(0)
    f1=base_field.make(1)
    xb=base_field.make(hexi("4F1970C66BED0DED221D15A622BF36DA9E14657"+\
        "0470F1767EA6DE324A3D3A46412AE1AF72AB66511433B80E18B00938E26"+\
        "26A82BC70CC05E"))
    yb=base_field.make(hexi("693F46716EB6BC248876203756C9C7624BEA737"+\
        "36CA3984087789C1E05A0C2D73AD3FF1CE67C39C4FDBD132C4ED7C8AD98"+\
        "08795BF230FA14"))
    #The standard base point.
    @staticmethod
    def stdbase():
        return Edwards448Point(Edwards448Point.xb,Edwards448Point.yb)
    def __init__(self,x,y):
        #Check that the point is actually on the curve.
        if y*y+x*x!=self.f1+self.d*x*x*y*y:
            raise ValueError("Invalid point")
        self.initpoint(x, y)
    #Decode a point representation.
    def decode(self,s):
        x,y=self.decode_base(s,456);
        return Edwards448Point(x, y) if x is not None else None
    #Encode a point representation.
    def encode(self):
        return self.encode_base(456)
    #Construct a neutral point on this curve.
    def zero_elem(self):
        return Edwards448Point(self.f0,self.f1)
    #Solve for x^2.
    def solve_x2(self,y):
        return ((y*y-self.f1)/(self.d*y*y-self.f1))





Josefsson & Liusvaara         Informational                    [Page 53]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    #Point addition.
    def __add__(self,y):
        #The formulas are from EFD.
        tmp=self.zero_elem()
        xcp,ycp,zcp=self.x*y.x,self.y*y.y,self.z*y.z
        B=zcp*zcp
        E=self.d*xcp*ycp
        F,G=B-E,B+E
        tmp.x=zcp*F*((self.x+self.y)*(y.x+y.y)-xcp-ycp)
        tmp.y,tmp.z=zcp*G*(ycp-xcp),F*G
        return tmp
    #Point doubling.
    def double(self):
        #The formulas are from EFD.
        tmp=self.zero_elem()
        x1s,y1s,z1s=self.x*self.x,self.y*self.y,self.z*self.z
        xys=self.x+self.y
        F=x1s+y1s
        J=F-(z1s+z1s)
        tmp.x,tmp.y,tmp.z=(xys*xys-x1s-y1s)*J,F*(x1s-y1s),F*J
        return tmp
    #Order of basepoint.
    def l(self):
        return hexi("3ffffffffffffffffffffffffffffffffffffffffffffff"+\
            "fffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c2"+\
            "92ab5844f3")
    #The logarithm of cofactor.
    def c(self): return 2
    #The highest set bit.
    def n(self): return 447
    #The coding length.
    def b(self): return 456
    #Validity check (for debugging).
    def is_valid_point(self):
        x,y,z=self.x,self.y,self.z
        x2=x*x
        y2=y*y
        z2=z*z
        lhs=(x2+y2)*z2
        rhs=z2*z2+self.d*x2*y2
        assert(lhs == rhs)










Josefsson & Liusvaara         Informational                    [Page 54]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


#Simple self-check.
def curve_self_check(point):
    p=point
    q=point.zero_elem()
    z=q
    l=p.l()+1
    p.is_valid_point()
    q.is_valid_point()
    for i in range(0,point.b()):
        if (l>>i)&1 != 0:
            q=q+p
            q.is_valid_point()
        p=p.double()
        p.is_valid_point()
    assert q.encode() == point.encode()
    assert q.encode() != p.encode()
    assert q.encode() != z.encode()

#Simple self-check.
def self_check_curves():
    curve_self_check(Edwards25519Point.stdbase())
    curve_self_check(Edwards448Point.stdbase())

#PureEdDSA scheme.
#Limitation: only b mod 8 = 0 is handled.
class PureEdDSA:
    #Create a new object.
    def __init__(self,properties):
        self.B=properties["B"]
        self.H=properties["H"]
        self.l=self.B.l()
        self.n=self.B.n()
        self.b=self.B.b()
        self.c=self.B.c()
    #Clamp a private scalar.
    def __clamp(self,a):
        _a = bytearray(a)
        for i in range(0,self.c): _a[i//8]&=~(1<<(i%8))
        _a[self.n//8]|=1<<(self.n%8)
        for i in range(self.n+1,self.b): _a[i//8]&=~(1<<(i%8))
        return _a
    #Generate a key.  If privkey is None, a random one is generated.
    #In any case, the (privkey, pubkey) pair is returned.
    def keygen(self,privkey):
        #If no private key data is given, generate random.
        if privkey is None: privkey=os.urandom(self.b//8)





Josefsson & Liusvaara         Informational                    [Page 55]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


        #Expand key.
        khash=self.H(privkey,None,None)
        a=from_le(self.__clamp(khash[:self.b//8]))
        #Return the key pair (public key is A=Enc(aB).
        return privkey,(self.B*a).encode()
    #Sign with key pair.
    def sign(self,privkey,pubkey,msg,ctx,hflag):
        #Expand key.
        khash=self.H(privkey,None,None)
        a=from_le(self.__clamp(khash[:self.b//8]))
        seed=khash[self.b//8:]
        #Calculate r and R (R only used in encoded form).
        r=from_le(self.H(seed+msg,ctx,hflag))%self.l
        R=(self.B*r).encode()
        #Calculate h.
        h=from_le(self.H(R+pubkey+msg,ctx,hflag))%self.l
        #Calculate s.
        S=((r+h*a)%self.l).to_bytes(self.b//8,byteorder="little")
        #The final signature is a concatenation of R and S.
        return R+S
    #Verify signature with public key.
    def verify(self,pubkey,msg,sig,ctx,hflag):
        #Sanity-check sizes.
        if len(sig)!=self.b//4: return False
        if len(pubkey)!=self.b//8: return False
        #Split signature into R and S, and parse.
        Rraw,Sraw=sig[:self.b//8],sig[self.b//8:]
        R,S=self.B.decode(Rraw),from_le(Sraw)
        #Parse public key.
        A=self.B.decode(pubkey)
        #Check parse results.
        if (R is None) or (A is None) or S>=self.l: return False
        #Calculate h.
        h=from_le(self.H(Rraw+pubkey+msg,ctx,hflag))%self.l
        #Calculate left and right sides of check eq.
        rhs=R+(A*h)
        lhs=self.B*S
        for i in range(0, self.c):
            lhs = lhs.double()
            rhs = rhs.double()
        #Check eq. holds?
        return lhs==rhs

def Ed25519_inthash(data,ctx,hflag):
    if (ctx is not None and len(ctx) > 0) or hflag:
        raise ValueError("Contexts/hashes not supported")
    return hashlib.sha512(data).digest()




Josefsson & Liusvaara         Informational                    [Page 56]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


#The base PureEdDSA schemes.
pEd25519=PureEdDSA({\
    "B":Edwards25519Point.stdbase(),\
    "H":Ed25519_inthash\
})

def Ed25519ctx_inthash(data,ctx,hflag):
    dompfx = b""
    PREFIX=b"SigEd25519 no Ed25519 collisions"
    if ctx is not None:
        if len(ctx) > 255: raise ValueError("Context too big")
        dompfx=PREFIX+bytes([1 if hflag else 0,len(ctx)])+ctx
    return hashlib.sha512(dompfx+data).digest()

pEd25519ctx=PureEdDSA({\
    "B":Edwards25519Point.stdbase(),\
    "H":Ed25519ctx_inthash\
})

def Ed448_inthash(data,ctx,hflag):
    dompfx = b""
    if ctx is not None:
        if len(ctx) > 255: raise ValueError("Context too big")
        dompfx=b"SigEd448"+bytes([1 if hflag else 0,len(ctx)])+ctx
    return shake256(dompfx+data,114)

pEd448 = PureEdDSA({\
    "B":Edwards448Point.stdbase(),\
    "H":Ed448_inthash\
})

#EdDSA scheme.
class EdDSA:
    #Create a new scheme object, with the specified PureEdDSA base
    #scheme and specified prehash.
    def __init__(self,pure_scheme,prehash):
        self.__pflag = True
        self.__pure=pure_scheme
        self.__prehash=prehash
        if self.__prehash is None:
            self.__prehash = lambda x,y:x
            self.__pflag = False
    # Generate a key.  If privkey is none, it generates a random
    # privkey key, otherwise it uses a specified private key.
    # Returns pair (privkey, pubkey).
    def keygen(self,privkey): return self.__pure.keygen(privkey)





Josefsson & Liusvaara         Informational                    [Page 57]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


    # Sign message msg using specified key pair.
    def sign(self,privkey,pubkey,msg,ctx=None):
        if ctx is None: ctx=b"";
        return self.__pure.sign(privkey,pubkey,self.__prehash(msg,ctx),\
            ctx,self.__pflag)
    # Verify signature sig on message msg using public key pubkey.
    def verify(self,pubkey,msg,sig,ctx=None):
        if ctx is None: ctx=b"";
        return self.__pure.verify(pubkey,self.__prehash(msg,ctx),sig,\
            ctx,self.__pflag)

def Ed448ph_prehash(data,ctx):
    return shake256(data,64)

#Our signature schemes.
Ed25519 = EdDSA(pEd25519,None)
Ed25519ctx = EdDSA(pEd25519ctx,None)
Ed25519ph = EdDSA(pEd25519ctx,lambda x,y:hashlib.sha512(x).digest())
Ed448 = EdDSA(pEd448,None)
Ed448ph = EdDSA(pEd448,Ed448ph_prehash)

def eddsa_obj(name):
    if name == "Ed25519": return Ed25519
    if name == "Ed25519ctx": return Ed25519ctx
    if name == "Ed25519ph": return Ed25519ph
    if name == "Ed448": return Ed448
    if name == "Ed448ph": return Ed448ph
    raise NotImplementedError("Algorithm not implemented")

Appendix B.  Library Driver

   Below is a command-line tool that uses the library above to perform
   computations for interactive use or for self-checking.

import sys
import binascii

from eddsa2 import Ed25519


def munge_string(s, pos, change):
    return (s[:pos] +
            int.to_bytes(s[pos] ^ change, 1, "little") +
            s[pos+1:])







Josefsson & Liusvaara         Informational                    [Page 58]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


# Read a file in the format of
# http://ed25519.cr.yp.to/python/sign.input
lineno = 0
while True:
    line = sys.stdin.readline()
    if not line:
        break
    lineno = lineno + 1
    print(lineno)
    fields = line.split(":")
    secret = (binascii.unhexlify(fields[0]))[:32]
    public = binascii.unhexlify(fields[1])
    msg = binascii.unhexlify(fields[2])
    signature = binascii.unhexlify(fields[3])[:64]

    privkey,pubkey = Ed25519.keygen(secret)
    assert public == pubkey
    assert signature == Ed25519.sign(privkey, pubkey, msg)
    assert Ed25519.verify(public, msg, signature)
    if len(msg) == 0:
        bad_msg = b"x"
    else:
        bad_msg = munge_string(msg, len(msg) // 3, 4)
    assert not Ed25519.verify(public,bad_msg,signature)
    assert not Ed25519.verify(public, msg, munge_string(signature,20,8))
    assert not Ed25519.verify(public,msg,munge_string(signature,40,16))

























Josefsson & Liusvaara         Informational                    [Page 59]
   __________________________________________________________________


RFC 8032                EdDSA: Ed25519 and Ed448            January 2017


Acknowledgements

   EdDSA and Ed25519 were initially described in a paper due to Daniel
   J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin
   Yang.  The Ed448 curve is due to Mike Hamburg.

   An earlier draft version of this document was coauthored by Niels
   Moeller.

   Feedback on this document was received from Werner Koch, Damien
   Miller, Bob Bradley, Franck Rondepierre, Alexey Melnikov, Kenny
   Paterson, and Robert Edmonds.

   The Ed25519 test vectors were double checked by Bob Bradley using
   three separate implementations (one based on TweetNaCl and two
   different implementations based on code from SUPERCOP).

Authors' Addresses

   Simon Josefsson
   SJD AB

   Email: simon@josefsson.org
   URI:   http://josefsson.org/


   Ilari Liusvaara
   Independent

   Email: ilariliusvaara@welho.com





















Josefsson & Liusvaara         Informational                    [Page 60]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-iab-sec-cons] [Tracker] [Diff1] [Diff2]
   [Errata]
   BEST CURRENT PRACTICE
   Errata Exist
Network Working Group                                        E. Rescorla
Request for Comments: 3552                                    RTFM, Inc.
BCP: 72                                                        B. Korver
Category: Best Current Practice                          Xythos Software
                                             Internet Architecture Board
                                                                     IAB
                                                               July 2003


       Guidelines for Writing RFC Text on Security Considerations

Status of this Memo

   This document specifies an Internet Best Current Practices for the
   Internet Community, and requests discussion and suggestions for
   improvements.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

Abstract

   All RFCs are required to have a Security Considerations section.
   Historically, such sections have been relatively weak.  This document
   provides guidelines to RFC authors on how to write a good Security
   Considerations section.

Table of Contents

   1. Introduction . . . . . . . . . . . . . . . . . . . . . . .   3
      1.1. Requirements. . . . . . . . . . . . . . . . . . . . .   3
   2. The Goals of Security. . . . . . . . . . . . . . . . . . .   3
      2.1. Communication Security. . . . . . . . . . . . . . . .   3
           2.1.1. Confidentiality. . . . . . . . . . . . . . . .   4
           2.1.2. Data Integrity . . . . . . . . . . . . . . . .   4
           2.1.3. Peer Entity authentication . . . . . . . . . .   4
      2.2. Non-Repudiation . . . . . . . . . . . . . . . . . . .   5
      2.3. Systems Security. . . . . . . . . . . . . . . . . . .   5
           2.3.1. Unauthorized Usage . . . . . . . . . . . . . .   6
           2.3.2. Inappropriate Usage. . . . . . . . . . . . . .   6
           2.3.3. Denial of Service. . . . . . . . . . . . . . .   6
   3. The Internet Threat Model. . . . . . . . . . . . . . . . .   6
      3.1. Limited Threat Models . . . . . . . . . . . . . . . .   7
      3.2. Passive Attacks . . . . . . . . . . . . . . . . . . .   7
           3.2.1. Confidentiality Violations . . . . . . . . . .   8
           3.2.2. Password Sniffing. . . . . . . . . . . . . . .   8
           3.2.3. Offline Cryptographic Attacks. . . . . . . . .   9



Rescorla & Korver        Best Current Practice                  [Page 1]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


      3.3. Active Attacks. . . . . . . . . . . . . . . . . . . .   9
           3.3.1. Replay Attacks . . . . . . . . . . . . . . . .  10
           3.3.2. Message Insertion. . . . . . . . . . . . . . .  10
           3.3.3. Message Deletion . . . . . . . . . . . . . . .  11
           3.3.4. Message Modification . . . . . . . . . . . . .  11
           3.3.5. Man-In-The-Middle. . . . . . . . . . . . . . .  12
      3.4. Topological Issues. . . . . . . . . . . . . . . . . .  12
      3.5. On-path versus off-path . . . . . . . . . . . . . . .  13
      3.6. Link-local. . . . . . . . . . . . . . . . . . . . . .  13
   4. Common Issues. . . . . . . . . . . . . . . . . . . . . . .  13
      4.1. User Authentication . . . . . . . . . . . . . . . . .  14
           4.1.1. Username/Password. . . . . . . . . . . . . . .  14
           4.1.2. Challenge Response and One Time Passwords. . .  14
           4.1.3. Shared Keys. . . . . . . . . . . . . . . . . .  15
           4.1.4. Key Distribution Centers . . . . . . . . . . .  15
           4.1.5. Certificates . . . . . . . . . . . . . . . . .  15
           4.1.6. Some Uncommon Systems. . . . . . . . . . . . .  15
           4.1.7. Host Authentication. . . . . . . . . . . . . .  16
      4.2. Generic Security Frameworks . . . . . . . . . . . . .  16
      4.3. Non-repudiation . . . . . . . . . . . . . . . . . . .  17
      4.4. Authorization vs. Authentication. . . . . . . . . . .  18
           4.4.1. Access Control Lists . . . . . . . . . . . . .  18
           4.4.2. Certificate Based Systems. . . . . . . . . . .  18
      4.5. Providing Traffic Security. . . . . . . . . . . . . .  19
           4.5.1. IPsec. . . . . . . . . . . . . . . . . . . . .  19
           4.5.2. SSL/TLS. . . . . . . . . . . . . . . . . . . .  20
           4.5.3. Remote Login . . . . . . . . . . . . . . . . .  22
      4.6. Denial of Service Attacks and Countermeasures . . . .  22
           4.6.1. Blind Denial of Service. . . . . . . . . . . .  23
           4.6.2. Distributed Denial of Service. . . . . . . . .  23
           4.6.3. Avoiding Denial of Service . . . . . . . . . .  24
           4.6.4. Example: TCP SYN Floods. . . . . . . . . . . .  24
           4.6.5. Example: Photuris. . . . . . . . . . . . . . .  25
      4.7. Object vs. Channel Security . . . . . . . . . . . . .  25
      4.8. Firewalls and Network Topology. . . . . . . . . . . .  26
   5. Writing Security Considerations Sections . . . . . . . . .  26
   6. Examples . . . . . . . . . . . . . . . . . . . . . . . . .  28
      6.1. SMTP. . . . . . . . . . . . . . . . . . . . . . . . .  29
           6.1.1. Security Considerations. . . . . . . . . . . .  29
           6.1.2. Communications security issues . . . . . . . .  34
           6.1.3. Denial of Service. . . . . . . . . . . . . . .  36
      6.2. VRRP. . . . . . . . . . . . . . . . . . . . . . . . . .36
           6.2.1. Security Considerations. . . . . . . . . . . .  36
   7. Acknowledgments. . . . . . . . . . . . . . . . . . . . . .  38
   8. Normative References . . . . . . . . . . . . . . . . . . .  39
   9. Informative References . . . . . . . . . . . . . . . . . .  41
   10.Security Considerations. . . . . . . . . . . . . . . . . .  42
   Appendix A. . . . . . . . . . . . . . . . . . . . . . . . . .  43



Rescorla & Korver        Best Current Practice                  [Page 2]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Authors' Addresses. . . . . . . . . . . . . . . . . . . . . .  43
   Full Copyright Statement. . . . . . . . . . . . . . . . . . .  44

1. Introduction

   All RFCs are required by RFC 2223 to contain a Security
   Considerations section.  The purpose of this is both to encourage
   document authors to consider security in their designs and to inform
   the reader of relevant security issues.  This memo is intended to
   provide guidance to RFC authors in service of both ends.

   This document is structured in three parts.  The first is a
   combination security tutorial and definition of common terms; the
   second is a series of guidelines for writing Security Considerations;
   the third is a series of examples.

1.1. Requirements

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in BCP 14, RFC 2119
   [KEYWORDS].

2. The Goals of Security

   Most people speak of security as if it were a single monolithic
   property of a protocol or system, however, upon reflection, one
   realizes that it is clearly not true.  Rather, security is a series
   of related but somewhat independent properties.  Not all of these
   properties are required for every application.

   We can loosely divide security goals into those related to protecting
   communications (COMMUNICATION SECURITY, also known as COMSEC) and
   those relating to protecting systems (ADMINISTRATIVE SECURITY or
   SYSTEM SECURITY).  Since communications are carried out by systems
   and access to systems is through communications channels, these goals
   obviously interlock, but they can also be independently provided.

2.1. Communication Security

   Different authors partition the goals of communication security
   differently.  The partitioning we've found most useful is to divide
   them into three major categories: CONFIDENTIALITY, DATA INTEGRITY and
   PEER ENTITY AUTHENTICATION.







Rescorla & Korver        Best Current Practice                  [Page 3]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


2.1.1. Confidentiality

   When most people think of security, they think of CONFIDENTIALITY.
   Confidentiality means that your data is kept secret from unintended
   listeners.  Usually, these listeners are simply eavesdroppers.  When
   an adversary taps your phone, it poses a risk to your
   confidentiality.

   Obviously, if you have secrets, then you are probably concerned about
   others discovering them.  Thus, at the very least, you want to
   maintain confidentiality.  When you see spies in the movies go into
   the bathroom and turn on all the water to foil bugging, the property
   they're looking for is confidentiality.

2.1.2. Data Integrity

   The second primary goal is DATA INTEGRITY.  The basic idea here is
   that we want to make sure that the data we receive is the same data
   that the sender has sent.  In paper-based systems, some data
   integrity comes automatically.  When you receive a letter written in
   pen you can be fairly certain that no words have been removed by an
   attacker because pen marks are difficult to remove from paper.
   However, an attacker could have easily added some marks to the paper
   and completely changed the meaning of the message.  Similarly, it's
   easy to shorten the page to truncate the message.

   On the other hand, in the electronic world, since all bits look
   alike, it's trivial to tamper with messages in transit.  You simply
   remove the message from the wire, copy out the parts you like, add
   whatever data you want, and generate a new message of your choosing,
   and the recipient is no wiser.  This is the moral equivalent of the
   attacker taking a letter you wrote, buying some new paper and
   recopying the message, changing it as he does it.  It's just a lot
   easier to do electronically since all bits look alike.

2.1.3. Peer Entity authentication

   The third property we're concerned with is PEER ENTITY
   AUTHENTICATION.  What we mean by this is that we know that one of the
   endpoints in the communication is the one we intended.  Without peer
   entity authentication, it's very difficult to provide either
   confidentiality or data integrity.  For instance, if we receive a
   message from Alice, the property of data integrity doesn't do us much
   good unless we know that it was in fact sent by Alice and not the
   attacker.  Similarly, if we want to send a confidential message to
   Bob, it's not of much value to us if we're actually sending a
   confidential message to the attacker.




Rescorla & Korver        Best Current Practice                  [Page 4]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Note that peer entity authentication can be provided asymmetrically.
   When you call someone on the phone, you can be fairly certain that
   you have the right person -- or at least that you got a person who's
   actually at the phone number you called.  On the other hand, if they
   don't have caller ID, then the receiver of a phone call has no idea
   who's calling them.  Calling someone on the phone is an example of
   recipient authentication, since you know who the recipient of the
   call is, but they don't know anything about the sender.

   In messaging situations, you often wish to use peer entity
   authentication to establish the identity of the sender of a certain
   message.  In such contexts, this property is called DATA ORIGIN
   AUTHENTICATION.

2.2. Non-Repudiation

   A system that provides endpoint authentication allows one party to be
   certain of the identity of someone with whom he is communicating.
   When the system provides data integrity a receiver can be sure of
   both the sender's identity and that he is receiving the data that
   that sender meant to send.  However, he cannot necessarily
   demonstrate this fact to a third party.  The ability to make this
   demonstration is called NON-REPUDIATION.

   There are many situations in which non-repudiation is desirable.
   Consider the situation in which two parties have signed a contract
   which one party wishes to unilaterally abrogate.  He might simply
   claim that he had never signed it in the first place.  Non-
   repudiation prevents him from doing so, thus protecting the
   counterparty.

   Unfortunately, non-repudiation can be very difficult to achieve in
   practice and naive approaches are generally inadequate.  Section 4.3
   describes some of the difficulties, which generally stem from the
   fact that the interests of the two parties are not aligned -- one
   party wishes to prove something that the other party wishes to deny.

2.3. Systems Security

   In general, systems security is concerned with protecting one's
   machines and data.  The intent is that machines should be used only
   by authorized users and for the purposes that the owners intend.
   Furthermore, they should be available for those purposes.  Attackers
   should not be able to deprive legitimate users of resources.







Rescorla & Korver        Best Current Practice                  [Page 5]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


2.3.1. Unauthorized Usage

   Most systems are not intended to be completely accessible to the
   public.  Rather, they are intended to be used only by certain
   authorized individuals.  Although many Internet services are
   available to all Internet users, even those servers generally offer a
   larger subset of services to specific users.  For instance, Web
   Servers often will serve data to any user, but restrict the ability
   to modify pages to specific users.  Such modifications by the general
   public would be UNAUTHORIZED USAGE.

2.3.2. Inappropriate Usage

   Being an authorized user does not mean that you have free run of the
   system.  As we said above, some activities are restricted to
   authorized users, some to specific users, and some activities are
   generally forbidden to all but administrators.  Moreover, even
   activities which are in general permitted might be forbidden in some
   cases.  For instance, users may be permitted to send email but
   forbidden from sending files above a certain size, or files which
   contain viruses.  These are examples of INAPPROPRIATE USAGE.

2.3.3. Denial of Service

   Recall that our third goal was that the system should be available to
   legitimate users.  A broad variety of attacks are possible which
   threaten such usage.  Such attacks are collectively referred to as
   DENIAL OF SERVICE attacks.  Denial of service attacks are often very
   easy to mount and difficult to stop.  Many such attacks are designed
   to consume machine resources, making it difficult or impossible to
   serve legitimate users.  Other attacks cause the target machine to
   crash, completely denying service to users.

3. The Internet Threat Model

   A THREAT MODEL describes the capabilities that an attacker is assumed
   to be able to deploy against a resource.  It should contain such
   information as the resources available to an attacker in terms of
   information, computing capability, and control of the system.  The
   purpose of a threat model is twofold.  First, we wish to identify the
   threats we are concerned with.  Second, we wish to rule some threats
   explicitly out of scope.  Nearly every security system is vulnerable
   to a sufficiently dedicated and resourceful attacker.

   The Internet environment has a fairly well understood threat model.
   In general, we assume that the end-systems engaging in a protocol
   exchange have not themselves been compromised.  Protecting against an
   attack when one of the end-systems has been compromised is



Rescorla & Korver        Best Current Practice                  [Page 6]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   extraordinarily difficult.  It is, however, possible to design
   protocols which minimize the extent of the damage done under these
   circumstances.

   By contrast, we assume that the attacker has nearly complete control
   of the communications channel over which the end-systems communicate.
   This means that the attacker can read any PDU (Protocol Data Unit) on
   the network and undetectably remove, change, or inject forged packets
   onto the wire.  This includes being able to generate packets that
   appear to be from a trusted machine.  Thus, even if the end-system
   with which you wish to communicate is itself secure, the Internet
   environment provides no assurance that packets which claim to be from
   that system in fact are.

   It's important to realize that the meaning of a PDU is different at
   different levels.  At the IP level, a PDU means an IP packet.  At the
   TCP level, it means a TCP segment.  At the application layer, it
   means some kind of application PDU.  For instance, at the level of
   email, it might either mean an RFC-822 message or a single SMTP
   command.  At the HTTP level, it might mean a request or response.

3.1. Limited Threat Models

   As we've said, a resourceful and dedicated attacker can control the
   entire communications channel.  However, a large number of attacks
   can be mounted by an attacker with fewer resources.  A number of
   currently known attacks can be mounted by an attacker with limited
   control of the network.  For instance, password sniffing attacks can
   be mounted by an attacker who can only read arbitrary packets.  This
   is generally referred to as a PASSIVE ATTACK [INTAUTH].

   By contrast, Morris' sequence number guessing attack [SEQNUM] can be
   mounted by an attacker who can write but not read arbitrary packets.
   Any attack which requires the attacker to write to the network is
   known as an ACTIVE ATTACK.

   Thus, a useful way of organizing attacks is to divide them based on
   the capabilities required to mount the attack.  The rest of this
   section describes these categories and provides some examples of each
   category.

3.2. Passive Attacks

   In a passive attack, the attacker reads packets off the network but
   does not write them.  The simplest way to mount such an attack is to
   simply be on the same LAN as the victim.  On most common LAN
   configurations, including Ethernet, 802.3, and FDDI, any machine on
   the wire can read all traffic destined for any other machine on the



Rescorla & Korver        Best Current Practice                  [Page 7]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   same LAN.  Note that switching hubs make this sort of sniffing
   substantially more difficult, since traffic destined for a machine
   only goes to the network segment which that machine is on.

   Similarly, an attacker who has control of a host in the
   communications path between two victim machines is able to mount a
   passive attack on their communications.  It is also possible to
   compromise the routing infrastructure to specifically arrange that
   traffic passes through a compromised machine.  This might involve an
   active attack on the routing infrastructure to facilitate a passive
   attack on a victim machine.

   Wireless communications channels deserve special consideration,
   especially with the recent and growing popularity of wireless-based
   LANs, such as those using 802.11.  Since the data is simply broadcast
   on well known radio frequencies, an attacker simply needs to be able
   to receive those transmissions.  Such channels are especially
   vulnerable to passive attacks.  Although many such channels include
   cryptographic protection, it is often of such poor quality as to be
   nearly useless [WEP].

   In general, the goal of a passive attack is to obtain information
   which the sender and receiver would prefer to remain private.  This
   private information may include credentials useful in the electronic
   world and/or passwords or credentials useful in the outside world,
   such as confidential business information.

3.2.1. Confidentiality Violations

   The classic example of passive attack is sniffing some inherently
   private data off of the wire.  For instance, despite the wide
   availability of SSL, many credit card transactions still traverse the
   Internet in the clear.  An attacker could sniff such a message and
   recover the credit card number, which can then be used to make
   fraudulent transactions.  Moreover, confidential business information
   is routinely transmitted over the network in the clear in email.

3.2.2. Password Sniffing

   Another example of a passive attack is PASSWORD SNIFFING.  Password
   sniffing is directed towards obtaining unauthorized use of resources.
   Many protocols, including [TELNET], [POP], and [NNTP] use a shared
   password to authenticate the client to the server.  Frequently, this
   password is transmitted from the client to the server in the clear
   over the communications channel.  An attacker who can read this
   traffic can therefore capture the password and REPLAY it.  In other
   words, the attacker can initiate a connection to the server and pose
   as the client and login using the captured password.



Rescorla & Korver        Best Current Practice                  [Page 8]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Note that although the login phase of the attack is active, the
   actual password capture phase is passive.  Moreover, unless the
   server checks the originating address of connections, the login phase
   does not require any special control of the network.

3.2.3. Offline Cryptographic Attacks

   Many cryptographic protocols are subject to OFFLINE ATTACKS.  In such
   a protocol, the attacker recovers data which has been processed using
   the victim's secret key and then mounts a cryptanalytic attack on
   that key.  Passwords make a particularly vulnerable target because
   they are typically low entropy.  A number of popular password-based
   challenge response protocols are vulnerable to DICTIONARY ATTACK.
   The attacker captures a challenge-response pair and then proceeds to
   try entries from a list of common words (such as a dictionary file)
   until he finds a password that produces the right response.

   A similar such attack can be mounted on a local network when NIS is
   used.  The Unix password is crypted using a one-way function, but
   tools exist to break such crypted passwords [KLEIN].  When NIS is
   used, the crypted password is transmitted over the local network and
   an attacker can thus sniff the password and attack it.

   Historically, it has also been possible to exploit small operating
   system security holes to recover the password file using an active
   attack.  These holes can then be bootstrapped into an actual account
   by using the aforementioned offline password recovery techniques.
   Thus we combine a low-level active attack with an offline passive
   attack.

3.3. Active Attacks

   When an attack involves writing data to the network, we refer to this
   as an ACTIVE ATTACK.  When IP is used without IPsec, there is no
   authentication for the sender address.  As a consequence, it's
   straightforward for an attacker to create a packet with a source
   address of his choosing.  We'll refer to this as a SPOOFING ATTACK.

   Under certain circumstances, such a packet may be screened out by the
   network.  For instance, many packet filtering firewalls screen out
   all packets with source addresses on the INTERNAL network that arrive
   on the EXTERNAL interface.  Note, however, that this provides no
   protection against an attacker who is inside the firewall.  In
   general, designers should assume that attackers can forge packets.







Rescorla & Korver        Best Current Practice                  [Page 9]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   However, the ability to forge packets does not go hand in hand with
   the ability to receive arbitrary packets.  In fact, there are active
   attacks that involve being able to send forged packets but not
   receive the responses.  We'll refer to these as BLIND ATTACKS.

   Note that not all active attacks require forging addresses.  For
   instance, the TCP SYN denial of service attack [TCPSYN] can be
   mounted successfully without disguising the sender's address.
   However, it is common practice to disguise one's address in order to
   conceal one's identity if an attack is discovered.

   Each protocol is susceptible to specific active attacks, but
   experience shows that a number of common patterns of attack can be
   adapted to any given protocol.  The next sections describe a number
   of these patterns and give specific examples of them as applied to
   known protocols.

3.3.1. Replay Attacks

   In a REPLAY ATTACK, the attacker records a sequence of messages off
   of the wire and plays them back to the party which originally
   received them.  Note that the attacker does not need to be able to
   understand the messages.  He merely needs to capture and retransmit
   them.

   For example, consider the case where an S/MIME message is being used
   to request some service, such as a credit card purchase or a stock
   trade.  An attacker might wish to have the service executed twice, if
   only to inconvenience the victim.  He could capture the message and
   replay it, even though he can't read it, causing the transaction to
   be executed twice.

3.3.2. Message Insertion

   In a MESSAGE INSERTION attack, the attacker forges a message with
   some chosen set of properties and injects it into the network.  Often
   this message will have a forged source address in order to disguise
   the identity of the attacker.

   For example, a denial-of-service attack can be mounted by inserting a
   series of spurious TCP SYN packets directed towards the target host.
   The target host responds with its own SYN and allocates kernel data
   structures for the new connection.  The attacker never completes the
   3-way handshake, so the allocated connection endpoints just sit there
   taking up kernel memory.  Typical TCP stack implementations only






Rescorla & Korver        Best Current Practice                 [Page 10]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   allow some limited number of connections in this "half-open" state
   and when this limit is reached, no more connections can be initiated,
   even from legitimate hosts.  Note that this attack is a blind attack,
   since the attacker does not need to process the victim's SYNs.

3.3.3. Message Deletion

   In a MESSAGE DELETION attack, the attacker removes a message from the
   wire.  Morris' sequence number guessing attack [SEQNUM] often
   requires a message deletion attack to be performed successfully.  In
   this blind attack, the host whose address is being forged will
   receive a spurious TCP SYN packet from the host being attacked.
   Receipt of this SYN packet generates a RST, which would tear the
   illegitimate connection down.  In order to prevent this host from
   sending a RST so that the attack can be carried out successfully,
   Morris describes flooding this host to create queue overflows such
   that the SYN packet is lost and thus never responded to.

3.3.4. Message Modification

   In a MESSAGE MODIFICATION attack, the attacker removes a message from
   the wire, modifies it, and reinjects it into the network.  This sort
   of attack is particularly useful if the attacker wants to send some
   of the data in the message but also wants to change some of it.

   Consider the case where the attacker wants to attack an order for
   goods placed over the Internet.  He doesn't have the victim's credit
   card number so he waits for the victim to place the order and then
   replaces the delivery address (and possibly the goods description)
   with his own.  Note that this particular attack is known as a CUT-
   AND-PASTE attack since the attacker cuts the credit card number out
   of the original message and pastes it into the new message.

   Another interesting example of a cut-and-paste attack is provided by
   [IPSPPROB].  If IPsec ESP is used without any MAC then it is possible
   for the attacker to read traffic encrypted for a victim on the same
   machine.  The attacker attaches an IP header corresponding to a port
   he controls onto the encrypted IP packet.  When the packet is
   received by the host it will automatically be decrypted and forwarded
   to the attacker's port.  Similar techniques can be used to mount a
   session hijacking attack.  Both of these attacks can be avoided by
   always using message authentication when you use encryption.  Note
   that this attack only works if (1) no MAC check is being used, since
   this attack generates damaged packets (2) a host-to-host SA is being
   used, since a user-to-user SA will result in an inconsistency between
   the port associated with the SA and the target port.  If the
   receiving machine is single-user than this attack is infeasible.




Rescorla & Korver        Best Current Practice                 [Page 11]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


3.3.5. Man-In-The-Middle

   A MAN-IN-THE-MIDDLE attack combines the above techniques in a special
   form: The attacker subverts the communication stream in order to pose
   as the sender to receiver and the receiver to the sender:

      What Alice and Bob think:
      Alice  <---------------------------------------------->  Bob

      What's happening:
      Alice  <---------------->  Attacker  <---------------->  Bob

   This differs fundamentally from the above forms of attack because it
   attacks the identity of the communicating parties, rather than the
   data stream itself.  Consequently, many techniques which provide
   integrity of the communications stream are insufficient to protect
   against man-in-the-middle attacks.

   Man-in-the-middle attacks are possible whenever a protocol lacks PEER
   ENTITY AUTHENTICATION.  For instance, if an attacker can hijack the
   client TCP connection during the TCP handshake (perhaps by responding
   to the client's SYN before the server does), then the attacker can
   open another connection to the server and begin a man-in-the-middle
   attack.  It is also trivial to mount man-in-the-middle attacks on
   local networks via ARP spoofing -- the attacker forges an ARP with
   the victim's IP address and his own MAC address.  Tools to mount this
   sort of attack are readily available.

   Note that it is only necessary to authenticate one side of the
   transaction in order to prevent man-in-the-middle attacks.  In such a
   situation the the peers can establish an association in which only
   one peer is authenticated.  In such a system, an attacker can
   initiate an association posing as the unauthenticated peer but cannot
   transmit or access data being sent on a legitimate connection.  This
   is an acceptable situation in contexts such as Web e-commerce where
   only the server needs to be authenticated (or the client is
   independently authenticated via some non-cryptographic mechanism such
   as a credit card number).

3.4. Topological Issues

   In practice, the assumption that it's equally easy for an attacker to
   read and generate all packets is false, since the Internet is not
   fully connected.  This has two primary implications.







Rescorla & Korver        Best Current Practice                 [Page 12]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


3.5. On-path versus off-path

   In order for a datagram to be transmitted from one host to another,
   it generally must traverse some set of intermediate links and
   gateways.  Such gateways are naturally able to read, modify, or
   remove any datagram transmitted along that path.  This makes it much
   easier to mount a wide variety of attacks if you are on-path.

   Off-path hosts can, of course, transmit arbitrary datagrams that
   appear to come from any hosts but cannot necessarily receive
   datagrams intended for other hosts.  Thus, if an attack depends on
   being able to receive data, off-path hosts must first subvert the
   topology in order to place themselves on-path.  This is by no means
   impossible but is not necessarily trivial.

   Applications protocol designers MUST NOT assume that all attackers
   will be off-path.  Where possible, protocols SHOULD be designed to
   resist attacks from attackers who have complete control of the
   network.  However, designers are expected to give more weight to
   attacks which can be mounted by off-path attackers as well as on-path
   ones.

3.6. Link-local

   One specialized case of on-path is being on the same link.  In some
   situations, it's desirable to distinguish between hosts who are on
   the local network and those who are not.  The standard technique for
   this is verifying the IP TTL value [IP].  Since the TTL must be
   decremented by each forwarder, a protocol can demand that TTL be set
   to 255 and that all receivers verify the TTL.  A receiver then has
   some reason to believe that conforming packets are from the same
   link.  Note that this technique must be used with care in the
   presence of tunneling systems, since such systems may pass packets
   without decrementing TTL.

4. Common Issues

   Although each system's security requirements are unique, certain
   common requirements appear in a number of protocols.  Often, when
   naive protocol designers are faced with these requirements, they
   choose an obvious but insecure solution even though better solutions
   are available.  This section describes a number of issues seen in
   many protocols and the common pieces of security technology that may
   be useful in addressing them.







Rescorla & Korver        Best Current Practice                 [Page 13]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


4.1. User Authentication

   Essentially every system which wants to control access to its
   resources needs some way to authenticate users.  A nearly uncountable
   number of such mechanisms have been designed for this purpose.  The
   next several sections describe some of these techniques.

4.1.1. Username/Password

   The most common access control mechanism is simple USERNAME/PASSWORD
   The user provides a username and a reusable password to the host
   which he wishes to use.  This system is vulnerable to a simple
   passive attack where the attacker sniffs the password off the wire
   and then initiates a new session, presenting the password.  This
   threat can be mitigated by hosting the protocol over an encrypted
   connection such as TLS or IPSEC.  Unprotected (plaintext)
   username/password systems are not acceptable in IETF standards.

4.1.2. Challenge Response and One Time Passwords

   Systems which desire greater security than USERNAME/PASSWORD often
   employ either a ONE TIME PASSWORD [OTP] scheme or a CHALLENGE-
   RESPONSE.  In a one time password scheme, the user is provided with a
   list of passwords, which must be used in sequence, one time each.
   (Often these passwords are generated from some secret key so the user
   can simply compute the next password in the sequence.)  SecureID and
   DES Gold are variants of this scheme.  In a challenge-response
   scheme, the host and the user share some secret (which often is
   represented as a password).  In order to authenticate the user, the
   host presents the user with a (randomly generated) challenge.  The
   user computes some function based on the challenge and the secret and
   provides that to the host, which verifies it.  Often this computation
   is performed in a handheld device, such as a DES Gold card.

   Both types of scheme provide protection against replay attack, but
   often still vulnerable to an OFFLINE KEYSEARCH ATTACK (a form of
   passive attack): As previously mentioned, often the one-time password
   or response is computed from a shared secret.  If the attacker knows
   the function being used, he can simply try all possible shared
   secrets until he finds one that produces the right output.  This is
   made easier if the shared secret is a password, in which case he can
   mount a DICTIONARY ATTACK -- meaning that he tries a list of common
   words (or strings) rather than just random strings.

   These systems are also often vulnerable to an active attack.  Unless
   communication security is provided for the entire session, the
   attacker can simply wait until authentication has been performed and
   hijack the connection.



Rescorla & Korver        Best Current Practice                 [Page 14]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


4.1.3. Shared Keys

   CHALLENGE-RESPONSE type systems can be made secure against dictionary
   attack by using randomly generated shared keys instead of user-
   generated passwords.  If the keys are sufficiently large then
   keysearch attacks become impractical.  This approach works best when
   the keys are configured into the end nodes rather than memorized and
   typed in by users, since users have trouble remembering sufficiently
   long keys.

   Like password-based systems, shared key systems suffer from
   management problems.  Each pair of communicating parties must have
   their own agreed-upon key, which leads to there being a lot of keys.

4.1.4. Key Distribution Centers

   One approach to solving the large number of keys problem is to use an
   online "trusted third party" that mediates between the authenticating
   parties.  The trusted third party (generally called a a KEY
   DISTRIBUTION CENTER (KDC)) shares a symmetric key or password with
   each party in the system.  It first contacts the KDC which gives it a
   TICKET containing a randomly generated symmetric key encrypted under
   both peer's keys.  Since only the proper peers can decrypt the
   symmetric key the ticket can be used to establish a trusted
   association.  By far the most popular KDC system is Kerberos
   [KERBEROS].

4.1.5. Certificates

   A simple approach is to have all users have CERTIFICATES [PKIX] which
   they then use to authenticate in some protocol-specific way, as in
   [TLS] or [S/MIME].  A certificate is a signed credential binding an
   entity's identity to its public key.  The signer of a certificate is
   a CERTIFICATE AUTHORITY (CA), whose certificate may itself be signed
   by some superior CA.  In order for this system to work, trust in one
   or more CAs must be established in an out-of-band fashion.  Such CAs
   are referred to as TRUSTED ROOTS or ROOT CAS.  The primary obstacle
   to this approach in client-server type systems is that it requires
   clients to have certificates, which can be a deployment problem.

4.1.6. Some Uncommon Systems

   There are ways to do a better job than the schemes mentioned above,
   but they typically don't add much security unless communications
   security (at least message integrity) will be employed to secure the
   connection, because otherwise the attacker can merely hijack the
   connection after authentication has been performed.  A number of
   protocols ([EKE], [SPEKE], [SRP]) allow one to securely bootstrap a



Rescorla & Korver        Best Current Practice                 [Page 15]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   user's password into a shared key which can be used as input to a
   cryptographic protocol.  One major obstacle to the deployment of
   these protocols has been that their Intellectual Property status is
   extremely unclear.  Similarly, the user can authenticate using public
   key certificates (e.g., S-HTTP client authentication).  Typically
   these methods are used as part of a more complete security protocol.

4.1.7. Host Authentication

   Host authentication presents a special problem.  Quite commonly, the
   addresses of services are presented using a DNS hostname, for
   instance as a URL [URL].  When requesting such a service, one has to
   ensure that the entity that one is talking to not only has a
   certificate but that that certificate corresponds to the expected
   identity of the server.  The important thing to have is a secure
   binding between the certificate and the expected hostname.

   For instance, it is usually not acceptable for the certificate to
   contain an identity in the form of an IP address if the request was
   for a given hostname.  This does not provide end-to-end security
   because the hostname-IP mapping is not secure unless secure name
   resolution [DNSSEC] is being used.  This is a particular problem when
   the hostname is presented at the application layer but the
   authentication is performed at some lower layer.

4.2. Generic Security Frameworks

   Providing security functionality in a protocol can be difficult.  In
   addition to the problem of choosing authentication and key
   establishment mechanisms, one needs to integrate it into a protocol.
   One response to this problem (embodied in IPsec and TLS) is to create
   a lower-level security protocol and then insist that new protocols be
   run over that protocol.  Another approach that has recently become
   popular is to design generic application layer security frameworks.
   The idea is that you design a protocol that allows you to negotiate
   various security mechanisms in a pluggable fashion.  Application
   protocol designers then arrange to carry the security protocol PDUs
   in their application protocol.  Examples of such frameworks include
   GSS-API [GSS] and SASL [SASL].

   The generic framework approach has a number of problems.  First, it
   is highly susceptible to DOWNGRADE ATTACKS.  In a downgrade attack,
   an active attacker tampers with the negotiation in order to force the
   parties to negotiate weaker protection than they otherwise would.
   It's possible to include an integrity check after the negotiation and
   key establishment have both completed, but the strength of this
   integrity check is necessarily limited to the weakest common
   algorithm.  This problem exists with any negotiation approach, but



Rescorla & Korver        Best Current Practice                 [Page 16]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   generic frameworks exacerbate it by encouraging the application
   protocol author to just specify the framework rather than think hard
   about the appropriate underlying mechanisms, particularly since the
   mechanisms can very widely in the degree of security offered.

   Another problem is that it's not always obvious how the various
   security features in the framework interact with the application
   layer protocol.  For instance, SASL can be used merely as an
   authentication framework -- in which case the SASL exchange occurs
   but the rest of the connection is unprotected, but can also negotiate
   traffic protection, such as via GSS, as a mechanism.  Knowing under
   what circumstances traffic protection is optional and which it is
   required requires thinking about the threat model.

   In general, authentication frameworks are most useful in situations
   where new protocols are being added to systems with pre-existing
   legacy authentication systems.  A framework allows new installations
   to provide better authentication while not forcing existing sites
   completely redo their legacy authentication systems.  When the
   security requirements of a system can be clearly identified and only
   a few forms of authentication are used, choosing a single security
   mechanism leads to greater simplicity and predictability.  In
   situations where a framework is to be used, designers SHOULD
   carefully examine the framework's options and specify only the
   mechanisms that are appropriate for their particular threat model.
   If a framework is necessary, designers SHOULD choose one of the
   established ones instead of designing their own.

4.3. Non-repudiation

   The naive approach to non-repudiation is simply to use public-key
   digital signatures over the content.  The party who wishes to be
   bound (the SIGNING PARTY) digitally signs the message in question.
   The counterparty (the RELYING PARTY) can later point to the digital
   signature as proof that the signing party at one point agreed to the
   disputed message.  Unfortunately, this approach is insufficient.

   The easiest way for the signing party to repudiate the message is by
   claiming that his private key has been compromised and that some
   attacker (though not necessarily the relying party) signed the
   disputed message.  In order to defend against this attack the relying
   party needs to demonstrate that the signing party's key had not been
   compromised at the time of the signature.  This requires substantial
   infrastructure, including archival storage of certificate revocation
   information and timestamp servers to establish the time that the
   message was signed.





Rescorla & Korver        Best Current Practice                 [Page 17]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Additionally, the relying party might attempt to trick the signing
   party into signing one message while thinking he's signing another.
   This problem is particularly severe when the relying party controls
   the infrastructure that the signing party uses for signing, such as
   in kiosk situations.  In many such situations the signing party's key
   is kept on a smartcard but the message to be signed is displayed by
   the relying party.

   All of these complications make non-repudiation a difficult service
   to deploy in practice.

4.4. Authorization vs. Authentication

   AUTHORIZATION is the process by which one determines whether an
   authenticated party has permission to access a particular resource or
   service.  Although tightly bound, it is important to realize that
   authentication and authorization are two separate mechanisms.
   Perhaps because of this tight coupling, authentication is sometimes
   mistakenly thought to imply authorization.  Authentication simply
   identifies a party, authorization defines whether they can perform a
   certain action.

   Authorization necessarily relies on authentication, but
   authentication alone does not imply authorization.  Rather, before
   granting permission to perform an action, the authorization mechanism
   must be consulted to determine whether that action is permitted.

4.4.1. Access Control Lists

   One common form of authorization mechanism is an access control list
   (ACL), which lists users that are permitted access to a resource.
   Since assigning individual authorization permissions to each resource
   is tedious, resources are often hierarchically arranged so that the
   parent resource's ACL is inherited by child resources.  This allows
   administrators to set top level policies and override them when
   necessary.

4.4.2. Certificate Based Systems

   While the distinction between authentication and authorization is
   intuitive when using simple authentication mechanisms such as
   username and password (i.e., everyone understands the difference
   between the administrator account and a user account), with more
   complex authentication mechanisms the distinction is sometimes lost.

   With certificates, for instance, presenting a valid signature does
   not imply authorization.  The signature must be backed by a
   certificate chain that contains a trusted root, and that root must be



Rescorla & Korver        Best Current Practice                 [Page 18]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   trusted in the given context.  For instance, users who possess
   certificates issued by the Acme MIS CA may have different web access
   privileges than users who possess certificates issued by the Acme
   Accounting CA, even though both of these CAs are "trusted" by the
   Acme web server.

   Mechanisms for enforcing these more complicated properties have not
   yet been completely explored.  One approach is simply to attach
   policies to ACLs describing what sorts of certificates are trusted.
   Another approach is to carry that information with the certificate,
   either as a certificate extension/attribute [PKIX, SPKI] or as a
   separate "Attribute Certificate".

4.5. Providing Traffic Security

   Securely designed protocols should provide some mechanism for
   securing (meaning integrity protecting, authenticating, and possibly
   encrypting) all sensitive traffic.  One approach is to secure the
   protocol itself, as in [DNSSEC], [S/MIME] or [S-HTTP].  Although this
   provides security which is most fitted to the protocol, it also
   requires considerable effort to get right.

   Many protocols can be adequately secured using one of the available
   channel security systems.  We'll discuss the two most common, IPsec
   [AH, ESP] and [TLS].

4.5.1. IPsec

   The IPsec protocols (specifically, AH and ESP) can provide
   transmission security for all traffic between two hosts.  The IPsec
   protocols support varying granularities of user identification,
   including for example "IP Subnet", "IP Address", "Fully Qualified
   Domain Name", and individual user ("Mailbox name").  These varying
   levels of identification are employed as inputs to access control
   facilities that are an intrinsic part of IPsec.  However, a given
   IPsec implementation might not support all identity types.  In
   particular, security gateways may not provide user-to-user
   authentication or have mechanisms to provide that authentication
   information to applications.

   When AH or ESP is used, the application programmer might not need to
   do anything (if AH or ESP has been enabled system-wide) or might need
   to make specific software changes (e.g., adding specific setsockopt()
   calls) -- depending on the AH or ESP implementation being used.
   Unfortunately, APIs for controlling IPsec implementations are not yet
   standardized.





Rescorla & Korver        Best Current Practice                 [Page 19]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   The primary obstacle to using IPsec to secure other protocols is
   deployment.  The major use of IPsec at present is for VPN
   applications, especially for remote network access.  Without
   extremely tight coordination between security administrators and
   application developers, VPN usage is not well suited to providing
   security services for individual applications since it is difficult
   for such applications to determine what security services have in
   fact been provided.

   IPsec deployment in host-to-host environments has been slow.  Unlike
   application security systems such as TLS, adding IPsec to a non-IPsec
   system generally involves changing the operating system, either by
   modifying with the kernel or installing new drivers.  This is a
   substantially greater undertaking than simply installing a new
   application.  However, recent versions of a number of commodity
   operating systems include IPsec stacks, so deployment is becoming
   easier.

   In environments where IPsec is sure to be available, it represents a
   viable option for protecting application communications traffic.  If
   the traffic to be protected is UDP, IPsec and application-specific
   object security are the only options.  However, designers MUST NOT
   assume that IPsec will be available.  A security policy for a generic
   application layer protocol SHOULD NOT simply state that IPsec must be
   used, unless there is some reason to believe that IPsec will be
   available in the intended deployment environment.  In environments
   where IPsec may not be available and the traffic is solely TCP, TLS
   is the method of choice, since the application developer can easily
   ensure its presence by including a TLS implementation in his package.

   In the special-case of IPv6, both AH and ESP are mandatory to
   implement.  Hence, it is reasonable to assume that AH/ESP are already
   available for IPv6-only protocols or IPv6-only deployments.  However,
   automatic key management (IKE) is not required to implement so
   protocol designers SHOULD not assume it will be present.  [USEIPSEC]
   provides quite a bit of guidance on when IPsec is a good choice.

4.5.2. SSL/TLS

   Currently, the most common approach is to use SSL or its successor
   TLS.  They provide channel security for a TCP connection at the
   application level.  That is, they run over TCP.  SSL implementations
   typically provide a Berkeley Sockets-like interface for easy
   programming.  The primary issue when designing a protocol solution
   around TLS is to differentiate between connections protected using
   TLS and those which are not.





Rescorla & Korver        Best Current Practice                 [Page 20]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   The two primary approaches used have a separate well-known port for
   TLS connections (e.g., the HTTP over TLS port is 443) [HTTPTLS] or to
   have a mechanism for negotiating upward from the base protocol to TLS
   as in [UPGRADE] or [STARTTLS].  When an upward negotiation strategy
   is used, care must be taken to ensure that an attacker can not force
   a clear connection when both parties wish to use TLS.

   Note that TLS depends upon a reliable protocol such as TCP or SCTP.
   This produces two notable difficulties.  First, it cannot be used to
   secure datagram protocols that use UDP.  Second, TLS is susceptible
   to IP layer attacks that IPsec is not.  Typically, these attacks take
   some form of denial of service or connection assassination.  For
   instance, an attacker might forge a TCP RST to shut down SSL
   connections.  TLS has mechanisms to detect truncation attacks but
   these merely allow the victim to know he is being attacked and do not
   provide connection survivability in the face of such attacks.  By
   contrast, if IPsec were being used, such a forged RST could be
   rejected without affecting the TCP connection.  If forged RSTs or
   other such attacks on the TCP connection are a concern, then AH/ESP
   or the TCP MD5 option [TCPMD5] are the preferred choices.

4.5.2.1. Virtual Hosts

   If the "separate ports" approach to TLS is used, then TLS will be
   negotiated before any application-layer traffic is sent.  This can
   cause a problem with protocols that use virtual hosts, such as
   [HTTP], since the server does not know which certificate to offer the
   client during the TLS handshake.  The TLS hostname extension [TLSEXT]
   can be used to solve this problem, although it is too new to have
   seen wide deployment.

4.5.2.2. Remote Authentication and TLS

   One difficulty with using TLS is that the server is authenticated via
   a certificate.  This can be inconvenient in environments where
   previously the only form of authentication was a password shared
   between client and server.  It's tempting to use TLS without an
   authenticated server (i.e., with anonymous DH or a self-signed RSA
   certificate) and then authenticate via some challenge-response
   mechanism such as SASL with CRAM-MD5.

   Unfortunately, this composition of SASL and TLS is less strong than
   one would expect.  It's easy for an active attacker to hijack this
   connection.  The client man-in-the-middles the SSL connection
   (remember we're not authenticating the server, which is what
   ordinarily prevents this attack) and then simply proxies the SASL
   handshake.  From then on, it's as if the connection were in the




Rescorla & Korver        Best Current Practice                 [Page 21]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   clear, at least as far as that attacker is concerned.  In order to
   prevent this attack, the client needs to verify the server's
   certificate.

   However, if the server is authenticated, challenge-response becomes
   less desirable.  If you already have a hardened channel then simple
   passwords are fine.  In fact, they're arguably superior to
   challenge-response since they do not require that the password be
   stored in the clear on the server.  Thus, compromise of the key file
   with challenge-response systems is more serious than if simple
   passwords were used.

   Note that if the client has a certificate than SSL-based client
   authentication can be used.  To make this easier, SASL provides the
   EXTERNAL mechanism, whereby the SASL client can tell the server
   "examine the outer channel for my identity".  Obviously, this is not
   subject to the layering attacks described above.

4.5.3. Remote Login

   In some special cases it may be worth providing channel-level
   security directly in the application rather than using IPSEC or
   SSL/TLS.  One such case is remote terminal security.  Characters are
   typically delivered from client to server one character at a time.
   Since SSL/TLS and AH/ESP authenticate and encrypt every packet, this
   can mean a data expansion of 20-fold.  The telnet encryption option
   [ENCOPT] prevents this expansion by foregoing message integrity.

   When using remote terminal service, it's often desirable to securely
   perform other sorts of communications services.  In addition to
   providing remote login, SSH [SSH] also provides secure port
   forwarding for arbitrary TCP ports, thus allowing users run arbitrary
   TCP-based applications over the SSH channel.  Note that SSH Port
   Forwarding can be security issue if it is used improperly to
   circumvent firewall and improperly expose insecure internal
   applications to the outside world.

4.6. Denial of Service Attacks and Countermeasures

   Denial of service attacks are all too frequently viewed as an fact of
   life.  One problem is that an attacker can often choose from one of
   many denial of service attacks to inflict upon a victim, and because
   most of these attacks cannot be thwarted, common wisdom frequently
   assumes that there is no point protecting against one kind of denial
   of service attack when there are many other denial of service attacks
   that are possible but that cannot be prevented.





Rescorla & Korver        Best Current Practice                 [Page 22]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   However, not all denial of service attacks are equal and more
   importantly, it is possible to design protocols so that denial of
   service attacks are made more difficult, if not impractical.  Recent
   SYN flood attacks [TCPSYN] demonstrate both of these properties: SYN
   flood attacks are so easy, anonymous, and effective that they are
   more attractive to attackers than other attacks; and because the
   design of TCP enables this attack.

   Because complete DoS protection is so difficult, security against DoS
   must be dealt with pragmatically.  In particular, some attacks which
   would be desirable to defend against cannot be defended against
   economically.  The goal should be to manage risk by defending against
   attacks with sufficiently high ratios of severity to cost of defense.
   Both severity of attack and cost of defense change as technology
   changes and therefore so does the set of attacks which should be
   defended against.

   Authors of internet standards MUST describe which denial of service
   attacks their protocol is susceptible to.  This description MUST
   include the reasons it was either unreasonable or out of scope to
   attempt to avoid these denial of service attacks.

4.6.1. Blind Denial of Service

   BLIND denial of service attacks are particularly pernicious.  With a
   blind attack the attacker has a significant advantage.  If the
   attacker must be able to receive traffic from the victim, then he
   must either subvert the routing fabric or use his own IP address.
   Either provides an opportunity for the victim to track the attacker
   and/or filter out his traffic.  With a blind attack the attacker can
   use forged IP addresses, making it extremely difficult for the victim
   to filter out his packets.  The TCP SYN flood attack is an example of
   a blind attack.  Designers should make every attempt possible to
   prevent blind denial of service attacks.

4.6.2. Distributed Denial of Service

   Even more dangerous are DISTRIBUTED denial of service attacks (DDoS)
   [DDOS].  In a DDoS the attacker arranges for a number of machines to
   attack the target machine simultaneously.  Usually this is
   accomplished by infecting a large number of machines with a program
   that allows remote initiation of attacks.  The machines actually
   performing the attack are called ZOMBIEs and are likely owned by
   unsuspecting third parties in an entirely different location from the
   true attacker.  DDoS attacks can be very hard to counter because the
   zombies often appear to be making legitimate protocol requests and





Rescorla & Korver        Best Current Practice                 [Page 23]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   simply crowd out the real users.  DDoS attacks can be difficult to
   thwart, but protocol designers are expected to be cognizant of these
   forms of attack while designing protocols.

4.6.3. Avoiding Denial of Service

   There are two common approaches to making denial of service attacks
   more difficult:

4.6.3.1. Make your attacker do more work than you do

   If an attacker consumes more of his resources than yours when
   launching an attack, attackers with fewer resources than you will be
   unable to launch effective attacks.  One common technique is to
   require the attacker perform a time-intensive operation, such as a
   cryptographic operation.  Note that an attacker can still mount a
   denial of service attack if he can muster substantially sufficient
   CPU power.  For instance, this technique would not stop the
   distributed attacks described in [TCPSYN].

4.6.3.2. Make your attacker prove they can receive data from you

   A blind attack can be subverted by forcing the attacker to prove that
   they can can receive data from the victim.  A common technique is to
   require that the attacker reply using information that was gained
   earlier in the message exchange.  If this countermeasure is used, the
   attacker must either use his own address (making him easy to track)
   or to forge an address which will be routed back along a path that
   traverses the host from which the attack is being launched.

   Hosts on small subnets are thus useless to the attacker (at least in
   the context of a spoofing attack) because the attack can be traced
   back to a subnet (which should be sufficient for locating the
   attacker) so that anti-attack measures can be put into place (for
   instance, a boundary router can be configured to drop all traffic
   from that subnet).  A common technique is to require that the
   attacker reply using information that was gained earlier in the
   message exchange.

4.6.4. Example: TCP SYN Floods

   TCP/IP is vulnerable to SYN flood attacks (which are described in
   section 3.3.2) because of the design of the 3-way handshake.  First,
   an attacker can force a victim to consume significant resources (in
   this case, memory) by sending a single packet.  Second, because the
   attacker can perform this action without ever having received data
   from the victim, the attack can be performed anonymously (and
   therefore using a large number of forged source addresses).



Rescorla & Korver        Best Current Practice                 [Page 24]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


4.6.5. Example: Photuris

   [PHOTURIS] specifies an anti-clogging mechanism that prevents attacks
   on Photuris that resemble the SYN flood attack.  Photuris employs a
   time-variant secret to generate a "cookie" which is returned to the
   attacker.  This cookie must be returned in subsequent messages for
   the exchange to progress.  The interesting feature is that this
   cookie can be regenerated by the victim later in the exchange, and
   thus no state need be retained by the victim until after the attacker
   has proven that he can receive packets from the victim.

4.7. Object vs. Channel Security

   It's useful to make the conceptual distinction between object
   security and channel security.  Object security refers to security
   measures which apply to entire data objects.  Channel security
   measures provide a secure channel over which objects may be carried
   transparently but the channel has no special knowledge about object
   boundaries.

   Consider the case of an email message.  When it's carried over an
   IPSEC or TLS secured connection, the message is protected during
   transmission.  However, it is unprotected in the receiver's mailbox,
   and in intermediate spool files along the way.  Moreover, since mail
   servers generally run as a daemon, not a user, authentication of
   messages generally merely means authentication of the daemon not the
   user.  Finally, since mail transport is hop-by-hop, even if the user
   authenticates to the first hop relay the authentication can't be
   safely verified by the receiver.

   By contrast, when an email message is protected with S/MIME or
   OpenPGP, the entire message is encrypted and integrity protected
   until it is examined and decrypted by the recipient.  It also
   provides strong authentication of the actual sender, as opposed to
   the machine the message came from.  This is object security.
   Moreover, the receiver can prove the signed message's authenticity to
   a third party.

   Note that the difference between object and channel security is a
   matter of perspective.  Object security at one layer of the protocol
   stack often looks like channel security at the next layer up.  So,
   from the perspective of the IP layer, each packet looks like an
   individually secured object.  But from the perspective of a web
   client, IPSEC just provides a secure channel.

   The distinction isn't always clear-cut.  For example, S-HTTP provides
   object level security for a single HTTP transaction, but a web page
   typically consists of multiple HTTP transactions (the base page and



Rescorla & Korver        Best Current Practice                 [Page 25]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   numerous inline images).  Thus, from the perspective of the total web
   page, this looks rather more like channel security.  Object security
   for a web page would consist of security for the transitive closure
   of the page and all its embedded content as a single unit.

4.8. Firewalls and Network Topology

   It's common security practice in modern networks to partition the
   network into external and internal networks using a firewall.  The
   internal network is then assumed to be secure and only limited
   security measures are used there.  The internal portion of such a
   network is often called a WALLED GARDEN.

   Internet protocol designers cannot safely assume that their protocols
   will be deployed in such an environment, for three reasons.  First,
   protocols which were originally designed to be deployed in closed
   environments often are later deployed on the Internet, thus creating
   serious vulnerabilities.

   Second, networks which appear to be topologically disconnected may
   not be.  One reason may be that the network has been reconfigured to
   allow access by the outside world.  Moreover, firewalls are
   increasingly passing generic application layer protocols such as
   [SOAP] or [HTTP].  Network protocols which are based on these generic
   protocols cannot in general assume that a firewall will protect them.
   Finally, one of the most serious security threats to systems is from
   insiders, not outsiders.  Since insiders by definition have access to
   the internal network, topological protections such as firewalls will
   not protect them.

5. Writing Security Considerations Sections

   While it is not a requirement that any given protocol or system be
   immune to all forms of attack, it is still necessary for authors to
   consider as many forms as possible.  Part of the purpose of the
   Security Considerations section is to explain what attacks are out of
   scope and what countermeasures can be applied to defend against them.
   In

   There should be a clear description of the kinds of threats on the
   described protocol or technology.  This should be approached as an
   effort to perform "due diligence" in describing all known or
   foreseeable risks and threats to potential implementers and users.








Rescorla & Korver        Best Current Practice                 [Page 26]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Authors MUST describe

      1.   which attacks are out of scope (and why!)
      2.   which attacks are in-scope
      2.1  and the protocol is susceptible to
      2.2  and the protocol protects against

   At least the following forms of attack MUST be considered:
   eavesdropping, replay, message insertion, deletion, modification, and
   man-in-the-middle.  Potential denial of service attacks MUST be
   identified as well.  If the protocol incorporates cryptographic
   protection mechanisms, it should be clearly indicated which portions
   of the data are protected and what the protections are (i.e.,
   integrity only, confidentiality, and/or endpoint authentication,
   etc.).  Some indication should also be given to what sorts of attacks
   the cryptographic protection is susceptible.  Data which should be
   held secret (keying material, random seeds, etc.) should be clearly
   labeled.

   If the technology involves authentication, particularly user-host
   authentication, the security of the authentication method MUST be
   clearly specified.  That is, authors MUST document the assumptions
   that the security of this authentication method is predicated upon.
   For instance, in the case of the UNIX username/password login method,
   a statement to the effect of:

      Authentication in the system is secure only to the extent that it
      is difficult to guess or obtain a ASCII password that is a maximum
      of 8 characters long.  These passwords can be obtained by sniffing
      telnet sessions or by running the 'crack' program using the
      contents of the /etc/passwd file.  Attempts to protect against
      on-line password guessing by (1) disconnecting after several
      unsuccessful login attempts and (2) waiting between successive
      password prompts is effective only to the extent that attackers
      are impatient.

      Because the /etc/passwd file maps usernames to user ids, groups,
      etc. it must be world readable.  In order to permit this usage but
      make running crack more difficult, the file is often split into
      /etc/passwd and a 'shadow' password file.  The shadow file is not
      world readable and contains the encrypted password.  The regular
      /etc/passwd file contains a dummy password in its place.

   It is insufficient to simply state that one's protocol should be run
   over some lower layer security protocol.  If a system relies upon
   lower layer security services for security, the protections those





Rescorla & Korver        Best Current Practice                 [Page 27]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   services are expected to provide MUST be clearly specified.  In
   addition, the resultant properties of the combined system need to be
   specified.

   Note: In general, the IESG will not approve standards track protocols
   which do not provide for strong authentication, either internal to
   the protocol or through tight binding to a lower layer security
   protocol.

   The threat environment addressed by the Security Considerations
   section MUST at a minimum include deployment across the global
   Internet across multiple administrative boundaries without assuming
   that firewalls are in place, even if only to provide justification
   for why such consideration is out of scope for the protocol.  It is
   not acceptable to only discuss threats applicable to LANs and ignore
   the broader threat environment.  All IETF standards-track protocols
   are considered likely to have deployment in the global Internet.  In
   some cases, there might be an Applicability Statement discouraging
   use of a technology or protocol in a particular environment.
   Nonetheless, the security issues of broader deployment should be
   discussed in the document.

   There should be a clear description of the residual risk to the user
   or operator of that protocol after threat mitigation has been
   deployed.  Such risks might arise from compromise in a related
   protocol (e.g., IPsec is useless if key management has been
   compromised), from incorrect implementation, compromise of the
   security technology used for risk reduction (e.g., a cipher with a
   40-bit key), or there might be risks that are not addressed by the
   protocol specification (e.g., denial of service attacks on an
   underlying link protocol).  Particular care should be taken in
   situations where the compromise of a single system would compromise
   an entire protocol.  For instance, in general protocol designers
   assume that end-systems are inviolate and don't worry about physical
   attack.  However, in cases (such as a certificate authority) where
   compromise of a single system could lead to widespread compromises,
   it is appropriate to consider systems and physical security as well.

   There should also be some discussion of potential security risks
   arising from potential misapplications of the protocol or technology
   described in the RFC.  This might be coupled with an Applicability
   Statement for that RFC.

6. Examples

   This section consists of some example security considerations
   sections, intended to give the reader a flavor of what's intended by
   this document.



Rescorla & Korver        Best Current Practice                 [Page 28]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   The first example is a 'retrospective' example, applying the criteria
   of this document to an existing widely deployed protocol, SMTP.  The
   second example is a good security considerations section clipped from
   a current protocol.

6.1. SMTP

   When RFC 821 was written, Security Considerations sections were not
   required in RFCs, and none is contained in that document.  [RFC 2821]
   updated RFC 821 and added a detailed security considerations section.
   We reproduce here the Security Considerations section from that
   document (with new section numbers).  Our comments are indented and
   prefaced with 'NOTE:'.  We also add a number of new sections to cover
   topics we consider important.  Those sections are marked with [NEW]
   in the section header.

6.1.1. Security Considerations

6.1.1.1. Mail Security and Spoofing

   SMTP mail is inherently insecure in that it is feasible for even
   fairly casual users to negotiate directly with receiving and relaying
   SMTP servers and create messages that will trick a naive recipient
   into believing that they came from somewhere else.  Constructing such
   a message so that the "spoofed" behavior cannot be detected by an
   expert is somewhat more difficult, but not sufficiently so as to be a
   deterrent to someone who is determined and knowledgeable.
   Consequently, as knowledge of Internet mail increases, so does the
   knowledge that SMTP mail inherently cannot be authenticated, or
   integrity checks provided, at the transport level.  Real mail
   security lies only in end-to-end methods involving the message
   bodies, such as those which use digital signatures (see [14] and,
   e.g., PGP [4] or S/MIME [31]).

      NOTE: One bad approach to sender authentication is [IDENT] in
      which the receiving mail server contacts the alleged sender and
      asks for the username of the sender.  This is a bad idea for a
      number of reasons, including but not limited to relaying, TCP
      connection hijacking, and simple lying by the origin server.
      Aside from the fact that IDENT is of low security value, use of
      IDENT by receiving sites can lead to operational problems.  Many
      sending sites blackhole IDENT requests, thus causing mail to be
      held until the receiving server's IDENT request times out.

   Various protocol extensions and configuration options that provide
   authentication at the transport level (e.g., from an SMTP client to
   an SMTP server) improve somewhat on the traditional situation
   described above.  However, unless they are accompanied by careful



Rescorla & Korver        Best Current Practice                 [Page 29]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   handoffs of responsibility in a carefully-designed trust environment,
   they remain inherently weaker than end-to-end mechanisms which use
   digitally signed messages rather than depending on the integrity of
   the transport system.

   Efforts to make it more difficult for users to set envelope return
   path and header "From" fields to point to valid addresses other than
   their own are largely misguided: they frustrate legitimate
   applications in which mail is sent by one user on behalf of another
   or in which error (or normal) replies should be directed to a special
   address.  (Systems that provide convenient ways for users to alter
   these fields on a per-message basis should attempt to establish a
   primary and permanent mailbox address for the user so that Sender
   fields within the message data can be generated sensibly.)

   This specification does not further address the authentication issues
   associated with SMTP other than to advocate that useful functionality
   not be disabled in the hope of providing some small margin of
   protection against an ignorant user who is trying to fake mail.

      NOTE: We have added additional material on communications security
      and SMTP in Section 6.1.2 In a final specification, the above text
      would be edited somewhat to reflect that fact.

6.1.1.2. Blind Copies

   Addresses that do not appear in the message headers may appear in the
   RCPT commands to an SMTP server for a number of reasons.  The two
   most common involve the use of a mailing address as a "list exploder"
   (a single address that resolves into multiple addresses) and the
   appearance of "blind copies".  Especially when more than one RCPT
   command is present, and in order to avoid defeating some of the
   purpose of these mechanisms, SMTP clients and servers SHOULD NOT copy
   the full set of RCPT command arguments into the headers, either as
   part of trace headers or as informational or private-extension
   headers.  Since this rule is often violated in practice, and cannot
   be enforced, sending SMTP systems that are aware of "bcc" use MAY
   find it helpful to send each blind copy as a separate message
   transaction containing only a single RCPT command.

   There is no inherent relationship between either "reverse" (from
   MAIL, SAML, etc., commands) or "forward" (RCPT) addresses in the SMTP
   transaction ("envelope") and the addresses in the headers.  Receiving
   systems SHOULD NOT attempt to deduce such relationships and use them







Rescorla & Korver        Best Current Practice                 [Page 30]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   to alter the headers of the message for delivery.  The popular
   "Apparently-to" header is a violation of this principle as well as a
   common source of unintended information disclosure and SHOULD NOT be
   used.

6.1.1.3. VRFY, EXPN, and Security

   As discussed in section 3.5, individual sites may want to disable
   either or both of VRFY or EXPN for security reasons.  As a corollary
   to the above, implementations that permit this MUST NOT appear to
   have verified addresses that are not, in fact, verified.  If a site
   disables these commands for security reasons, the SMTP server MUST
   return a 252 response, rather than a code that could be confused with
   successful or unsuccessful verification.

   Returning a 250 reply code with the address listed in the VRFY
   command after having checked it only for syntax violates this rule.
   Of course, an implementation that "supports" VRFY by always returning
   550 whether or not the address is valid is equally not in
   conformance.

   Within the last few years, the contents of mailing lists have become
   popular as an address information source for so-called "spammers."
   The use of EXPN to "harvest" addresses has increased as list
   administrators have installed protections against inappropriate uses
   of the lists themselves.  Implementations SHOULD still provide
   support for EXPN, but sites SHOULD carefully evaluate the tradeoffs.
   As authentication mechanisms are introduced into SMTP, some sites may
   choose to make EXPN available only to authenticated requesters.

      NOTE: It's not clear that disabling VRFY adds much protection,
      since it's often possible to discover whether an address is valid
      using RCPT TO.

6.1.1.4. Information Disclosure in Announcements

   There has been an ongoing debate about the tradeoffs between the
   debugging advantages of announcing server type and version (and,
   sometimes, even server domain name) in the greeting response or in
   response to the HELP command and the disadvantages of exposing
   information that might be useful in a potential hostile attack.  The
   utility of the debugging information is beyond doubt.  Those who
   argue for making it available point out that it is far better to
   actually secure an SMTP server rather than hope that trying to
   conceal known vulnerabilities by hiding the server's precise identity
   will provide more protection.  Sites are encouraged to evaluate the





Rescorla & Korver        Best Current Practice                 [Page 31]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   tradeoff with that issue in mind; implementations are strongly
   encouraged to minimally provide for making type and version
   information available in some way to other network hosts.

6.1.1.5. Information Disclosure in Trace Fields

   In some circumstances, such as when mail originates from within a LAN
   whose hosts are not directly on the public Internet, trace
   ("Received") fields produced in conformance with this specification
   may disclose host names and similar information that would not
   normally be available.  This ordinarily does not pose a problem, but
   sites with special concerns about name disclosure should be aware of
   it.  Also, the optional FOR clause should be supplied with caution or
   not at all when multiple recipients are involved lest it
   inadvertently disclose the identities of "blind copy" recipients to
   others.

6.1.1.6. Information Disclosure in Message Forwarding

   As discussed in section 3.4, use of the 251 or 551 reply codes to
   identify the replacement address associated with a mailbox may
   inadvertently disclose sensitive information.  Sites that are
   concerned about those issues should ensure that they select and
   configure servers appropriately.

6.1.1.7. Scope of Operation of SMTP Servers

   It is a well-established principle that an SMTP server may refuse to
   accept mail for any operational or technical reason that makes sense
   to the site providing the server.  However, cooperation among sites
   and installations makes the Internet possible.  If sites take
   excessive advantage of the right to reject traffic, the ubiquity of
   email availability (one of the strengths of the Internet) will be
   threatened; considerable care should be taken and balance maintained
   if a site decides to be selective about the traffic it will accept
   and process.

   In recent years, use of the relay function through arbitrary sites
   has been used as part of hostile efforts to hide the actual origins
   of mail.  Some sites have decided to limit the use of the relay
   function to known or identifiable sources, and implementations SHOULD
   provide the capability to perform this type of filtering.  When mail
   is rejected for these or other policy reasons, a 550 code SHOULD be
   used in response to EHLO, MAIL, or RCPT as appropriate.







Rescorla & Korver        Best Current Practice                 [Page 32]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


6.1.1.8. Inappropriate Usage [NEW]

   SMTP itself provides no protection is provided against unsolicited
   commercial mass e-mail (aka spam).  It is extremely difficult to tell
   a priori whether a given message is spam or not.  From a protocol
   perspective, spam is indistinguishable from other e-mail -- the
   distinction is almost entirely social and often quite subtle.  (For
   instance, is a message from a merchant from whom you've purchased
   items before advertising similar items spam?) SMTP spam-suppression
   mechanisms are generally limited to identifying known spam senders
   and either refusing to service them or target them for
   punishment/disconnection.  [RFC-2505] provides extensive guidance on
   making SMTP servers spam-resistant.  We provide a brief discussion of
   the topic here.

   The primary tool for refusal to service spammers is the blacklist.
   Some authority such as [MAPS] collects and publishes a list of known
   spammers.  Individual SMTP servers then block the blacklisted
   offenders (generally by IP address).

   In order to avoid being blacklisted or otherwise identified, spammers
   often attempt to obscure their identity, either simply by sending a
   false SMTP identity or by forwarding their mail through an Open Relay
   -- an SMTP server which will perform mail relaying for any sender.
   As a consequence, there are now blacklists [ORBS] of open relays as
   well.

6.1.1.8.1. Closed Relaying [NEW]

   To avoid being used for spam forwarding, many SMTP servers operate as
   closed relays, providing relaying service only for clients who they
   can identify.  Such relays should generally insist that senders
   advertise a sending address consistent with their known identity.  If
   the relay is providing service for an identifiable network (such as a
   corporate network or an ISP's network) then it is sufficient to block
   all other IP addresses).  In other cases, explicit authentication
   must be used.  The two standard choices for this are TLS [STARTTLS]
   and SASL [SASLSMTP].

6.1.1.8.2. Endpoints [NEW]

   Realistically, SMTP endpoints cannot refuse to deny service to
   unauthenticated senders.  Since the vast majority of senders are
   unauthenticated, this would break Internet mail interoperability.
   The exception to this is when the endpoint server should only be






Rescorla & Korver        Best Current Practice                 [Page 33]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   receiving mail from some other server which can itself receive
   unauthenticated messages.  For instance, a company might operate a
   public gateway but configure its internal servers to only talk to the
   gateway.

6.1.2. Communications security issues [NEW]

   SMTP itself provides no communications security, and therefore a
   large number of attacks are possible.  A passive attack is sufficient
   to recover the text of messages transmitted with SMTP.  No endpoint
   authentication is provided by the protocol.  Sender spoofing is
   trivial, and therefore forging email messages is trivial.  Some
   implementations do add header lines with hostnames derived through
   reverse name resolution (which is only secure to the extent that it
   is difficult to spoof DNS -- not very), although these header lines
   are normally not displayed to users.  Receiver spoofing is also
   fairly straight-forward, either using TCP connection hijacking or DNS
   spoofing.  Moreover, since email messages often pass through SMTP
   gateways, all intermediate gateways must be trusted, a condition
   nearly impossible on the global Internet.

   Several approaches are available for alleviating these threats.  In
   order of increasingly high level in the protocol stack, we have:

      SMTP over IPSEC
      SMTP/TLS
      S/MIME and PGP/MIME

6.1.2.1. SMTP over IPSEC [NEW]

   An SMTP connection run over IPSEC can provide confidentiality for the
   message between the sender and the first hop SMTP gateway, or between
   any pair of connected SMTP gateways.  That is to say, it provides
   channel security for the SMTP connections.  In a situation where the
   message goes directly from the client to the receiver's gateway, this
   may provide substantial security (though the receiver must still
   trust the gateway).  Protection is provided against replay attacks,
   since the data itself is protected and the packets cannot be
   replayed.

   Endpoint identification is a problem, however, unless the receiver's
   address can be directly cryptographically authenticated.  Sender
   identification is not generally available, since generally only the
   sender's machine is authenticated, not the sender himself.
   Furthermore, the identity of the sender simply appears in the From
   header of the message, so it is easily spoofable by the sender.
   Finally, unless the security policy is set extremely strictly, there
   is also an active downgrade to cleartext attack.



Rescorla & Korver        Best Current Practice                 [Page 34]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   Another problem with IPsec as a security solution for SMTP is the
   lack of a standard IPsec API.  In order to take advantage of IPsec,
   applications in general need to be able to instruct the IPsec
   implementation about their security policies and discover what
   protection has been applied to their connections.  Without a standard
   API this is very difficult to do portably.

   Implementors of SMTP servers or SMTP administrators MUST NOT assume
   that IPsec will be available unless they have reason to believe that
   it will be (such as the existence of preexisting association between
   two machines).  However, it may be a reasonable procedure to attempt
   to create an IPsec association opportunistically to a peer server
   when mail is delivered.  Note that in cases where IPsec is used to
   provide a VPN tunnel between two sites, this is of substantial
   security value, particularly to the extent that confidentiality is
   provided, subject to the caveats mentioned above.  Also see
   [USEIPSEC] for general guidance on the applicability of IPsec.

6.1.2.2. SMTP/TLS [NEW]

   SMTP can be combined with TLS as described in [STARTTLS].  This
   provides similar protection to that provided when using IPSEC.  Since
   TLS certificates typically contain the server's host name, recipient
   authentication may be slightly more obvious, but is still susceptible
   to DNS spoofing attacks.  Notably, common implementations of TLS
   contain a US exportable (and hence low security) mode.  Applications
   desiring high security should ensure that this mode is disabled.
   Protection is provided against replay attacks, since the data itself
   is protected and the packets cannot be replayed.  [Note:  The
   Security Considerations section of the SMTP over TLS document is
   quite good and bears reading as an example of how to do things.]

6.1.2.3. S/MIME and PGP/MIME [NEW]

   S/MIME and PGP/MIME are both message oriented security protocols.
   They provide object security for individual messages.  With various
   settings, sender and recipient authentication and confidentiality may
   be provided.  More importantly, the identification is not of the
   sending and receiving machines, but rather of the sender and
   recipient themselves.  (Or, at least, of cryptographic keys
   corresponding to the sender and recipient.)  Consequently, end-to-end
   security may be obtained.  Note, however, that no protection is
   provided against replay attacks.  Note also that S/MIME and PGP/MIME
   generally provide identifying marks for both sender and receiver.
   Thus even when confidentiality is provided, traffic analysis is still
   possible.





Rescorla & Korver        Best Current Practice                 [Page 35]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


6.1.3. Denial of Service [NEW]

   None of these security measures provides any real protection against
   denial of service.  SMTP connections can easily be used to tie up
   system resources in a number of ways, including excessive port
   consumption, excessive disk usage (email is typically delivered to
   disk files), and excessive memory consumption (sendmail, for
   instance, is fairly large, and typically forks a new process to deal
   with each message.)

   If transport- or application-layer security is used for SMTP
   connections, it is possible to mount a variety of attacks on
   individual connections using forged RSTs or other kinds of packet
   injection.

6.2. VRRP

   The second example is from VRRP, the Virtual Router Redundance
   Protocol ([VRRP]).  We reproduce here the Security Considerations
   section from that document (with new section numbers).  Our comments
   are indented and prefaced with 'NOTE:'.

6.2.1. Security Considerations

   VRRP is designed for a range of internetworking environments that may
   employ different security policies.  The protocol includes several
   authentication methods ranging from no authentication, simple clear
   text passwords, and strong authentication using IP Authentication
   with MD5 HMAC.  The details on each approach including possible
   attacks and recommended environments follows.

   Independent of any authentication type VRRP includes a mechanism
   (setting TTL=255, checking on receipt) that protects against VRRP
   packets being injected from another remote network.  This limits most
   vulnerabilities to local attacks.

      NOTE: The security measures discussed in the following sections
      only provide various kinds of authentication.  No confidentiality
      is provided at all.  This should be explicitly described as
      outside the scope.

6.2.1.1. No Authentication

   The use of this authentication type means that VRRP protocol
   exchanges are not authenticated.  This type of authentication SHOULD
   only be used in environments were there is minimal security risk and
   little chance for configuration errors (e.g., two VRRP routers on a
   LAN).



Rescorla & Korver        Best Current Practice                 [Page 36]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


6.2.1.2. Simple Text Password

   The use of this authentication type means that VRRP protocol
   exchanges are authenticated by a simple clear text password.

   This type of authentication is useful to protect against accidental
   misconfiguration of routers on a LAN.  It protects against routers
   inadvertently backing up another router.  A new router must first be
   configured with the correct password before it can run VRRP with
   another router.  This type of authentication does not protect against
   hostile attacks where the password can be learned by a node snooping
   VRRP packets on the LAN.  The Simple Text Authentication combined
   with the TTL check makes it difficult for a VRRP packet to be sent
   from another LAN to disrupt VRRP operation.

   This type of authentication is RECOMMENDED when there is minimal risk
   of nodes on a LAN actively disrupting VRRP operation.  If this type
   of authentication is used the user should be aware that this clear
   text password is sent frequently, and therefore should not be the
   same as any security significant password.

      NOTE: This section should be clearer.  The basic point is that no
      authentication and Simple Text are only useful for a very limited
      threat model, namely that none of the nodes on the local LAN are
      hostile.  The TTL check prevents hostile nodes off-LAN from posing
      as valid nodes, but nothing stops hostile nodes on-LAN from
      impersonating authorized nodes.  This is not a particularly
      realistic threat model in many situations.  In particular, it's
      extremely brittle: the compromise of any node the LAN allows
      reconfiguration of the VRRP nodes.

6.2.1.3. IP Authentication Header

   The use of this authentication type means the VRRP protocol exchanges
   are authenticated using the mechanisms defined by the IP
   Authentication Header [AH] using [HMAC].  This provides strong
   protection against configuration errors, replay attacks, and packet
   corruption/modification.

   This type of authentication is RECOMMENDED when there is limited
   control over the administration of nodes on a LAN.  While this type
   of authentication does protect the operation of VRRP, there are other
   types of attacks that may be employed on shared media links (e.g.,
   generation of bogus ARP replies) which are independent from VRRP and
   are not protected.






Rescorla & Korver        Best Current Practice                 [Page 37]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


      NOTE: It's a mistake to have AH be a RECOMMENDED in this context.
      Since AH is the only mechanism that protects VRRP against attack
      from other nodes on the same LAN, it should be a MUST for cases
      where there are untrusted nodes on the same network.  In any case,
      AH should be a MUST implement.

      NOTE: There's an important piece of security analysis that's only
      hinted at in this document, namely the cost/benefit tradeoff of
      VRRP authentication.

   [The rest of this section is NEW material]
   The threat that VRRP authentication is intended to prevent is an
   attacker arranging to be the VRRP master.  This would be done by
   joining the group (probably multiple times), gagging the master and
   then electing oneself master.  Such a node could then direct traffic
   in arbitrary undesirable ways.

   However, it is not necessary for an attacker to be the VRRP master to
   do this.  An attacker can do similar kinds of damage to the network
   by forging ARP packets or (on switched networks) fooling the switch
   VRRP authentication offers no real protection against these attacks.

   Unfortunately, authentication makes VRRP networks very brittle in the
   face of misconfiguration.  Consider what happens if two nodes are
   configured with different passwords.  Each will reject messages from
   the other and therefore both will attempt to be master.  This creates
   substantial network instability.

   This set of cost/benefit tradeoffs suggests that VRRP authentication
   is a bad idea, since the incremental security benefit is marginal but
   the incremental risk is high.  This judgment should be revisited if
   the current set of non-VRRP threats are removed.

7. Acknowledgments

   This document is heavily based on a note written by Ran Atkinson in
   1997.  That note was written after the IAB Security Workshop held in
   early 1997, based on input from everyone at that workshop.  Some of
   the specific text above was taken from Ran's original document, and
   some of that text was taken from an email message written by Fred
   Baker.  The other primary source for this document is specific
   comments received from Steve Bellovin.  Early review of this document
   was done by Lisa Dusseault and Mark Schertler.  Other useful comments
   were received from Bill Fenner, Ned Freed, Lawrence Greenfield, Steve
   Kent, Allison Mankin and Kurt Zeilenga.






Rescorla & Korver        Best Current Practice                 [Page 38]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


8. Normative References

   [AH]       Kent, S. and R. Atkinson, "IP Authentication Header", RFC
              2402, November 1998.

   [DNSSEC]   Eastlake, D., "Domain Name System Security Extensions",
              RFC 2535, March 1999.

   [ENCOPT]   Tso, T., "Telnet Data Encryption Option", RFC 2946,
              September, 2000.

   [ESP]      Kent, S. and R. Atkinson, "IP Encapsulating Security
              Payload (ESP)", RFC 2406, November 1998.

   [GSS]      Linn, J., "Generic Security Services Application Program
              Interface Version 2, Update 1", RFC 2743, January 2000.

   [HTTP]     Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P. and T. Berners-Lee, "HyperText
              Transfer Protocol", RFC 2616, June 1999.

   [HTTPTLS]  Rescorla, E., "HTTP over TLS", RFC 2818, May 2000.

   [HMAC]     Madson, C. and R. Glenn, "The Use of HMAC-MD5-96 within
              ESP and AH", RFC 2403, November 1998.

   KERBEROS]  Kohl, J. and C. Neuman, "The Kerberos Network
              Authentication Service (V5)", RFC 1510, September 1993.

   [KEYWORDS] Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [OTP]      Haller, N., Metz, C., Nesser, P. and M. Straw, "A One-Time
              Password System", STD 61, RFC 2289, February 1998.

   [PHOTURIS] Karn, P. and W. Simpson, "Photuris: Session-Key Management
              Protocol", RFC 2522, March 1999.

   [PKIX]     Housley, R., Polk, W., Ford, W. and D. Solo, "Internet
              X.509 "Public Key Infrastructure Certificate and
              Certificate Restoration List (CRL) Profile", RFC 3280,
              April 2002.

   [RFC-2223] Postel J. and J. Reynolds, "Instructions to RFC Authors",
              RFC 2223, October 1997.

   [RFC-2505] Lindberg, G., "Anti-Spam Recommendations for SMTP MTAs",
              BCP 30, RFC 2505, February 1999.



Rescorla & Korver        Best Current Practice                 [Page 39]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   [RFC-2821] Klensin, J., "Simple Mail Transfer Protocol", RFC 2821,
              April 2001.

   [SASL]     Myers, J., "Simple Authentication and Security Layer
              (SASL)", RFC 2222, October 1997.

   [SPKI]     Ellison, C., Frantz, B., Lampson, B., Rivest, R., Thomas,
              B. and T. Ylonen, "SPKI Certificate Theory",  RFC 2693,
              September 1999.

   [SSH]      Ylonen, T., "SSH - Secure Login Connections Over the
              Internet", 6th USENIX Security Symposium, p. 37-42, July
              1996.

   [SASLSMTP] Myers, J., "SMTP Service Extension for Authentication",
              RFC 2554, March 1999.

   [STARTTLS] Hoffman, P., "SMTP Service Extension for Secure SMTP over
              Transport Layer Security", RFC 3207, February 2002.

   [S-HTTP]   Rescorla, E. and A. Schiffman, "The Secure HyperText
              Transfer Protocol", RFC 2660, August 1999.

   [S/MIME]   Ramsdell, B., Editor, "S/MIME Version 3 Message
              Specification", RFC 2633, June 1999.

   [TELNET]   Postel, J. and J. Reynolds, "Telnet Protocol
              Specification", STD 8, RFC 854, May 1983.

   [TLS]      Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              RFC 2246, January 1999.

   [TLSEXT]   Blake-Wilson, S., Nystrom, M., Hopwood, D. and J.
              Mikkelsen, "Transport Layer Security (TLS) Extensions",
              RFC 3546, May 2003.

   [TCPSYN]   "TCP SYN Flooding and IP Spoofing Attacks", CERT Advisory
              CA-1996-21, 19 September 1996, CERT.
              http://www.cert.org/advisories/CA-1996-21.html

   [UPGRADE]  Khare, R. and S. Lawrence, "Upgrading to TLS Within
              HTTP/1.1", RFC 2817, May 2000.

   [URL]      Berners-Lee, T., Masinter, M. and M. McCahill, "Uniform
              Resource Locators (URL)", RFC 1738, December 1994.






Rescorla & Korver        Best Current Practice                 [Page 40]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   [VRRP]     Knight, S., Weaver, D., Whipple, D., Hinden, R., Mitzel,
              D., Hunt, P., Higginson, P., Shand, M. and A. Lindemn,
              "Virtual Router Redundancy Protocol", RFC 2338, April
              1998.

9. Informative References

   [DDOS]     "Denial-Of-Service Tools" CERT Advisory CA-1999-17, 28
              December 1999, CERT http://www.cert.org/advisories/CA-
              1999-17.html

   [EKE]      Bellovin, S., Merritt, M., "Encrypted Key Exchange:
              Password-based protocols secure against dictionary
              attacks", Proceedings of the IEEE Symposium on Research in
              Security and Privacy, May 1992.

   [IDENT]    St. Johns, M. and M. Rose, "Identification Protocol", RFC
              1414, February 1993.

   [INTAUTH]  Haller, N. and R. Atkinson, "On Internet Authentication",
              RFC 1704, October 1994.

   [IPSPPROB] Bellovin, S. M., "Problem Areas for the IP Security
              Protocols", Proceedings of the Sixth Usenix UNIX Security
              Symposium, July 1996.

   [KLEIN]    Klein, D.V., "Foiling the Cracker: A Survey of and
              Improvements to Password Security",  1990.

   [NNTP]     Kantor, B. and P. Lapsley, "Network News Transfer
              Protocol", RFC 977, February 1986.

   [POP]      Myers, J. and M. Rose, "Post Office Protocol - Version 3",
              STD 53, RFC 1939, May 1996.

   [SEQNUM]   Morris, R.T., "A Weakness in the 4.2 BSD UNIX TCP/IP
              Software", AT&T Bell Laboratories, CSTR 117, 1985.

   [SOAP]     Box, D., Ehnebuske, D., Kakivaya, G., Layman, A.,
              Mendelsoh, N., Nielsen, H., Thatte, S., Winer, D., "Simple
              Object Access Protocol (SOAP) 1.1", May 2000.

   [SPEKE]    Jablon, D., "Strong Password-Only Authenticated Key
              Exchange", Computer Communication Review, ACM SIGCOMM,
              vol. 26, no. 5, pp. 5-26, October 1996.

   [SRP]      Wu T., "The Secure Remote Password Protocol", ISOC NDSS
              Symposium, 1998.



Rescorla & Korver        Best Current Practice                 [Page 41]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


   [USEIPSEC] Bellovin, S., "Guidelines for Mandating the Use of IPsec",
              Work in Progress.

   [WEP]      Borisov, N., Goldberg, I., Wagner, D., "Intercepting
              Mobile Communications: The Insecurity of 802.11",
              http://www.isaac.cs.berkeley.edu/isaac/wep-draft.pdf

10. Security Considerations

   This entire document is about security considerations.









































Rescorla & Korver        Best Current Practice                 [Page 42]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


Appendix A.

   IAB Members at the time of this writing

   Harald Alvestrand
   Ran Atkinson
   Rob Austein
   Fred Baker
   Leslie Daigle
   Steve Deering
   Sally Floyd
   Ted Hardie
   Geoff Huston
   Charlie Kaufman
   James Kempf
   Eric Rescorla
   Mike St. Johns

Authors' Addresses

   Eric Rescorla
   RTFM, Inc.
   2439 Alvin Drive
   Mountain View, CA 94043

   Phone: (650)-320-8549
   EMail: ekr@rtfm.com


   Brian Korver
   Xythos Software, Inc.
   77 Maiden Lane, 6th Floor
   San Francisco, CA, 94108

   Phone: (415)-248-3800
   EMail: briank@xythos.com


   Internet Architecture Board
   IAB
   EMail: iab@iab.org










Rescorla & Korver        Best Current Practice                 [Page 43]
   __________________________________________________________________


RFC 3552           Security Considerations Guidelines          July 2003


Full Copyright Statement

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Rescorla & Korver        Best Current Practice                 [Page 44]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2] [IPR]
   [Errata]
   Obsoleted by: 8446 PROPOSED STANDARD
   Updated by: 5746, 5878, 6176, 7465, 7507, 7568, 7627, 7685, 7905, 7919,
   8447 Errata Exist
Network Working Group                                          T. Dierks
Request for Comments: 5246                                   Independent
Obsoletes: 3268, 4346, 4366                                  E. Rescorla
Updates: 4492                                                 RTFM, Inc.
Category: Standards Track                                    August 2008


              The Transport Layer Security (TLS) Protocol
                              Version 1.2

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   This document specifies Version 1.2 of the Transport Layer Security
   (TLS) protocol.  The TLS protocol provides communications security
   over the Internet.  The protocol allows client/server applications to
   communicate in a way that is designed to prevent eavesdropping,
   tampering, or message forgery.

Table of Contents

   1. Introduction ....................................................4
      1.1. Requirements Terminology ...................................5
      1.2. Major Differences from TLS 1.1 .............................5
   2. Goals ...........................................................6
   3. Goals of This Document ..........................................7
   4. Presentation Language ...........................................7
      4.1. Basic Block Size ...........................................7
      4.2. Miscellaneous ..............................................8
      4.3. Vectors ....................................................8
      4.4. Numbers ....................................................9
      4.5. Enumerateds ................................................9
      4.6. Constructed Types .........................................10
           4.6.1. Variants ...........................................10
      4.7. Cryptographic Attributes ..................................12
      4.8. Constants .................................................14
   5. HMAC and the Pseudorandom Function .............................14
   6. The TLS Record Protocol ........................................15
      6.1. Connection States .........................................16
      6.2. Record Layer ..............................................19
           6.2.1. Fragmentation ......................................19



Dierks & Rescorla           Standards Track                     [Page 1]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


           6.2.2. Record Compression and Decompression ...............20
           6.2.3. Record Payload Protection ..........................21
                  6.2.3.1. Null or Standard Stream Cipher ............22
                  6.2.3.2. CBC Block Cipher ..........................22
                  6.2.3.3. AEAD Ciphers ..............................24
      6.3. Key Calculation ...........................................25
   7. The TLS Handshaking Protocols ..................................26
      7.1. Change Cipher Spec Protocol ...............................27
      7.2. Alert Protocol ............................................28
           7.2.1. Closure Alerts .....................................29
           7.2.2. Error Alerts .......................................30
      7.3. Handshake Protocol Overview ...............................33
      7.4. Handshake Protocol ........................................37
           7.4.1. Hello Messages .....................................38
                  7.4.1.1. Hello Request .............................38
                  7.4.1.2. Client Hello ..............................39
                  7.4.1.3. Server Hello ..............................42
                  7.4.1.4. Hello Extensions ..........................44
                           7.4.1.4.1. Signature Algorithms ...........45
           7.4.2. Server Certificate .................................47
           7.4.3. Server Key Exchange Message ........................50
           7.4.4. Certificate Request ................................53
           7.4.5. Server Hello Done ..................................55
           7.4.6. Client Certificate .................................55
           7.4.7. Client Key Exchange Message ........................57
                  7.4.7.1. RSA-Encrypted Premaster Secret Message ....58
                  7.4.7.2. Client Diffie-Hellman Public Value ........61
           7.4.8. Certificate Verify .................................62
           7.4.9. Finished ...........................................63
   8. Cryptographic Computations .....................................64
      8.1. Computing the Master Secret ...............................64
           8.1.1. RSA ................................................65
           8.1.2. Diffie-Hellman .....................................65
   9. Mandatory Cipher Suites ........................................65
   10. Application Data Protocol .....................................65
   11. Security Considerations .......................................65
   12. IANA Considerations ...........................................65
   Appendix A. Protocol Data Structures and Constant Values ..........68
      A.1. Record Layer ..............................................68
      A.2. Change Cipher Specs Message ...............................69
      A.3. Alert Messages ............................................69
      A.4. Handshake Protocol ........................................70
           A.4.1. Hello Messages .....................................71
           A.4.2. Server Authentication and Key Exchange Messages ....72
           A.4.3. Client Authentication and Key Exchange Messages ....74
           A.4.4. Handshake Finalization Message .....................74
      A.5. The Cipher Suite ..........................................75
      A.6. The Security Parameters ...................................77



Dierks & Rescorla           Standards Track                     [Page 2]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      A.7. Changes to RFC 4492 .......................................78
   Appendix B. Glossary ..............................................78
   Appendix C. Cipher Suite Definitions ..............................83
   Appendix D. Implementation Notes ..................................85
      D.1. Random Number Generation and Seeding ......................85
      D.2. Certificates and Authentication ...........................85
      D.3. Cipher Suites .............................................85
      D.4. Implementation Pitfalls ...................................85
   Appendix E. Backward Compatibility ................................87
      E.1. Compatibility with TLS 1.0/1.1 and SSL 3.0 ................87
      E.2. Compatibility with SSL 2.0 ................................88
      E.3. Avoiding Man-in-the-Middle Version Rollback ...............90
   Appendix F. Security Analysis .....................................91
      F.1. Handshake Protocol ........................................91
           F.1.1. Authentication and Key Exchange ....................91
                  F.1.1.1. Anonymous Key Exchange ....................91
                  F.1.1.2. RSA Key Exchange and Authentication .......92
                  F.1.1.3. Diffie-Hellman Key Exchange with
                           Authentication ............................92
           F.1.2. Version Rollback Attacks ...........................93
           F.1.3. Detecting Attacks Against the Handshake Protocol ...94
           F.1.4. Resuming Sessions ..................................94
      F.2. Protecting Application Data ...............................94
      F.3. Explicit IVs ..............................................95
      F.4. Security of Composite Cipher Modes ........................95
      F.5. Denial of Service .........................................96
      F.6. Final Notes ...............................................96
   Normative References ..............................................97
   Informative References ............................................98
   Working Group Information ........................................101
   Contributors .....................................................101




















Dierks & Rescorla           Standards Track                     [Page 3]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


1.  Introduction

   The primary goal of the TLS protocol is to provide privacy and data
   integrity between two communicating applications.  The protocol is
   composed of two layers: the TLS Record Protocol and the TLS Handshake
   Protocol.  At the lowest level, layered on top of some reliable
   transport protocol (e.g., TCP [TCP]), is the TLS Record Protocol.
   The TLS Record Protocol provides connection security that has two
   basic properties:

   -  The connection is private.  Symmetric cryptography is used for
      data encryption (e.g., AES [AES], RC4 [SCH], etc.).  The keys for
      this symmetric encryption are generated uniquely for each
      connection and are based on a secret negotiated by another
      protocol (such as the TLS Handshake Protocol).  The Record
      Protocol can also be used without encryption.

   -  The connection is reliable.  Message transport includes a message
      integrity check using a keyed MAC.  Secure hash functions (e.g.,
      SHA-1, etc.) are used for MAC computations.  The Record Protocol
      can operate without a MAC, but is generally only used in this mode
      while another protocol is using the Record Protocol as a transport
      for negotiating security parameters.

   The TLS Record Protocol is used for encapsulation of various higher-
   level protocols.  One such encapsulated protocol, the TLS Handshake
   Protocol, allows the server and client to authenticate each other and
   to negotiate an encryption algorithm and cryptographic keys before
   the application protocol transmits or receives its first byte of
   data.  The TLS Handshake Protocol provides connection security that
   has three basic properties:

   -  The peer's identity can be authenticated using asymmetric, or
      public key, cryptography (e.g., RSA [RSA], DSA [DSS], etc.).  This
      authentication can be made optional, but is generally required for
      at least one of the peers.

   -  The negotiation of a shared secret is secure: the negotiated
      secret is unavailable to eavesdroppers, and for any authenticated
      connection the secret cannot be obtained, even by an attacker who
      can place himself in the middle of the connection.

   -  The negotiation is reliable: no attacker can modify the
      negotiation communication without being detected by the parties to
      the communication.






Dierks & Rescorla           Standards Track                     [Page 4]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   One advantage of TLS is that it is application protocol independent.
   Higher-level protocols can layer on top of the TLS protocol
   transparently.  The TLS standard, however, does not specify how
   protocols add security with TLS; the decisions on how to initiate TLS
   handshaking and how to interpret the authentication certificates
   exchanged are left to the judgment of the designers and implementors
   of protocols that run on top of TLS.

1.1.  Requirements Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [REQ].

1.2.  Major Differences from TLS 1.1

   This document is a revision of the TLS 1.1 [TLS1.1] protocol which
   contains improved flexibility, particularly for negotiation of
   cryptographic algorithms.  The major changes are:

   -  The MD5/SHA-1 combination in the pseudorandom function (PRF) has
      been replaced with cipher-suite-specified PRFs.  All cipher suites
      in this document use P_SHA256.

   -  The MD5/SHA-1 combination in the digitally-signed element has been
      replaced with a single hash.  Signed elements now include a field
      that explicitly specifies the hash algorithm used.

   -  Substantial cleanup to the client's and server's ability to
      specify which hash and signature algorithms they will accept.
      Note that this also relaxes some of the constraints on signature
      and hash algorithms from previous versions of TLS.

   -  Addition of support for authenticated encryption with additional
      data modes.

   -  TLS Extensions definition and AES Cipher Suites were merged in
      from external [TLSEXT] and [TLSAES].

   -  Tighter checking of EncryptedPreMasterSecret version numbers.

   -  Tightened up a number of requirements.

   -  Verify_data length now depends on the cipher suite (default is
      still 12).

   -  Cleaned up description of Bleichenbacher/Klima attack defenses.




Dierks & Rescorla           Standards Track                     [Page 5]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   -  Alerts MUST now be sent in many cases.

   -  After a certificate_request, if no certificates are available,
      clients now MUST send an empty certificate list.

   -  TLS_RSA_WITH_AES_128_CBC_SHA is now the mandatory to implement
      cipher suite.

   -  Added HMAC-SHA256 cipher suites.

   -  Removed IDEA and DES cipher suites.  They are now deprecated and
      will be documented in a separate document.

   -  Support for the SSLv2 backward-compatible hello is now a MAY, not
      a SHOULD, with sending it a SHOULD NOT.  Support will probably
      become a SHOULD NOT in the future.

   -  Added limited "fall-through" to the presentation language to allow
      multiple case arms to have the same encoding.

   -  Added an Implementation Pitfalls sections

   -  The usual clarifications and editorial work.

2.  Goals

   The goals of the TLS protocol, in order of priority, are as follows:

   1. Cryptographic security: TLS should be used to establish a secure
      connection between two parties.

   2. Interoperability: Independent programmers should be able to
      develop applications utilizing TLS that can successfully exchange
      cryptographic parameters without knowledge of one another's code.

   3. Extensibility: TLS seeks to provide a framework into which new
      public key and bulk encryption methods can be incorporated as
      necessary.  This will also accomplish two sub-goals: preventing
      the need to create a new protocol (and risking the introduction of
      possible new weaknesses) and avoiding the need to implement an
      entire new security library.

   4. Relative efficiency: Cryptographic operations tend to be highly
      CPU intensive, particularly public key operations.  For this
      reason, the TLS protocol has incorporated an optional session
      caching scheme to reduce the number of connections that need to be
      established from scratch.  Additionally, care has been taken to
      reduce network activity.



Dierks & Rescorla           Standards Track                     [Page 6]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


3.  Goals of This Document

   This document and the TLS protocol itself are based on the SSL 3.0
   Protocol Specification as published by Netscape.  The differences
   between this protocol and SSL 3.0 are not dramatic, but they are
   significant enough that the various versions of TLS and SSL 3.0 do
   not interoperate (although each protocol incorporates a mechanism by
   which an implementation can back down to prior versions).  This
   document is intended primarily for readers who will be implementing
   the protocol and for those doing cryptographic analysis of it.  The
   specification has been written with this in mind, and it is intended
   to reflect the needs of those two groups.  For that reason, many of
   the algorithm-dependent data structures and rules are included in the
   body of the text (as opposed to in an appendix), providing easier
   access to them.

   This document is not intended to supply any details of service
   definition or of interface definition, although it does cover select
   areas of policy as they are required for the maintenance of solid
   security.

4.  Presentation Language

   This document deals with the formatting of data in an external
   representation.  The following very basic and somewhat casually
   defined presentation syntax will be used.  The syntax draws from
   several sources in its structure.  Although it resembles the
   programming language "C" in its syntax and XDR [XDR] in both its
   syntax and intent, it would be risky to draw too many parallels.  The
   purpose of this presentation language is to document TLS only; it has
   no general application beyond that particular goal.

4.1.  Basic Block Size

   The representation of all data items is explicitly specified.  The
   basic data block size is one byte (i.e., 8 bits).  Multiple byte data
   items are concatenations of bytes, from left to right, from top to
   bottom.  From the byte stream, a multi-byte item (a numeric in the
   example) is formed (using C notation) by:

      value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
              ... | byte[n-1];

   This byte ordering for multi-byte values is the commonplace network
   byte order or big-endian format.






Dierks & Rescorla           Standards Track                     [Page 7]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


4.2.  Miscellaneous

   Comments begin with "/*" and end with "*/".

   Optional components are denoted by enclosing them in "[[ ]]" double
   brackets.

   Single-byte entities containing uninterpreted data are of type
   opaque.

4.3.  Vectors

   A vector (single-dimensioned array) is a stream of homogeneous data
   elements.  The size of the vector may be specified at documentation
   time or left unspecified until runtime.  In either case, the length
   declares the number of bytes, not the number of elements, in the
   vector.  The syntax for specifying a new type, T', that is a fixed-
   length vector of type T is

      T T'[n];

   Here, T' occupies n bytes in the data stream, where n is a multiple
   of the size of T.  The length of the vector is not included in the
   encoded stream.

   In the following example, Datum is defined to be three consecutive
   bytes that the protocol does not interpret, while Data is three
   consecutive Datum, consuming a total of nine bytes.

      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* 3 consecutive 3 byte vectors */

   Variable-length vectors are defined by specifying a subrange of legal
   lengths, inclusively, using the notation <floor..ceiling>.  When
   these are encoded, the actual length precedes the vector's contents
   in the byte stream.  The length will be in the form of a number
   consuming as many bytes as required to hold the vector's specified
   maximum (ceiling) length.  A variable-length vector with an actual
   length field of zero is referred to as an empty vector.

      T T'<floor..ceiling>;

   In the following example, mandatory is a vector that must contain
   between 300 and 400 bytes of type opaque.  It can never be empty.
   The actual length field consumes two bytes, a uint16, which is
   sufficient to represent the value 400 (see Section 4.4).  On the
   other hand, longer can represent up to 800 bytes of data, or 400
   uint16 elements, and it may be empty.  Its encoding will include a



Dierks & Rescorla           Standards Track                     [Page 8]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   two-byte actual length field prepended to the vector.  The length of
   an encoded vector must be an even multiple of the length of a single
   element (for example, a 17-byte vector of uint16 would be illegal).

      opaque mandatory<300..400>;
            /* length field is 2 bytes, cannot be empty */
      uint16 longer<0..800>;
            /* zero to 400 16-bit unsigned integers */

4.4.  Numbers

   The basic numeric data type is an unsigned byte (uint8).  All larger
   numeric data types are formed from fixed-length series of bytes
   concatenated as described in Section 4.1 and are also unsigned.  The
   following numeric types are predefined.

      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];

   All values, here and elsewhere in the specification, are stored in
   network byte (big-endian) order; the uint32 represented by the hex
   bytes 01 02 03 04 is equivalent to the decimal value 16909060.

   Note that in some cases (e.g., DH parameters) it is necessary to
   represent integers as opaque vectors.  In such cases, they are
   represented as unsigned integers (i.e., leading zero octets are not
   required even if the most significant bit is set).

4.5.  Enumerateds

   An additional sparse data type is available called enum.  A field of
   type enum can only assume the values declared in the definition.
   Each definition is a different type.  Only enumerateds of the same
   type may be assigned or compared.  Every element of an enumerated
   must be assigned a value, as demonstrated in the following example.
   Since the elements of the enumerated are not ordered, they can be
   assigned any unique value, in any order.

      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;

   An enumerated occupies as much space in the byte stream as would its
   maximal defined ordinal value.  The following definition would cause
   one byte to be used to carry fields of type Color.

      enum { red(3), blue(5), white(7) } Color;




Dierks & Rescorla           Standards Track                     [Page 9]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   One may optionally specify a value without its associated tag to
   force the width definition without defining a superfluous element.

   In the following example, Taste will consume two bytes in the data
   stream but can only assume the values 1, 2, or 4.

      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;

   The names of the elements of an enumeration are scoped within the
   defined type.  In the first example, a fully qualified reference to
   the second element of the enumeration would be Color.blue.  Such
   qualification is not required if the target of the assignment is well
   specified.

      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */

   For enumerateds that are never converted to external representation,
   the numerical information may be omitted.

      enum { low, medium, high } Amount;

4.6.  Constructed Types

   Structure types may be constructed from primitive types for
   convenience.  Each specification declares a new, unique type.  The
   syntax for definition is much like that of C.

      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } [[T]];

   The fields within a structure may be qualified using the type's name,
   with a syntax much like that available for enumerateds.  For example,
   T.f2 refers to the second field of the previous declaration.
   Structure definitions may be embedded.

4.6.1.  Variants

   Defined structures may have variants based on some knowledge that is
   available within the environment.  The selector must be an enumerated
   type that defines the possible variants the structure defines.  There
   must be a case arm for every element of the enumeration declared in
   the select.  Case arms have limited fall-through: if two case arms
   follow in immediate succession with no fields in between, then they



Dierks & Rescorla           Standards Track                    [Page 10]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   both contain the same fields.  Thus, in the example below, "orange"
   and "banana" both contain V2.  Note that this is a new piece of
   syntax in TLS 1.2.

   The body of the variant structure may be given a label for reference.
   The mechanism by which the variant is selected at runtime is not
   prescribed by the presentation language.

      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               case e3: case e4: Te3;
               ....
               case en: Ten;
           } [[fv]];
      } [[Tv]];

   For example:

      enum { apple, orange, banana } VariantTag;

      struct {
          uint16 number;
          opaque string<0..10>; /* variable length */
      } V1;

      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;

      struct {
          select (VariantTag) { /* value of selector is implicit */
              case apple:
                V1;   /* VariantBody, tag = apple */
              case orange:
              case banana:
                V2;   /* VariantBody, tag = orange or banana */
          } variant_body;       /* optional label on variant */
      } VariantRecord;






Dierks & Rescorla           Standards Track                    [Page 11]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


4.7.  Cryptographic Attributes

   The five cryptographic operations -- digital signing, stream cipher
   encryption, block cipher encryption, authenticated encryption with
   additional data (AEAD) encryption, and public key encryption -- are
   designated digitally-signed, stream-ciphered, block-ciphered, aead-
   ciphered, and public-key-encrypted, respectively.  A field's
   cryptographic processing is specified by prepending an appropriate
   key word designation before the field's type specification.
   Cryptographic keys are implied by the current session state (see
   Section 6.1).

   A digitally-signed element is encoded as a struct DigitallySigned:

      struct {
         SignatureAndHashAlgorithm algorithm;
         opaque signature<0..2^16-1>;
      } DigitallySigned;

   The algorithm field specifies the algorithm used (see Section
   7.4.1.4.1 for the definition of this field).  Note that the
   introduction of the algorithm field is a change from previous
   versions.  The signature is a digital signature using those
   algorithms over the contents of the element.  The contents themselves
   do not appear on the wire but are simply calculated.  The length of
   the signature is specified by the signing algorithm and key.

   In RSA signing, the opaque vector contains the signature generated
   using the RSASSA-PKCS1-v1_5 signature scheme defined in [PKCS1].  As
   discussed in [PKCS1], the DigestInfo MUST be DER-encoded [X680]
   [X690].  For hash algorithms without parameters (which includes
   SHA-1), the DigestInfo.AlgorithmIdentifier.parameters field MUST be
   NULL, but implementations MUST accept both without parameters and
   with NULL parameters.  Note that earlier versions of TLS used a
   different RSA signature scheme that did not include a DigestInfo
   encoding.

   In DSA, the 20 bytes of the SHA-1 hash are run directly through the
   Digital Signing Algorithm with no additional hashing.  This produces
   two values, r and s.  The DSA signature is an opaque vector, as
   above, the contents of which are the DER encoding of:

      Dss-Sig-Value ::= SEQUENCE {
          r INTEGER,
          s INTEGER
      }





Dierks & Rescorla           Standards Track                    [Page 12]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Note: In current terminology, DSA refers to the Digital Signature
   Algorithm and DSS refers to the NIST standard.  In the original SSL
   and TLS specs, "DSS" was used universally.  This document uses "DSA"
   to refer to the algorithm, "DSS" to refer to the standard, and it
   uses "DSS" in the code point definitions for historical continuity.

   In stream cipher encryption, the plaintext is exclusive-ORed with an
   identical amount of output generated from a cryptographically secure
   keyed pseudorandom number generator.

   In block cipher encryption, every block of plaintext encrypts to a
   block of ciphertext.  All block cipher encryption is done in CBC
   (Cipher Block Chaining) mode, and all items that are block-ciphered
   will be an exact multiple of the cipher block length.

   In AEAD encryption, the plaintext is simultaneously encrypted and
   integrity protected.  The input may be of any length, and aead-
   ciphered output is generally larger than the input in order to
   accommodate the integrity check value.

   In public key encryption, a public key algorithm is used to encrypt
   data in such a way that it can be decrypted only with the matching
   private key.  A public-key-encrypted element is encoded as an opaque
   vector <0..2^16-1>, where the length is specified by the encryption
   algorithm and key.

   RSA encryption is done using the RSAES-PKCS1-v1_5 encryption scheme
   defined in [PKCS1].

   In the following example

      stream-ciphered struct {
          uint8 field1;
          uint8 field2;
          digitally-signed opaque {
            uint8 field3<0..255>;
            uint8 field4;
          };
      } UserType;

   The contents of the inner struct (field3 and field4) are used as
   input for the signature/hash algorithm, and then the entire structure
   is encrypted with a stream cipher.  The length of this structure, in
   bytes, would be equal to two bytes for field1 and field2, plus two
   bytes for the signature and hash algorithm, plus two bytes for the
   length of the signature, plus the length of the output of the signing





Dierks & Rescorla           Standards Track                    [Page 13]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   algorithm.  The length of the signature is known because the
   algorithm and key used for the signing are known prior to encoding or
   decoding this structure.

4.8.  Constants

   Typed constants can be defined for purposes of specification by
   declaring a symbol of the desired type and assigning values to it.

   Under-specified types (opaque, variable-length vectors, and
   structures that contain opaque) cannot be assigned values.  No fields
   of a multi-element structure or vector may be elided.

   For example:

      struct {
          uint8 f1;
          uint8 f2;
      } Example1;

      Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */

5.  HMAC and the Pseudorandom Function

   The TLS record layer uses a keyed Message Authentication Code (MAC)
   to protect message integrity.  The cipher suites defined in this
   document use a construction known as HMAC, described in [HMAC], which
   is based on a hash function.  Other cipher suites MAY define their
   own MAC constructions, if needed.

   In addition, a construction is required to do expansion of secrets
   into blocks of data for the purposes of key generation or validation.
   This pseudorandom function (PRF) takes as input a secret, a seed, and
   an identifying label and produces an output of arbitrary length.

   In this section, we define one PRF, based on HMAC.  This PRF with the
   SHA-256 hash function is used for all cipher suites defined in this
   document and in TLS documents published prior to this document when
   TLS 1.2 is negotiated.  New cipher suites MUST explicitly specify a
   PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a
   stronger standard hash function.

   First, we define a data expansion function, P_hash(secret, data),
   that uses a single hash function to expand a secret and seed into an
   arbitrary quantity of output:






Dierks & Rescorla           Standards Track                    [Page 14]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                             HMAC_hash(secret, A(2) + seed) +
                             HMAC_hash(secret, A(3) + seed) + ...

   where + indicates concatenation.

   A() is defined as:

      A(0) = seed
      A(i) = HMAC_hash(secret, A(i-1))

   P_hash can be iterated as many times as necessary to produce the
   required quantity of data.  For example, if P_SHA256 is being used to
   create 80 bytes of data, it will have to be iterated three times
   (through A(3)), creating 96 bytes of output data; the last 16 bytes
   of the final iteration will then be discarded, leaving 80 bytes of
   output data.

   TLS's PRF is created by applying P_hash to the secret as:

      PRF(secret, label, seed) = P_<hash>(secret, label + seed)

   The label is an ASCII string.  It should be included in the exact
   form it is given without a length byte or trailing null character.
   For example, the label "slithy toves" would be processed by hashing
   the following bytes:

      73 6C 69 74 68 79 20 74 6F 76 65 73

6.  The TLS Record Protocol

   The TLS Record Protocol is a layered protocol.  At each layer,
   messages may include fields for length, description, and content.
   The Record Protocol takes messages to be transmitted, fragments the
   data into manageable blocks, optionally compresses the data, applies
   a MAC, encrypts, and transmits the result.  Received data is
   decrypted, verified, decompressed, reassembled, and then delivered to
   higher-level clients.

   Four protocols that use the record protocol are described in this
   document: the handshake protocol, the alert protocol, the change
   cipher spec protocol, and the application data protocol.  In order to
   allow extension of the TLS protocol, additional record content types
   can be supported by the record protocol.  New record content type
   values are assigned by IANA in the TLS Content Type Registry as
   described in Section 12.





Dierks & Rescorla           Standards Track                    [Page 15]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Implementations MUST NOT send record types not defined in this
   document unless negotiated by some extension.  If a TLS
   implementation receives an unexpected record type, it MUST send an
   unexpected_message alert.

   Any protocol designed for use over TLS must be carefully designed to
   deal with all possible attacks against it.  As a practical matter,
   this means that the protocol designer must be aware of what security
   properties TLS does and does not provide and cannot safely rely on
   the latter.

   Note in particular that type and length of a record are not protected
   by encryption.  If this information is itself sensitive, application
   designers may wish to take steps (padding, cover traffic) to minimize
   information leakage.

6.1.  Connection States

   A TLS connection state is the operating environment of the TLS Record
   Protocol.  It specifies a compression algorithm, an encryption
   algorithm, and a MAC algorithm.  In addition, the parameters for
   these algorithms are known: the MAC key and the bulk encryption keys
   for the connection in both the read and the write directions.
   Logically, there are always four connection states outstanding: the
   current read and write states, and the pending read and write states.
   All records are processed under the current read and write states.
   The security parameters for the pending states can be set by the TLS
   Handshake Protocol, and the ChangeCipherSpec can selectively make
   either of the pending states current, in which case the appropriate
   current state is disposed of and replaced with the pending state; the
   pending state is then reinitialized to an empty state.  It is illegal
   to make a state that has not been initialized with security
   parameters a current state.  The initial current state always
   specifies that no encryption, compression, or MAC will be used.

   The security parameters for a TLS Connection read and write state are
   set by providing the following values:

   connection end
      Whether this entity is considered the "client" or the "server" in
      this connection.

   PRF algorithm
      An algorithm used to generate keys from the master secret (see
      Sections 5 and 6.3).






Dierks & Rescorla           Standards Track                    [Page 16]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   bulk encryption algorithm
      An algorithm to be used for bulk encryption.  This specification
      includes the key size of this algorithm, whether it is a block,
      stream, or AEAD cipher, the block size of the cipher (if
      appropriate), and the lengths of explicit and implicit
      initialization vectors (or nonces).

   MAC algorithm
      An algorithm to be used for message authentication.  This
      specification includes the size of the value returned by the MAC
      algorithm.

   compression algorithm
      An algorithm to be used for data compression.  This specification
      must include all information the algorithm requires to do
      compression.

   master secret
      A 48-byte secret shared between the two peers in the connection.

   client random
      A 32-byte value provided by the client.

   server random
      A 32-byte value provided by the server.

      These parameters are defined in the presentation language as:

      enum { server, client } ConnectionEnd;

      enum { tls_prf_sha256 } PRFAlgorithm;

      enum { null, rc4, 3des, aes }
        BulkCipherAlgorithm;

      enum { stream, block, aead } CipherType;

      enum { null, hmac_md5, hmac_sha1, hmac_sha256,
           hmac_sha384, hmac_sha512} MACAlgorithm;

      enum { null(0), (255) } CompressionMethod;

      /* The algorithms specified in CompressionMethod, PRFAlgorithm,
         BulkCipherAlgorithm, and MACAlgorithm may be added to. */







Dierks & Rescorla           Standards Track                    [Page 17]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          ConnectionEnd          entity;
          PRFAlgorithm           prf_algorithm;
          BulkCipherAlgorithm    bulk_cipher_algorithm;
          CipherType             cipher_type;
          uint8                  enc_key_length;
          uint8                  block_length;
          uint8                  fixed_iv_length;
          uint8                  record_iv_length;
          MACAlgorithm           mac_algorithm;
          uint8                  mac_length;
          uint8                  mac_key_length;
          CompressionMethod      compression_algorithm;
          opaque                 master_secret[48];
          opaque                 client_random[32];
          opaque                 server_random[32];
      } SecurityParameters;

   The record layer will use the security parameters to generate the
   following six items (some of which are not required by all ciphers,
   and are thus empty):

      client write MAC key
      server write MAC key
      client write encryption key
      server write encryption key
      client write IV
      server write IV

   The client write parameters are used by the server when receiving and
   processing records and vice versa.  The algorithm used for generating
   these items from the security parameters is described in Section 6.3.

   Once the security parameters have been set and the keys have been
   generated, the connection states can be instantiated by making them
   the current states.  These current states MUST be updated for each
   record processed.  Each connection state includes the following
   elements:

   compression state
      The current state of the compression algorithm.

   cipher state
      The current state of the encryption algorithm.  This will consist
      of the scheduled key for that connection.  For stream ciphers,
      this will also contain whatever state information is necessary to
      allow the stream to continue to encrypt or decrypt data.




Dierks & Rescorla           Standards Track                    [Page 18]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   MAC key
      The MAC key for this connection, as generated above.

   sequence number
      Each connection state contains a sequence number, which is
      maintained separately for read and write states.  The sequence
      number MUST be set to zero whenever a connection state is made the
      active state.  Sequence numbers are of type uint64 and may not
      exceed 2^64-1.  Sequence numbers do not wrap.  If a TLS
      implementation would need to wrap a sequence number, it must
      renegotiate instead.  A sequence number is incremented after each
      record: specifically, the first record transmitted under a
      particular connection state MUST use sequence number 0.

6.2.  Record Layer

   The TLS record layer receives uninterpreted data from higher layers
   in non-empty blocks of arbitrary size.

6.2.1.  Fragmentation

   The record layer fragments information blocks into TLSPlaintext
   records carrying data in chunks of 2^14 bytes or less.  Client
   message boundaries are not preserved in the record layer (i.e.,
   multiple client messages of the same ContentType MAY be coalesced
   into a single TLSPlaintext record, or a single message MAY be
   fragmented across several records).

      struct {
          uint8 major;
          uint8 minor;
      } ProtocolVersion;

      enum {
          change_cipher_spec(20), alert(21), handshake(22),
          application_data(23), (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;

   type
      The higher-level protocol used to process the enclosed fragment.




Dierks & Rescorla           Standards Track                    [Page 19]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   version
      The version of the protocol being employed.  This document
      describes TLS Version 1.2, which uses the version { 3, 3 }.  The
      version value 3.3 is historical, deriving from the use of {3, 1}
      for TLS 1.0.  (See Appendix A.1.)  Note that a client that
      supports multiple versions of TLS may not know what version will
      be employed before it receives the ServerHello.  See Appendix E
      for discussion about what record layer version number should be
      employed for ClientHello.

   length
      The length (in bytes) of the following TLSPlaintext.fragment.  The
      length MUST NOT exceed 2^14.

   fragment
      The application data.  This data is transparent and treated as an
      independent block to be dealt with by the higher-level protocol
      specified by the type field.

   Implementations MUST NOT send zero-length fragments of Handshake,
   Alert, or ChangeCipherSpec content types.  Zero-length fragments of
   Application data MAY be sent as they are potentially useful as a
   traffic analysis countermeasure.

   Note: Data of different TLS record layer content types MAY be
   interleaved.  Application data is generally of lower precedence for
   transmission than other content types.  However, records MUST be
   delivered to the network in the same order as they are protected by
   the record layer.  Recipients MUST receive and process interleaved
   application layer traffic during handshakes subsequent to the first
   one on a connection.

6.2.2.  Record Compression and Decompression

   All records are compressed using the compression algorithm defined in
   the current session state.  There is always an active compression
   algorithm; however, initially it is defined as
   CompressionMethod.null.  The compression algorithm translates a
   TLSPlaintext structure into a TLSCompressed structure.  Compression
   functions are initialized with default state information whenever a
   connection state is made active.  [RFC3749] describes compression
   algorithms for TLS.

   Compression must be lossless and may not increase the content length
   by more than 1024 bytes.  If the decompression function encounters a
   TLSCompressed.fragment that would decompress to a length in excess of
   2^14 bytes, it MUST report a fatal decompression failure error.




Dierks & Rescorla           Standards Track                    [Page 20]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          ContentType type;       /* same as TLSPlaintext.type */
          ProtocolVersion version;/* same as TLSPlaintext.version */
          uint16 length;
          opaque fragment[TLSCompressed.length];
      } TLSCompressed;

   length
      The length (in bytes) of the following TLSCompressed.fragment.
      The length MUST NOT exceed 2^14 + 1024.

   fragment
      The compressed form of TLSPlaintext.fragment.

      Note: A CompressionMethod.null operation is an identity operation;
      no fields are altered.

      Implementation note: Decompression functions are responsible for
      ensuring that messages cannot cause internal buffer overflows.

6.2.3.  Record Payload Protection

      The encryption and MAC functions translate a TLSCompressed
      structure into a TLSCiphertext.  The decryption functions reverse
      the process.  The MAC of the record also includes a sequence
      number so that missing, extra, or repeated messages are
      detectable.

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          select (SecurityParameters.cipher_type) {
              case stream: GenericStreamCipher;
              case block:  GenericBlockCipher;
              case aead:   GenericAEADCipher;
          } fragment;
      } TLSCiphertext;

   type
      The type field is identical to TLSCompressed.type.

   version
      The version field is identical to TLSCompressed.version.

   length
      The length (in bytes) of the following TLSCiphertext.fragment.
      The length MUST NOT exceed 2^14 + 2048.



Dierks & Rescorla           Standards Track                    [Page 21]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   fragment
      The encrypted form of TLSCompressed.fragment, with the MAC.

6.2.3.1.  Null or Standard Stream Cipher

   Stream ciphers (including BulkCipherAlgorithm.null; see Appendix A.6)
   convert TLSCompressed.fragment structures to and from stream
   TLSCiphertext.fragment structures.

      stream-ciphered struct {
          opaque content[TLSCompressed.length];
          opaque MAC[SecurityParameters.mac_length];
      } GenericStreamCipher;

   The MAC is generated as:

      MAC(MAC_write_key, seq_num +
                            TLSCompressed.type +
                            TLSCompressed.version +
                            TLSCompressed.length +
                            TLSCompressed.fragment);

   where "+" denotes concatenation.

   seq_num
      The sequence number for this record.

   MAC
      The MAC algorithm specified by SecurityParameters.mac_algorithm.

   Note that the MAC is computed before encryption.  The stream cipher
   encrypts the entire block, including the MAC.  For stream ciphers
   that do not use a synchronization vector (such as RC4), the stream
   cipher state from the end of one record is simply used on the
   subsequent packet.  If the cipher suite is TLS_NULL_WITH_NULL_NULL,
   encryption consists of the identity operation (i.e., the data is not
   encrypted, and the MAC size is zero, implying that no MAC is used).
   For both null and stream ciphers, TLSCiphertext.length is
   TLSCompressed.length plus SecurityParameters.mac_length.

6.2.3.2.  CBC Block Cipher

   For block ciphers (such as 3DES or AES), the encryption and MAC
   functions convert TLSCompressed.fragment structures to and from block
   TLSCiphertext.fragment structures.






Dierks & Rescorla           Standards Track                    [Page 22]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          opaque IV[SecurityParameters.record_iv_length];
          block-ciphered struct {
              opaque content[TLSCompressed.length];
              opaque MAC[SecurityParameters.mac_length];
              uint8 padding[GenericBlockCipher.padding_length];
              uint8 padding_length;
          };
      } GenericBlockCipher;

   The MAC is generated as described in Section 6.2.3.1.

   IV
      The Initialization Vector (IV) SHOULD be chosen at random, and
      MUST be unpredictable.  Note that in versions of TLS prior to 1.1,
      there was no IV field, and the last ciphertext block of the
      previous record (the "CBC residue") was used as the IV.  This was
      changed to prevent the attacks described in [CBCATT].  For block
      ciphers, the IV length is of length
      SecurityParameters.record_iv_length, which is equal to the
      SecurityParameters.block_size.

   padding
      Padding that is added to force the length of the plaintext to be
      an integral multiple of the block cipher's block length.  The
      padding MAY be any length up to 255 bytes, as long as it results
      in the TLSCiphertext.length being an integral multiple of the
      block length.  Lengths longer than necessary might be desirable to
      frustrate attacks on a protocol that are based on analysis of the
      lengths of exchanged messages.  Each uint8 in the padding data
      vector MUST be filled with the padding length value.  The receiver
      MUST check this padding and MUST use the bad_record_mac alert to
      indicate padding errors.

   padding_length
      The padding length MUST be such that the total size of the
      GenericBlockCipher structure is a multiple of the cipher's block
      length.  Legal values range from zero to 255, inclusive.  This
      length specifies the length of the padding field exclusive of the
      padding_length field itself.

   The encrypted data length (TLSCiphertext.length) is one more than the
   sum of SecurityParameters.block_length, TLSCompressed.length,
   SecurityParameters.mac_length, and padding_length.

   Example: If the block length is 8 bytes, the content length
   (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes,
   then the length before padding is 82 bytes (this does not include the



Dierks & Rescorla           Standards Track                    [Page 23]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   IV.  Thus, the padding length modulo 8 must be equal to 6 in order to
   make the total length an even multiple of 8 bytes (the block length).
   The padding length can be 6, 14, 22, and so on, through 254.  If the
   padding length were the minimum necessary, 6, the padding would be 6
   bytes, each containing the value 6.  Thus, the last 8 octets of the
   GenericBlockCipher before block encryption would be xx 06 06 06 06 06
   06 06, where xx is the last octet of the MAC.

   Note: With block ciphers in CBC mode (Cipher Block Chaining), it is
   critical that the entire plaintext of the record be known before any
   ciphertext is transmitted.  Otherwise, it is possible for the
   attacker to mount the attack described in [CBCATT].

   Implementation note: Canvel et al. [CBCTIME] have demonstrated a
   timing attack on CBC padding based on the time required to compute
   the MAC.  In order to defend against this attack, implementations
   MUST ensure that record processing time is essentially the same
   whether or not the padding is correct.  In general, the best way to
   do this is to compute the MAC even if the padding is incorrect, and
   only then reject the packet.  For instance, if the pad appears to be
   incorrect, the implementation might assume a zero-length pad and then
   compute the MAC.  This leaves a small timing channel, since MAC
   performance depends to some extent on the size of the data fragment,
   but it is not believed to be large enough to be exploitable, due to
   the large block size of existing MACs and the small size of the
   timing signal.

6.2.3.3.  AEAD Ciphers

   For AEAD [AEAD] ciphers (such as [CCM] or [GCM]), the AEAD function
   converts TLSCompressed.fragment structures to and from AEAD
   TLSCiphertext.fragment structures.

      struct {
         opaque nonce_explicit[SecurityParameters.record_iv_length];
         aead-ciphered struct {
             opaque content[TLSCompressed.length];
         };
      } GenericAEADCipher;

   AEAD ciphers take as input a single key, a nonce, a plaintext, and
   "additional data" to be included in the authentication check, as
   described in Section 2.1 of [AEAD].  The key is either the
   client_write_key or the server_write_key.  No MAC key is used.

   Each AEAD cipher suite MUST specify how the nonce supplied to the
   AEAD operation is constructed, and what is the length of the
   GenericAEADCipher.nonce_explicit part.  In many cases, it is



Dierks & Rescorla           Standards Track                    [Page 24]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   appropriate to use the partially implicit nonce technique described
   in Section 3.2.1 of [AEAD]; with record_iv_length being the length of
   the explicit part.  In this case, the implicit part SHOULD be derived
   from key_block as client_write_iv and server_write_iv (as described
   in Section 6.3), and the explicit part is included in
   GenericAEAEDCipher.nonce_explicit.

   The plaintext is the TLSCompressed.fragment.

   The additional authenticated data, which we denote as
   additional_data, is defined as follows:

      additional_data = seq_num + TLSCompressed.type +
                        TLSCompressed.version + TLSCompressed.length;

   where "+" denotes concatenation.

   The aead_output consists of the ciphertext output by the AEAD
   encryption operation.  The length will generally be larger than
   TLSCompressed.length, but by an amount that varies with the AEAD
   cipher.  Since the ciphers might incorporate padding, the amount of
   overhead could vary with different TLSCompressed.length values.  Each
   AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes.
   Symbolically,

      AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext,
                                   additional_data)

   In order to decrypt and verify, the cipher takes as input the key,
   nonce, the "additional_data", and the AEADEncrypted value.  The
   output is either the plaintext or an error indicating that the
   decryption failed.  There is no separate integrity check.  That is:

      TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce,
                                            AEADEncrypted,
                                            additional_data)

   If the decryption fails, a fatal bad_record_mac alert MUST be
   generated.

6.3.  Key Calculation

   The Record Protocol requires an algorithm to generate keys required
   by the current connection state (see Appendix A.6) from the security
   parameters provided by the handshake protocol.






Dierks & Rescorla           Standards Track                    [Page 25]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The master secret is expanded into a sequence of secure bytes, which
   is then split to a client write MAC key, a server write MAC key, a
   client write encryption key, and a server write encryption key.  Each
   of these is generated from the byte sequence in that order.  Unused
   values are empty.  Some AEAD ciphers may additionally require a
   client write IV and a server write IV (see Section 6.2.3.3).

   When keys and MAC keys are generated, the master secret is used as an
   entropy source.

   To generate the key material, compute

      key_block = PRF(SecurityParameters.master_secret,
                      "key expansion",
                      SecurityParameters.server_random +
                      SecurityParameters.client_random);

   until enough output has been generated.  Then, the key_block is
   partitioned as follows:

      client_write_MAC_key[SecurityParameters.mac_key_length]
      server_write_MAC_key[SecurityParameters.mac_key_length]
      client_write_key[SecurityParameters.enc_key_length]
      server_write_key[SecurityParameters.enc_key_length]
      client_write_IV[SecurityParameters.fixed_iv_length]
      server_write_IV[SecurityParameters.fixed_iv_length]

   Currently, the client_write_IV and server_write_IV are only generated
   for implicit nonce techniques as described in Section 3.2.1 of
   [AEAD].

   Implementation note: The currently defined cipher suite which
   requires the most material is AES_256_CBC_SHA256.  It requires 2 x 32
   byte keys and 2 x 32 byte MAC keys, for a total 128 bytes of key
   material.

7.  The TLS Handshaking Protocols

   TLS has three subprotocols that are used to allow peers to agree upon
   security parameters for the record layer, to authenticate themselves,
   to instantiate negotiated security parameters, and to report error
   conditions to each other.

   The Handshake Protocol is responsible for negotiating a session,
   which consists of the following items:






Dierks & Rescorla           Standards Track                    [Page 26]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   session identifier
      An arbitrary byte sequence chosen by the server to identify an
      active or resumable session state.

   peer certificate
      X509v3 [PKIX] certificate of the peer.  This element of the state
      may be null.

   compression method
      The algorithm used to compress data prior to encryption.

   cipher spec
      Specifies the pseudorandom function (PRF) used to generate keying
      material, the bulk data encryption algorithm (such as null, AES,
      etc.) and the MAC algorithm (such as HMAC-SHA1).  It also defines
      cryptographic attributes such as the mac_length.  (See Appendix
      A.6 for formal definition.)

   master secret
      48-byte secret shared between the client and server.

   is resumable
      A flag indicating whether the session can be used to initiate new
      connections.

   These items are then used to create security parameters for use by
   the record layer when protecting application data.  Many connections
   can be instantiated using the same session through the resumption
   feature of the TLS Handshake Protocol.

7.1.  Change Cipher Spec Protocol

   The change cipher spec protocol exists to signal transitions in
   ciphering strategies.  The protocol consists of a single message,
   which is encrypted and compressed under the current (not the pending)
   connection state.  The message consists of a single byte of value 1.

      struct {
          enum { change_cipher_spec(1), (255) } type;
      } ChangeCipherSpec;

   The ChangeCipherSpec message is sent by both the client and the
   server to notify the receiving party that subsequent records will be
   protected under the newly negotiated CipherSpec and keys.  Reception
   of this message causes the receiver to instruct the record layer to
   immediately copy the read pending state into the read current state.
   Immediately after sending this message, the sender MUST instruct the
   record layer to make the write pending state the write active state.



Dierks & Rescorla           Standards Track                    [Page 27]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   (See Section 6.1.)  The ChangeCipherSpec message is sent during the
   handshake after the security parameters have been agreed upon, but
   before the verifying Finished message is sent.

   Note: If a rehandshake occurs while data is flowing on a connection,
   the communicating parties may continue to send data using the old
   CipherSpec.  However, once the ChangeCipherSpec has been sent, the
   new CipherSpec MUST be used.  The first side to send the
   ChangeCipherSpec does not know that the other side has finished
   computing the new keying material (e.g., if it has to perform a
   time-consuming public key operation).  Thus, a small window of time,
   during which the recipient must buffer the data, MAY exist.  In
   practice, with modern machines this interval is likely to be fairly
   short.

7.2.  Alert Protocol

   One of the content types supported by the TLS record layer is the
   alert type.  Alert messages convey the severity of the message
   (warning or fatal) and a description of the alert.  Alert messages
   with a level of fatal result in the immediate termination of the
   connection.  In this case, other connections corresponding to the
   session may continue, but the session identifier MUST be invalidated,
   preventing the failed session from being used to establish new
   connections.  Like other messages, alert messages are encrypted and
   compressed, as specified by the current connection state.

      enum { warning(1), fatal(2), (255) } AlertLevel;

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),



Dierks & Rescorla           Standards Track                    [Page 28]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          user_canceled(90),
          no_renegotiation(100),
          unsupported_extension(110),
          (255)
      } AlertDescription;

      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;

7.2.1.  Closure Alerts

   The client and the server must share knowledge that the connection is
   ending in order to avoid a truncation attack.  Either party may
   initiate the exchange of closing messages.

   close_notify
      This message notifies the recipient that the sender will not send
      any more messages on this connection.  Note that as of TLS 1.1,
      failure to properly close a connection no longer requires that a
      session not be resumed.  This is a change from TLS 1.0 to conform
      with widespread implementation practice.

   Either party may initiate a close by sending a close_notify alert.
   Any data received after a closure alert is ignored.

   Unless some other fatal alert has been transmitted, each party is
   required to send a close_notify alert before closing the write side
   of the connection.  The other party MUST respond with a close_notify
   alert of its own and close down the connection immediately,
   discarding any pending writes.  It is not required for the initiator
   of the close to wait for the responding close_notify alert before
   closing the read side of the connection.

   If the application protocol using TLS provides that any data may be
   carried over the underlying transport after the TLS connection is
   closed, the TLS implementation must receive the responding
   close_notify alert before indicating to the application layer that
   the TLS connection has ended.  If the application protocol will not
   transfer any additional data, but will only close the underlying
   transport connection, then the implementation MAY choose to close the
   transport without waiting for the responding close_notify.  No part




Dierks & Rescorla           Standards Track                    [Page 29]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   of this standard should be taken to dictate the manner in which a
   usage profile for TLS manages its data transport, including when
   connections are opened or closed.

   Note: It is assumed that closing a connection reliably delivers
   pending data before destroying the transport.

7.2.2.  Error Alerts

   Error handling in the TLS Handshake protocol is very simple.  When an
   error is detected, the detecting party sends a message to the other
   party.  Upon transmission or receipt of a fatal alert message, both
   parties immediately close the connection.  Servers and clients MUST
   forget any session-identifiers, keys, and secrets associated with a
   failed connection.  Thus, any connection terminated with a fatal
   alert MUST NOT be resumed.

   Whenever an implementation encounters a condition which is defined as
   a fatal alert, it MUST send the appropriate alert prior to closing
   the connection.  For all errors where an alert level is not
   explicitly specified, the sending party MAY determine at its
   discretion whether to treat this as a fatal error or not.  If the
   implementation chooses to send an alert but intends to close the
   connection immediately afterwards, it MUST send that alert at the
   fatal alert level.

   If an alert with a level of warning is sent and received, generally
   the connection can continue normally.  If the receiving party decides
   not to proceed with the connection (e.g., after having received a
   no_renegotiation alert that it is not willing to accept), it SHOULD
   send a fatal alert to terminate the connection.  Given this, the
   sending party cannot, in general, know how the receiving party will
   behave.  Therefore, warning alerts are not very useful when the
   sending party wants to continue the connection, and thus are
   sometimes omitted.  For example, if a peer decides to accept an
   expired certificate (perhaps after confirming this with the user) and
   wants to continue the connection, it would not generally send a
   certificate_expired alert.

   The following error alerts are defined:

   unexpected_message
      An inappropriate message was received.  This alert is always fatal
      and should never be observed in communication between proper
      implementations.






Dierks & Rescorla           Standards Track                    [Page 30]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   bad_record_mac
      This alert is returned if a record is received with an incorrect
      MAC.  This alert also MUST be returned if an alert is sent because
      a TLSCiphertext decrypted in an invalid way: either it wasn't an
      even multiple of the block length, or its padding values, when
      checked, weren't correct.  This message is always fatal and should
      never be observed in communication between proper implementations
      (except when messages were corrupted in the network).

   decryption_failed_RESERVED
      This alert was used in some earlier versions of TLS, and may have
      permitted certain attacks against the CBC mode [CBCATT].  It MUST
      NOT be sent by compliant implementations.

   record_overflow
      A TLSCiphertext record was received that had a length more than
      2^14+2048 bytes, or a record decrypted to a TLSCompressed record
      with more than 2^14+1024 bytes.  This message is always fatal and
      should never be observed in communication between proper
      implementations (except when messages were corrupted in the
      network).

   decompression_failure
      The decompression function received improper input (e.g., data
      that would expand to excessive length).  This message is always
      fatal and should never be observed in communication between proper
      implementations.

   handshake_failure
      Reception of a handshake_failure alert message indicates that the
      sender was unable to negotiate an acceptable set of security
      parameters given the options available.  This is a fatal error.

   no_certificate_RESERVED
      This alert was used in SSLv3 but not any version of TLS.  It MUST
      NOT be sent by compliant implementations.

   bad_certificate
      A certificate was corrupt, contained signatures that did not
      verify correctly, etc.

   unsupported_certificate
      A certificate was of an unsupported type.

   certificate_revoked
      A certificate was revoked by its signer.





Dierks & Rescorla           Standards Track                    [Page 31]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   certificate_expired
      A certificate has expired or is not currently valid.

   certificate_unknown
      Some other (unspecified) issue arose in processing the
      certificate, rendering it unacceptable.

   illegal_parameter
      A field in the handshake was out of range or inconsistent with
      other fields.  This message is always fatal.

   unknown_ca
      A valid certificate chain or partial chain was received, but the
      certificate was not accepted because the CA certificate could not
      be located or couldn't be matched with a known, trusted CA.  This
      message is always fatal.

   access_denied
      A valid certificate was received, but when access control was
      applied, the sender decided not to proceed with negotiation.  This
      message is always fatal.

   decode_error
      A message could not be decoded because some field was out of the
      specified range or the length of the message was incorrect.  This
      message is always fatal and should never be observed in
      communication between proper implementations (except when messages
      were corrupted in the network).

   decrypt_error
      A handshake cryptographic operation failed, including being unable
      to correctly verify a signature or validate a Finished message.
      This message is always fatal.

   export_restriction_RESERVED
      This alert was used in some earlier versions of TLS.  It MUST NOT
      be sent by compliant implementations.

   protocol_version
      The protocol version the client has attempted to negotiate is
      recognized but not supported.  (For example, old protocol versions
      might be avoided for security reasons.)  This message is always
      fatal.








Dierks & Rescorla           Standards Track                    [Page 32]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   insufficient_security
      Returned instead of handshake_failure when a negotiation has
      failed specifically because the server requires ciphers more
      secure than those supported by the client.  This message is always
      fatal.

   internal_error
      An internal error unrelated to the peer or the correctness of the
      protocol (such as a memory allocation failure) makes it impossible
      to continue.  This message is always fatal.

   user_canceled
      This handshake is being canceled for some reason unrelated to a
      protocol failure.  If the user cancels an operation after the
      handshake is complete, just closing the connection by sending a
      close_notify is more appropriate.  This alert should be followed
      by a close_notify.  This message is generally a warning.

   no_renegotiation
      Sent by the client in response to a hello request or by the server
      in response to a client hello after initial handshaking.  Either
      of these would normally lead to renegotiation; when that is not
      appropriate, the recipient should respond with this alert.  At
      that point, the original requester can decide whether to proceed
      with the connection.  One case where this would be appropriate is
      where a server has spawned a process to satisfy a request; the
      process might receive security parameters (key length,
      authentication, etc.) at startup, and it might be difficult to
      communicate changes to these parameters after that point.  This
      message is always a warning.

   unsupported_extension
      sent by clients that receive an extended server hello containing
      an extension that they did not put in the corresponding client
      hello.  This message is always fatal.

   New Alert values are assigned by IANA as described in Section 12.

7.3.  Handshake Protocol Overview

   The cryptographic parameters of the session state are produced by the
   TLS Handshake Protocol, which operates on top of the TLS record
   layer.  When a TLS client and server first start communicating, they
   agree on a protocol version, select cryptographic algorithms,
   optionally authenticate each other, and use public-key encryption
   techniques to generate shared secrets.





Dierks & Rescorla           Standards Track                    [Page 33]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The TLS Handshake Protocol involves the following steps:

   -  Exchange hello messages to agree on algorithms, exchange random
      values, and check for session resumption.

   -  Exchange the necessary cryptographic parameters to allow the
      client and server to agree on a premaster secret.

   -  Exchange certificates and cryptographic information to allow the
      client and server to authenticate themselves.

   -  Generate a master secret from the premaster secret and exchanged
      random values.

   -  Provide security parameters to the record layer.

   -  Allow the client and server to verify that their peer has
      calculated the same security parameters and that the handshake
      occurred without tampering by an attacker.

   Note that higher layers should not be overly reliant on whether TLS
   always negotiates the strongest possible connection between two
   peers.  There are a number of ways in which a man-in-the-middle
   attacker can attempt to make two entities drop down to the least
   secure method they support.  The protocol has been designed to
   minimize this risk, but there are still attacks available: for
   example, an attacker could block access to the port a secure service
   runs on, or attempt to get the peers to negotiate an unauthenticated
   connection.  The fundamental rule is that higher levels must be
   cognizant of what their security requirements are and never transmit
   information over a channel less secure than what they require.  The
   TLS protocol is secure in that any cipher suite offers its promised
   level of security: if you negotiate 3DES with a 1024-bit RSA key
   exchange with a host whose certificate you have verified, you can
   expect to be that secure.

   These goals are achieved by the handshake protocol, which can be
   summarized as follows: The client sends a ClientHello message to
   which the server must respond with a ServerHello message, or else a
   fatal error will occur and the connection will fail.  The ClientHello
   and ServerHello are used to establish security enhancement
   capabilities between client and server.  The ClientHello and
   ServerHello establish the following attributes: Protocol Version,
   Session ID, Cipher Suite, and Compression Method.  Additionally, two
   random values are generated and exchanged: ClientHello.random and
   ServerHello.random.





Dierks & Rescorla           Standards Track                    [Page 34]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The actual key exchange uses up to four messages: the server
   Certificate, the ServerKeyExchange, the client Certificate, and the
   ClientKeyExchange.  New key exchange methods can be created by
   specifying a format for these messages and by defining the use of the
   messages to allow the client and server to agree upon a shared
   secret.  This secret MUST be quite long; currently defined key
   exchange methods exchange secrets that range from 46 bytes upwards.

   Following the hello messages, the server will send its certificate in
   a Certificate message if it is to be authenticated.  Additionally, a
   ServerKeyExchange message may be sent, if it is required (e.g., if
   the server has no certificate, or if its certificate is for signing
   only).  If the server is authenticated, it may request a certificate
   from the client, if that is appropriate to the cipher suite selected.
   Next, the server will send the ServerHelloDone message, indicating
   that the hello-message phase of the handshake is complete.  The
   server will then wait for a client response.  If the server has sent
   a CertificateRequest message, the client MUST send the Certificate
   message.  The ClientKeyExchange message is now sent, and the content
   of that message will depend on the public key algorithm selected
   between the ClientHello and the ServerHello.  If the client has sent
   a certificate with signing ability, a digitally-signed
   CertificateVerify message is sent to explicitly verify possession of
   the private key in the certificate.

   At this point, a ChangeCipherSpec message is sent by the client, and
   the client copies the pending Cipher Spec into the current Cipher
   Spec.  The client then immediately sends the Finished message under
   the new algorithms, keys, and secrets.  In response, the server will
   send its own ChangeCipherSpec message, transfer the pending to the
   current Cipher Spec, and send its Finished message under the new
   Cipher Spec.  At this point, the handshake is complete, and the
   client and server may begin to exchange application layer data.  (See
   flow chart below.)  Application data MUST NOT be sent prior to the
   completion of the first handshake (before a cipher suite other than
   TLS_NULL_WITH_NULL_NULL is established).















Dierks & Rescorla           Standards Track                    [Page 35]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      Client                                               Server

      ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
      Application Data             <------->     Application Data

             Figure 1.  Message flow for a full handshake

   * Indicates optional or situation-dependent messages that are not
   always sent.

   Note: To help avoid pipeline stalls, ChangeCipherSpec is an
   independent TLS protocol content type, and is not actually a TLS
   handshake message.

   When the client and server decide to resume a previous session or
   duplicate an existing session (instead of negotiating new security
   parameters), the message flow is as follows:

   The client sends a ClientHello using the Session ID of the session to
   be resumed.  The server then checks its session cache for a match.
   If a match is found, and the server is willing to re-establish the
   connection under the specified session state, it will send a
   ServerHello with the same Session ID value.  At this point, both
   client and server MUST send ChangeCipherSpec messages and proceed
   directly to Finished messages.  Once the re-establishment is
   complete, the client and server MAY begin to exchange application
   layer data.  (See flow chart below.)  If a Session ID match is not
   found, the server generates a new session ID, and the TLS client and
   server perform a full handshake.










Dierks & Rescorla           Standards Track                    [Page 36]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      Client                                                Server

      ClientHello                   -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------             Finished
      [ChangeCipherSpec]
      Finished                      -------->
      Application Data              <------->     Application Data

          Figure 2.  Message flow for an abbreviated handshake

   The contents and significance of each message will be presented in
   detail in the following sections.

7.4.  Handshake Protocol

   The TLS Handshake Protocol is one of the defined higher-level clients
   of the TLS Record Protocol.  This protocol is used to negotiate the
   secure attributes of a session.  Handshake messages are supplied to
   the TLS record layer, where they are encapsulated within one or more
   TLSPlaintext structures, which are processed and transmitted as
   specified by the current active session state.

      enum {
          hello_request(0), client_hello(1), server_hello(2),
          certificate(11), server_key_exchange (12),
          certificate_request(13), server_hello_done(14),
          certificate_verify(15), client_key_exchange(16),
          finished(20), (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
          } body;
      } Handshake;



Dierks & Rescorla           Standards Track                    [Page 37]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The handshake protocol messages are presented below in the order they
   MUST be sent; sending handshake messages in an unexpected order
   results in a fatal error.  Unneeded handshake messages can be
   omitted, however.  Note one exception to the ordering: the
   Certificate message is used twice in the handshake (from server to
   client, then from client to server), but described only in its first
   position.  The one message that is not bound by these ordering rules
   is the HelloRequest message, which can be sent at any time, but which
   SHOULD be ignored by the client if it arrives in the middle of a
   handshake.

   New handshake message types are assigned by IANA as described in
   Section 12.

7.4.1.  Hello Messages

   The hello phase messages are used to exchange security enhancement
   capabilities between the client and server.  When a new session
   begins, the record layer's connection state encryption, hash, and
   compression algorithms are initialized to null.  The current
   connection state is used for renegotiation messages.

7.4.1.1.  Hello Request

   When this message will be sent:

      The HelloRequest message MAY be sent by the server at any time.

   Meaning of this message:

      HelloRequest is a simple notification that the client should begin
      the negotiation process anew.  In response, the client should send
      a ClientHello message when convenient.  This message is not
      intended to establish which side is the client or server but
      merely to initiate a new negotiation.  Servers SHOULD NOT send a
      HelloRequest immediately upon the client's initial connection.  It
      is the client's job to send a ClientHello at that time.

      This message will be ignored by the client if the client is
      currently negotiating a session.  This message MAY be ignored by
      the client if it does not wish to renegotiate a session, or the
      client may, if it wishes, respond with a no_renegotiation alert.
      Since handshake messages are intended to have transmission
      precedence over application data, it is expected that the
      negotiation will begin before no more than a few records are
      received from the client.  If the server sends a HelloRequest but
      does not receive a ClientHello in response, it may close the
      connection with a fatal alert.



Dierks & Rescorla           Standards Track                    [Page 38]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      After sending a HelloRequest, servers SHOULD NOT repeat the
      request until the subsequent handshake negotiation is complete.

   Structure of this message:

      struct { } HelloRequest;

   This message MUST NOT be included in the message hashes that are
   maintained throughout the handshake and used in the Finished messages
   and the certificate verify message.

7.4.1.2.  Client Hello

   When this message will be sent:

      When a client first connects to a server, it is required to send
      the ClientHello as its first message.  The client can also send a
      ClientHello in response to a HelloRequest or on its own initiative
      in order to renegotiate the security parameters in an existing
      connection.

   Structure of this message:

      The ClientHello message includes a random structure, which is used
      later in the protocol.

         struct {
             uint32 gmt_unix_time;
             opaque random_bytes[28];
         } Random;

      gmt_unix_time
         The current time and date in standard UNIX 32-bit format
         (seconds since the midnight starting Jan 1, 1970, UTC, ignoring
         leap seconds) according to the sender's internal clock.  Clocks
         are not required to be set correctly by the basic TLS protocol;
         higher-level or application protocols may define additional
         requirements.  Note that, for historical reasons, the data
         element is named using GMT, the predecessor of the current
         worldwide time base, UTC.

      random_bytes
         28 bytes generated by a secure random number generator.

   The ClientHello message includes a variable-length session
   identifier.  If not empty, the value identifies a session between the
   same client and server whose security parameters the client wishes to
   reuse.  The session identifier MAY be from an earlier connection,



Dierks & Rescorla           Standards Track                    [Page 39]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   this connection, or from another currently active connection.  The
   second option is useful if the client only wishes to update the
   random structures and derived values of a connection, and the third
   option makes it possible to establish several independent secure
   connections without repeating the full handshake protocol.  These
   independent connections may occur sequentially or simultaneously; a
   SessionID becomes valid when the handshake negotiating it completes
   with the exchange of Finished messages and persists until it is
   removed due to aging or because a fatal error was encountered on a
   connection associated with the session.  The actual contents of the
   SessionID are defined by the server.

      opaque SessionID<0..32>;

   Warning: Because the SessionID is transmitted without encryption or
   immediate MAC protection, servers MUST NOT place confidential
   information in session identifiers or let the contents of fake
   session identifiers cause any breach of security.  (Note that the
   content of the handshake as a whole, including the SessionID, is
   protected by the Finished messages exchanged at the end of the
   handshake.)

   The cipher suite list, passed from the client to the server in the
   ClientHello message, contains the combinations of cryptographic
   algorithms supported by the client in order of the client's
   preference (favorite choice first).  Each cipher suite defines a key
   exchange algorithm, a bulk encryption algorithm (including secret key
   length), a MAC algorithm, and a PRF.  The server will select a cipher
   suite or, if no acceptable choices are presented, return a handshake
   failure alert and close the connection.  If the list contains cipher
   suites the server does not recognize, support, or wish to use, the
   server MUST ignore those cipher suites, and process the remaining
   ones as usual.

      uint8 CipherSuite[2];    /* Cryptographic suite selector */

   The ClientHello includes a list of compression algorithms supported
   by the client, ordered according to the client's preference.

      enum { null(0), (255) } CompressionMethod;











Dierks & Rescorla           Standards Track                    [Page 40]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          ProtocolVersion client_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suites<2..2^16-2>;
          CompressionMethod compression_methods<1..2^8-1>;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ClientHello;

   TLS allows extensions to follow the compression_methods field in an
   extensions block.  The presence of extensions can be detected by
   determining whether there are bytes following the compression_methods
   at the end of the ClientHello.  Note that this method of detecting
   optional data differs from the normal TLS method of having a
   variable-length field, but it is used for compatibility with TLS
   before extensions were defined.

   client_version
      The version of the TLS protocol by which the client wishes to
      communicate during this session.  This SHOULD be the latest
      (highest valued) version supported by the client.  For this
      version of the specification, the version will be 3.3 (see
      Appendix E for details about backward compatibility).

   random
      A client-generated random structure.

   session_id
      The ID of a session the client wishes to use for this connection.
      This field is empty if no session_id is available, or if the
      client wishes to generate new security parameters.

   cipher_suites
      This is a list of the cryptographic options supported by the
      client, with the client's first preference first.  If the
      session_id field is not empty (implying a session resumption
      request), this vector MUST include at least the cipher_suite from
      that session.  Values are defined in Appendix A.5.

   compression_methods
      This is a list of the compression methods supported by the client,
      sorted by client preference.  If the session_id field is not empty
      (implying a session resumption request), it MUST include the



Dierks & Rescorla           Standards Track                    [Page 41]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      compression_method from that session.  This vector MUST contain,
      and all implementations MUST support, CompressionMethod.null.
      Thus, a client and server will always be able to agree on a
      compression method.

   extensions
      Clients MAY request extended functionality from servers by sending
      data in the extensions field.  The actual "Extension" format is
      defined in Section 7.4.1.4.

   In the event that a client requests additional functionality using
   extensions, and this functionality is not supplied by the server, the
   client MAY abort the handshake.  A server MUST accept ClientHello
   messages both with and without the extensions field, and (as for all
   other messages) it MUST check that the amount of data in the message
   precisely matches one of these formats; if not, then it MUST send a
   fatal "decode_error" alert.

   After sending the ClientHello message, the client waits for a
   ServerHello message.  Any handshake message returned by the server,
   except for a HelloRequest, is treated as a fatal error.

7.4.1.3.  Server Hello

   When this message will be sent:

      The server will send this message in response to a ClientHello
      message when it was able to find an acceptable set of algorithms.
      If it cannot find such a match, it will respond with a handshake
      failure alert.

   Structure of this message:

      struct {
          ProtocolVersion server_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ServerHello;





Dierks & Rescorla           Standards Track                    [Page 42]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The presence of extensions can be detected by determining whether
   there are bytes following the compression_method field at the end of
   the ServerHello.

   server_version
      This field will contain the lower of that suggested by the client
      in the client hello and the highest supported by the server.  For
      this version of the specification, the version is 3.3.  (See
      Appendix E for details about backward compatibility.)

   random
      This structure is generated by the server and MUST be
      independently generated from the ClientHello.random.

   session_id
      This is the identity of the session corresponding to this
      connection.  If the ClientHello.session_id was non-empty, the
      server will look in its session cache for a match.  If a match is
      found and the server is willing to establish the new connection
      using the specified session state, the server will respond with
      the same value as was supplied by the client.  This indicates a
      resumed session and dictates that the parties must proceed
      directly to the Finished messages.  Otherwise, this field will
      contain a different value identifying the new session.  The server
      may return an empty session_id to indicate that the session will
      not be cached and therefore cannot be resumed.  If a session is
      resumed, it must be resumed using the same cipher suite it was
      originally negotiated with.  Note that there is no requirement
      that the server resume any session even if it had formerly
      provided a session_id.  Clients MUST be prepared to do a full
      negotiation -- including negotiating new cipher suites -- during
      any handshake.

   cipher_suite
      The single cipher suite selected by the server from the list in
      ClientHello.cipher_suites.  For resumed sessions, this field is
      the value from the state of the session being resumed.

   compression_method
      The single compression algorithm selected by the server from the
      list in ClientHello.compression_methods.  For resumed sessions,
      this field is the value from the resumed session state.

   extensions
      A list of extensions.  Note that only extensions offered by the
      client can appear in the server's list.





Dierks & Rescorla           Standards Track                    [Page 43]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


7.4.1.4.  Hello Extensions

   The extension format is:

      struct {
          ExtensionType extension_type;
          opaque extension_data<0..2^16-1>;
      } Extension;

      enum {
          signature_algorithms(13), (65535)
      } ExtensionType;

   Here:

   -  "extension_type" identifies the particular extension type.

   -  "extension_data" contains information specific to the particular
      extension type.

   The initial set of extensions is defined in a companion document
   [TLSEXT].  The list of extension types is maintained by IANA as
   described in Section 12.

   An extension type MUST NOT appear in the ServerHello unless the same
   extension type appeared in the corresponding ClientHello.  If a
   client receives an extension type in ServerHello that it did not
   request in the associated ClientHello, it MUST abort the handshake
   with an unsupported_extension fatal alert.

   Nonetheless, "server-oriented" extensions may be provided in the
   future within this framework.  Such an extension (say, of type x)
   would require the client to first send an extension of type x in a
   ClientHello with empty extension_data to indicate that it supports
   the extension type.  In this case, the client is offering the
   capability to understand the extension type, and the server is taking
   the client up on its offer.

   When multiple extensions of different types are present in the
   ClientHello or ServerHello messages, the extensions MAY appear in any
   order.  There MUST NOT be more than one extension of the same type.

   Finally, note that extensions can be sent both when starting a new
   session and when requesting session resumption.  Indeed, a client
   that requests session resumption does not in general know whether the
   server will accept this request, and therefore it SHOULD send the
   same extensions as it would send if it were not attempting
   resumption.



Dierks & Rescorla           Standards Track                    [Page 44]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   In general, the specification of each extension type needs to
   describe the effect of the extension both during full handshake and
   session resumption.  Most current TLS extensions are relevant only
   when a session is initiated: when an older session is resumed, the
   server does not process these extensions in Client Hello, and does
   not include them in Server Hello.  However, some extensions may
   specify different behavior during session resumption.

   There are subtle (and not so subtle) interactions that may occur in
   this protocol between new features and existing features which may
   result in a significant reduction in overall security.  The following
   considerations should be taken into account when designing new
   extensions:

   -  Some cases where a server does not agree to an extension are error
      conditions, and some are simply refusals to support particular
      features.  In general, error alerts should be used for the former,
      and a field in the server extension response for the latter.

   -  Extensions should, as far as possible, be designed to prevent any
      attack that forces use (or non-use) of a particular feature by
      manipulation of handshake messages.  This principle should be
      followed regardless of whether the feature is believed to cause a
      security problem.

      Often the fact that the extension fields are included in the
      inputs to the Finished message hashes will be sufficient, but
      extreme care is needed when the extension changes the meaning of
      messages sent in the handshake phase.  Designers and implementors
      should be aware of the fact that until the handshake has been
      authenticated, active attackers can modify messages and insert,
      remove, or replace extensions.

   -  It would be technically possible to use extensions to change major
      aspects of the design of TLS; for example the design of cipher
      suite negotiation.  This is not recommended; it would be more
      appropriate to define a new version of TLS -- particularly since
      the TLS handshake algorithms have specific protection against
      version rollback attacks based on the version number, and the
      possibility of version rollback should be a significant
      consideration in any major design change.

7.4.1.4.1.  Signature Algorithms

   The client uses the "signature_algorithms" extension to indicate to
   the server which signature/hash algorithm pairs may be used in
   digital signatures.  The "extension_data" field of this extension
   contains a "supported_signature_algorithms" value.



Dierks & Rescorla           Standards Track                    [Page 45]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      enum {
          none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
          sha512(6), (255)
      } HashAlgorithm;

      enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
        SignatureAlgorithm;

      struct {
            HashAlgorithm hash;
            SignatureAlgorithm signature;
      } SignatureAndHashAlgorithm;

      SignatureAndHashAlgorithm
        supported_signature_algorithms<2..2^16-2>;

   Each SignatureAndHashAlgorithm value lists a single hash/signature
   pair that the client is willing to verify.  The values are indicated
   in descending order of preference.

   Note: Because not all signature algorithms and hash algorithms may be
   accepted by an implementation (e.g., DSA with SHA-1, but not
   SHA-256), algorithms here are listed in pairs.

   hash
      This field indicates the hash algorithm which may be used.  The
      values indicate support for unhashed data, MD5 [MD5], SHA-1,
      SHA-224, SHA-256, SHA-384, and SHA-512 [SHS], respectively.  The
      "none" value is provided for future extensibility, in case of a
      signature algorithm which does not require hashing before signing.

   signature
      This field indicates the signature algorithm that may be used.
      The values indicate anonymous signatures, RSASSA-PKCS1-v1_5
      [PKCS1] and DSA [DSS], and ECDSA [ECDSA], respectively.  The
      "anonymous" value is meaningless in this context but used in
      Section 7.4.3.  It MUST NOT appear in this extension.

   The semantics of this extension are somewhat complicated because the
   cipher suite indicates permissible signature algorithms but not hash
   algorithms.  Sections 7.4.2 and 7.4.3 describe the appropriate rules.

   If the client supports only the default hash and signature algorithms
   (listed in this section), it MAY omit the signature_algorithms
   extension.  If the client does not support the default algorithms, or
   supports other hash and signature algorithms (and it is willing to
   use them for verifying messages sent by the server, i.e., server
   certificates and server key exchange), it MUST send the



Dierks & Rescorla           Standards Track                    [Page 46]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   signature_algorithms extension, listing the algorithms it is willing
   to accept.

   If the client does not send the signature_algorithms extension, the
   server MUST do the following:

   -  If the negotiated key exchange algorithm is one of (RSA, DHE_RSA,
      DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA), behave as if client had
      sent the value {sha1,rsa}.

   -  If the negotiated key exchange algorithm is one of (DHE_DSS,
      DH_DSS), behave as if the client had sent the value {sha1,dsa}.

   -  If the negotiated key exchange algorithm is one of (ECDH_ECDSA,
      ECDHE_ECDSA), behave as if the client had sent value {sha1,ecdsa}.

   Note: this is a change from TLS 1.1 where there are no explicit
   rules, but as a practical matter one can assume that the peer
   supports MD5 and SHA-1.

   Note: this extension is not meaningful for TLS versions prior to 1.2.
   Clients MUST NOT offer it if they are offering prior versions.
   However, even if clients do offer it, the rules specified in [TLSEXT]
   require servers to ignore extensions they do not understand.

   Servers MUST NOT send this extension.  TLS servers MUST support
   receiving this extension.

   When performing session resumption, this extension is not included in
   Server Hello, and the server ignores the extension in Client Hello
   (if present).

7.4.2.  Server Certificate

   When this message will be sent:

      The server MUST send a Certificate message whenever the agreed-
      upon key exchange method uses certificates for authentication
      (this includes all key exchange methods defined in this document
      except DH_anon).  This message will always immediately follow the
      ServerHello message.

   Meaning of this message:

      This message conveys the server's certificate chain to the client.

      The certificate MUST be appropriate for the negotiated cipher
      suite's key exchange algorithm and any negotiated extensions.



Dierks & Rescorla           Standards Track                    [Page 47]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Structure of this message:

      opaque ASN.1Cert<1..2^24-1>;

      struct {
          ASN.1Cert certificate_list<0..2^24-1>;
      } Certificate;

   certificate_list
      This is a sequence (chain) of certificates.  The sender's
      certificate MUST come first in the list.  Each following
      certificate MUST directly certify the one preceding it.  Because
      certificate validation requires that root keys be distributed
      independently, the self-signed certificate that specifies the root
      certificate authority MAY be omitted from the chain, under the
      assumption that the remote end must already possess it in order to
      validate it in any case.

   The same message type and structure will be used for the client's
   response to a certificate request message.  Note that a client MAY
   send no certificates if it does not have an appropriate certificate
   to send in response to the server's authentication request.

   Note: PKCS #7 [PKCS7] is not used as the format for the certificate
   vector because PKCS #6 [PKCS6] extended certificates are not used.
   Also, PKCS #7 defines a SET rather than a SEQUENCE, making the task
   of parsing the list more difficult.

   The following rules apply to the certificates sent by the server:

   -  The certificate type MUST be X.509v3, unless explicitly negotiated
      otherwise (e.g., [TLSPGP]).

   -  The end entity certificate's public key (and associated
      restrictions) MUST be compatible with the selected key exchange
      algorithm.

      Key Exchange Alg.  Certificate Key Type

      RSA                RSA public key; the certificate MUST allow the
      RSA_PSK            key to be used for encryption (the
                         keyEncipherment bit MUST be set if the key
                         usage extension is present).
                         Note: RSA_PSK is defined in [TLSPSK].







Dierks & Rescorla           Standards Track                    [Page 48]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      DHE_RSA            RSA public key; the certificate MUST allow the
      ECDHE_RSA          key to be used for signing (the
                         digitalSignature bit MUST be set if the key
                         usage extension is present) with the signature
                         scheme and hash algorithm that will be employed
                         in the server key exchange message.
                         Note: ECDHE_RSA is defined in [TLSECC].

      DHE_DSS            DSA public key; the certificate MUST allow the
                         key to be used for signing with the hash
                         algorithm that will be employed in the server
                         key exchange message.

      DH_DSS             Diffie-Hellman public key; the keyAgreement bit
      DH_RSA             MUST be set if the key usage extension is
                         present.

      ECDH_ECDSA         ECDH-capable public key; the public key MUST
      ECDH_RSA           use a curve and point format supported by the
                         client, as described in [TLSECC].

      ECDHE_ECDSA        ECDSA-capable public key; the certificate MUST
                         allow the key to be used for signing with the
                         hash algorithm that will be employed in the
                         server key exchange message.  The public key
                         MUST use a curve and point format supported by
                         the client, as described in  [TLSECC].

   -  The "server_name" and "trusted_ca_keys" extensions [TLSEXT] are
      used to guide certificate selection.

   If the client provided a "signature_algorithms" extension, then all
   certificates provided by the server MUST be signed by a
   hash/signature algorithm pair that appears in that extension.  Note
   that this implies that a certificate containing a key for one
   signature algorithm MAY be signed using a different signature
   algorithm (for instance, an RSA key signed with a DSA key).  This is
   a departure from TLS 1.1, which required that the algorithms be the
   same.  Note that this also implies that the DH_DSS, DH_RSA,
   ECDH_ECDSA, and ECDH_RSA key exchange algorithms do not restrict the
   algorithm used to sign the certificate.  Fixed DH certificates MAY be
   signed with any hash/signature algorithm pair appearing in the
   extension.  The names DH_DSS, DH_RSA, ECDH_ECDSA, and ECDH_RSA are
   historical.







Dierks & Rescorla           Standards Track                    [Page 49]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   If the server has multiple certificates, it chooses one of them based
   on the above-mentioned criteria (in addition to other criteria, such
   as transport layer endpoint, local configuration and preferences,
   etc.).  If the server has a single certificate, it SHOULD attempt to
   validate that it meets these criteria.

   Note that there are certificates that use algorithms and/or algorithm
   combinations that cannot be currently used with TLS.  For example, a
   certificate with RSASSA-PSS signature key (id-RSASSA-PSS OID in
   SubjectPublicKeyInfo) cannot be used because TLS defines no
   corresponding signature algorithm.

   As cipher suites that specify new key exchange methods are specified
   for the TLS protocol, they will imply the certificate format and the
   required encoded keying information.

7.4.3.  Server Key Exchange Message

   When this message will be sent:

      This message will be sent immediately after the server Certificate
      message (or the ServerHello message, if this is an anonymous
      negotiation).

      The ServerKeyExchange message is sent by the server only when the
      server Certificate message (if sent) does not contain enough data
      to allow the client to exchange a premaster secret.  This is true
      for the following key exchange methods:

         DHE_DSS
         DHE_RSA
         DH_anon

      It is not legal to send the ServerKeyExchange message for the
      following key exchange methods:

         RSA
         DH_DSS
         DH_RSA

      Other key exchange algorithms, such as those defined in [TLSECC],
      MUST specify whether the ServerKeyExchange message is sent or not;
      and if the message is sent, its contents.








Dierks & Rescorla           Standards Track                    [Page 50]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Meaning of this message:

      This message conveys cryptographic information to allow the client
      to communicate the premaster secret: a Diffie-Hellman public key
      with which the client can complete a key exchange (with the result
      being the premaster secret) or a public key for some other
      algorithm.

   Structure of this message:

      enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa
            /* may be extended, e.g., for ECDH -- see [TLSECC] */
           } KeyExchangeAlgorithm;

      struct {
          opaque dh_p<1..2^16-1>;
          opaque dh_g<1..2^16-1>;
          opaque dh_Ys<1..2^16-1>;
      } ServerDHParams;     /* Ephemeral DH parameters */

      dh_p
         The prime modulus used for the Diffie-Hellman operation.

      dh_g
         The generator used for the Diffie-Hellman operation.

      dh_Ys
         The server's Diffie-Hellman public value (g^X mod p).























Dierks & Rescorla           Standards Track                    [Page 51]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          select (KeyExchangeAlgorithm) {
              case dh_anon:
                  ServerDHParams params;
              case dhe_dss:
              case dhe_rsa:
                  ServerDHParams params;
                  digitally-signed struct {
                      opaque client_random[32];
                      opaque server_random[32];
                      ServerDHParams params;
                  } signed_params;
              case rsa:
              case dh_dss:
              case dh_rsa:
                  struct {} ;
                 /* message is omitted for rsa, dh_dss, and dh_rsa */
              /* may be extended, e.g., for ECDH -- see [TLSECC] */
          };
      } ServerKeyExchange;

      params
         The server's key exchange parameters.

      signed_params
         For non-anonymous key exchanges, a signature over the server's
         key exchange parameters.

   If the client has offered the "signature_algorithms" extension, the
   signature algorithm and hash algorithm MUST be a pair listed in that
   extension.  Note that there is a possibility for inconsistencies
   here.  For instance, the client might offer DHE_DSS key exchange but
   omit any DSA pairs from its "signature_algorithms" extension.  In
   order to negotiate correctly, the server MUST check any candidate
   cipher suites against the "signature_algorithms" extension before
   selecting them.  This is somewhat inelegant but is a compromise
   designed to minimize changes to the original cipher suite design.

   In addition, the hash and signature algorithms MUST be compatible
   with the key in the server's end-entity certificate.  RSA keys MAY be
   used with any permitted hash algorithm, subject to restrictions in
   the certificate, if any.

   Because DSA signatures do not contain any secure indication of hash
   algorithm, there is a risk of hash substitution if multiple hashes
   may be used with any key.  Currently, DSA [DSS] may only be used with
   SHA-1.  Future revisions of DSS [DSS-3] are expected to allow the use
   of other digest algorithms with DSA, as well as guidance as to which



Dierks & Rescorla           Standards Track                    [Page 52]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   digest algorithms should be used with each key size.  In addition,
   future revisions of [PKIX] may specify mechanisms for certificates to
   indicate which digest algorithms are to be used with DSA.

   As additional cipher suites are defined for TLS that include new key
   exchange algorithms, the server key exchange message will be sent if
   and only if the certificate type associated with the key exchange
   algorithm does not provide enough information for the client to
   exchange a premaster secret.

7.4.4.  Certificate Request

   When this message will be sent:

       A non-anonymous server can optionally request a certificate from
       the client, if appropriate for the selected cipher suite.  This
       message, if sent, will immediately follow the ServerKeyExchange
       message (if it is sent; otherwise, this message follows the
       server's Certificate message).

   Structure of this message:

      enum {
          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
          rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
          fortezza_dms_RESERVED(20), (255)
      } ClientCertificateType;

      opaque DistinguishedName<1..2^16-1>;

      struct {
          ClientCertificateType certificate_types<1..2^8-1>;
          SignatureAndHashAlgorithm
            supported_signature_algorithms<2^16-1>;
          DistinguishedName certificate_authorities<0..2^16-1>;
      } CertificateRequest;

   certificate_types
      A list of the types of certificate types that the client may
      offer.

         rsa_sign        a certificate containing an RSA key
         dss_sign        a certificate containing a DSA key
         rsa_fixed_dh    a certificate containing a static DH key.
         dss_fixed_dh    a certificate containing a static DH key






Dierks & Rescorla           Standards Track                    [Page 53]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   supported_signature_algorithms
      A list of the hash/signature algorithm pairs that the server is
      able to verify, listed in descending order of preference.

   certificate_authorities
      A list of the distinguished names [X501] of acceptable
      certificate_authorities, represented in DER-encoded format.  These
      distinguished names may specify a desired distinguished name for a
      root CA or for a subordinate CA; thus, this message can be used to
      describe known roots as well as a desired authorization space.  If
      the certificate_authorities list is empty, then the client MAY
      send any certificate of the appropriate ClientCertificateType,
      unless there is some external arrangement to the contrary.

   The interaction of the certificate_types and
   supported_signature_algorithms fields is somewhat complicated.
   certificate_types has been present in TLS since SSLv3, but was
   somewhat underspecified.  Much of its functionality is superseded by
   supported_signature_algorithms.  The following rules apply:

   -  Any certificates provided by the client MUST be signed using a
      hash/signature algorithm pair found in
      supported_signature_algorithms.

   -  The end-entity certificate provided by the client MUST contain a
      key that is compatible with certificate_types.  If the key is a
      signature key, it MUST be usable with some hash/signature
      algorithm pair in supported_signature_algorithms.

   -  For historical reasons, the names of some client certificate types
      include the algorithm used to sign the certificate.  For example,
      in earlier versions of TLS, rsa_fixed_dh meant a certificate
      signed with RSA and containing a static DH key.  In TLS 1.2, this
      functionality has been obsoleted by the
      supported_signature_algorithms, and the certificate type no longer
      restricts the algorithm used to sign the certificate.  For
      example, if the server sends dss_fixed_dh certificate type and
      {{sha1, dsa}, {sha1, rsa}} signature types, the client MAY reply
      with a certificate containing a static DH key, signed with RSA-
      SHA1.

   New ClientCertificateType values are assigned by IANA as described in
   Section 12.

   Note: Values listed as RESERVED may not be used.  They were used in
   SSLv3.





Dierks & Rescorla           Standards Track                    [Page 54]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Note: It is a fatal handshake_failure alert for an anonymous server
   to request client authentication.

7.4.5.  Server Hello Done

   When this message will be sent:

      The ServerHelloDone message is sent by the server to indicate the
      end of the ServerHello and associated messages.  After sending
      this message, the server will wait for a client response.

   Meaning of this message:

      This message means that the server is done sending messages to
      support the key exchange, and the client can proceed with its
      phase of the key exchange.

      Upon receipt of the ServerHelloDone message, the client SHOULD
      verify that the server provided a valid certificate, if required,
      and check that the server hello parameters are acceptable.

   Structure of this message:

      struct { } ServerHelloDone;

7.4.6.  Client Certificate

   When this message will be sent:

      This is the first message the client can send after receiving a
      ServerHelloDone message.  This message is only sent if the server
      requests a certificate.  If no suitable certificate is available,
      the client MUST send a certificate message containing no
      certificates.  That is, the certificate_list structure has a
      length of zero.  If the client does not send any certificates, the
      server MAY at its discretion either continue the handshake without
      client authentication, or respond with a fatal handshake_failure
      alert.  Also, if some aspect of the certificate chain was
      unacceptable (e.g., it was not signed by a known, trusted CA), the
      server MAY at its discretion either continue the handshake
      (considering the client unauthenticated) or send a fatal alert.

      Client certificates are sent using the Certificate structure
      defined in Section 7.4.2.







Dierks & Rescorla           Standards Track                    [Page 55]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Meaning of this message:

      This message conveys the client's certificate chain to the server;
      the server will use it when verifying the CertificateVerify
      message (when the client authentication is based on signing) or
      calculating the premaster secret (for non-ephemeral Diffie-
      Hellman).  The certificate MUST be appropriate for the negotiated
      cipher suite's key exchange algorithm, and any negotiated
      extensions.

   In particular:

   -  The certificate type MUST be X.509v3, unless explicitly negotiated
      otherwise (e.g., [TLSPGP]).

   -  The end-entity certificate's public key (and associated
      restrictions) has to be compatible with the certificate types
      listed in CertificateRequest:

      Client Cert. Type   Certificate Key Type

      rsa_sign            RSA public key; the certificate MUST allow the
                          key to be used for signing with the signature
                          scheme and hash algorithm that will be
                          employed in the certificate verify message.

      dss_sign            DSA public key; the certificate MUST allow the
                          key to be used for signing with the hash
                          algorithm that will be employed in the
                          certificate verify message.

      ecdsa_sign          ECDSA-capable public key; the certificate MUST
                          allow the key to be used for signing with the
                          hash algorithm that will be employed in the
                          certificate verify message; the public key
                          MUST use a curve and point format supported by
                          the server.

      rsa_fixed_dh        Diffie-Hellman public key; MUST use the same
      dss_fixed_dh        parameters as server's key.

      rsa_fixed_ecdh      ECDH-capable public key; MUST use the
      ecdsa_fixed_ecdh    same curve as the server's key, and MUST use a
                          point format supported by the server.

   -  If the certificate_authorities list in the certificate request
      message was non-empty, one of the certificates in the certificate
      chain SHOULD be issued by one of the listed CAs.



Dierks & Rescorla           Standards Track                    [Page 56]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   -  The certificates MUST be signed using an acceptable hash/
      signature algorithm pair, as described in Section 7.4.4.  Note
      that this relaxes the constraints on certificate-signing
      algorithms found in prior versions of TLS.

   Note that, as with the server certificate, there are certificates
   that use algorithms/algorithm combinations that cannot be currently
   used with TLS.

7.4.7.  Client Key Exchange Message

   When this message will be sent:

      This message is always sent by the client.  It MUST immediately
      follow the client certificate message, if it is sent.  Otherwise,
      it MUST be the first message sent by the client after it receives
      the ServerHelloDone message.

   Meaning of this message:

      With this message, the premaster secret is set, either by direct
      transmission of the RSA-encrypted secret or by the transmission of
      Diffie-Hellman parameters that will allow each side to agree upon
      the same premaster secret.

      When the client is using an ephemeral Diffie-Hellman exponent,
      then this message contains the client's Diffie-Hellman public
      value.  If the client is sending a certificate containing a static
      DH exponent (i.e., it is doing fixed_dh client authentication),
      then this message MUST be sent but MUST be empty.

   Structure of this message:

      The choice of messages depends on which key exchange method has
      been selected.  See Section 7.4.3 for the KeyExchangeAlgorithm
      definition.















Dierks & Rescorla           Standards Track                    [Page 57]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      struct {
          select (KeyExchangeAlgorithm) {
              case rsa:
                  EncryptedPreMasterSecret;
              case dhe_dss:
              case dhe_rsa:
              case dh_dss:
              case dh_rsa:
              case dh_anon:
                  ClientDiffieHellmanPublic;
          } exchange_keys;
      } ClientKeyExchange;

7.4.7.1.  RSA-Encrypted Premaster Secret Message

   Meaning of this message:

      If RSA is being used for key agreement and authentication, the
      client generates a 48-byte premaster secret, encrypts it using the
      public key from the server's certificate, and sends the result in
      an encrypted premaster secret message.  This structure is a
      variant of the ClientKeyExchange message and is not a message in
      itself.

   Structure of this message:

      struct {
          ProtocolVersion client_version;
          opaque random[46];
      } PreMasterSecret;

      client_version
         The latest (newest) version supported by the client.  This is
         used to detect version rollback attacks.

      random
         46 securely-generated random bytes.

      struct {
          public-key-encrypted PreMasterSecret pre_master_secret;
      } EncryptedPreMasterSecret;

      pre_master_secret
         This random value is generated by the client and is used to
         generate the master secret, as specified in Section 8.1.






Dierks & Rescorla           Standards Track                    [Page 58]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Note: The version number in the PreMasterSecret is the version
   offered by the client in the ClientHello.client_version, not the
   version negotiated for the connection.  This feature is designed to
   prevent rollback attacks.  Unfortunately, some old implementations
   use the negotiated version instead, and therefore checking the
   version number may lead to failure to interoperate with such
   incorrect client implementations.

   Client implementations MUST always send the correct version number in
   PreMasterSecret.  If ClientHello.client_version is TLS 1.1 or higher,
   server implementations MUST check the version number as described in
   the note below.  If the version number is TLS 1.0 or earlier, server
   implementations SHOULD check the version number, but MAY have a
   configuration option to disable the check.  Note that if the check
   fails, the PreMasterSecret SHOULD be randomized as described below.

   Note: Attacks discovered by Bleichenbacher [BLEI] and Klima et al.
   [KPR03] can be used to attack a TLS server that reveals whether a
   particular message, when decrypted, is properly PKCS#1 formatted,
   contains a valid PreMasterSecret structure, or has the correct
   version number.

   As described by Klima [KPR03], these vulnerabilities can be avoided
   by treating incorrectly formatted message blocks and/or mismatched
   version numbers in a manner indistinguishable from correctly
   formatted RSA blocks.  In other words:

      1. Generate a string R of 46 random bytes

      2. Decrypt the message to recover the plaintext M

      3. If the PKCS#1 padding is not correct, or the length of message
         M is not exactly 48 bytes:
            pre_master_secret = ClientHello.client_version || R
         else If ClientHello.client_version <= TLS 1.0, and version
         number check is explicitly disabled:
            pre_master_secret = M
         else:
            pre_master_secret = ClientHello.client_version || M[2..47]

   Note that explicitly constructing the pre_master_secret with the
   ClientHello.client_version produces an invalid master_secret if the
   client has sent the wrong version in the original pre_master_secret.

   An alternative approach is to treat a version number mismatch as a
   PKCS-1 formatting error and randomize the premaster secret
   completely:




Dierks & Rescorla           Standards Track                    [Page 59]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      1. Generate a string R of 48 random bytes

      2. Decrypt the message to recover the plaintext M

      3. If the PKCS#1 padding is not correct, or the length of message
         M is not exactly 48 bytes:
            pre_master_secret = R
         else If ClientHello.client_version <= TLS 1.0, and version
         number check is explicitly disabled:
            premaster secret = M
         else If M[0..1] != ClientHello.client_version:
            premaster secret = R
         else:
            premaster secret = M

   Although no practical attacks against this construction are known,
   Klima et al. [KPR03] describe some theoretical attacks, and therefore
   the first construction described is RECOMMENDED.

   In any case, a TLS server MUST NOT generate an alert if processing an
   RSA-encrypted premaster secret message fails, or the version number
   is not as expected.  Instead, it MUST continue the handshake with a
   randomly generated premaster secret.  It may be useful to log the
   real cause of failure for troubleshooting purposes; however, care
   must be taken to avoid leaking the information to an attacker
   (through, e.g., timing, log files, or other channels.)

   The RSAES-OAEP encryption scheme defined in [PKCS1] is more secure
   against the Bleichenbacher attack.  However, for maximal
   compatibility with earlier versions of TLS, this specification uses
   the RSAES-PKCS1-v1_5 scheme.  No variants of the Bleichenbacher
   attack are known to exist provided that the above recommendations are
   followed.

   Implementation note: Public-key-encrypted data is represented as an
   opaque vector <0..2^16-1> (see Section 4.7).  Thus, the RSA-encrypted
   PreMasterSecret in a ClientKeyExchange is preceded by two length
   bytes.  These bytes are redundant in the case of RSA because the
   EncryptedPreMasterSecret is the only data in the ClientKeyExchange
   and its length can therefore be unambiguously determined.  The SSLv3
   specification was not clear about the encoding of public-key-
   encrypted data, and therefore many SSLv3 implementations do not
   include the length bytes -- they encode the RSA-encrypted data
   directly in the ClientKeyExchange message.

   This specification requires correct encoding of the
   EncryptedPreMasterSecret complete with length bytes.  The resulting
   PDU is incompatible with many SSLv3 implementations.  Implementors



Dierks & Rescorla           Standards Track                    [Page 60]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   upgrading from SSLv3 MUST modify their implementations to generate
   and accept the correct encoding.  Implementors who wish to be
   compatible with both SSLv3 and TLS should make their implementation's
   behavior dependent on the protocol version.

   Implementation note: It is now known that remote timing-based attacks
   on TLS are possible, at least when the client and server are on the
   same LAN.  Accordingly, implementations that use static RSA keys MUST
   use RSA blinding or some other anti-timing technique, as described in
   [TIMING].

7.4.7.2.  Client Diffie-Hellman Public Value

   Meaning of this message:

      This structure conveys the client's Diffie-Hellman public value
      (Yc) if it was not already included in the client's certificate.
      The encoding used for Yc is determined by the enumerated
      PublicValueEncoding.  This structure is a variant of the client
      key exchange message, and not a message in itself.

   Structure of this message:

      enum { implicit, explicit } PublicValueEncoding;

      implicit
         If the client has sent a certificate which contains a suitable
         Diffie-Hellman key (for fixed_dh client authentication), then
         Yc is implicit and does not need to be sent again.  In this
         case, the client key exchange message will be sent, but it MUST
         be empty.

      explicit
         Yc needs to be sent.

      struct {
          select (PublicValueEncoding) {
              case implicit: struct { };
              case explicit: opaque dh_Yc<1..2^16-1>;
          } dh_public;
      } ClientDiffieHellmanPublic;

      dh_Yc
         The client's Diffie-Hellman public value (Yc).







Dierks & Rescorla           Standards Track                    [Page 61]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


7.4.8.  Certificate Verify

   When this message will be sent:

      This message is used to provide explicit verification of a client
      certificate.  This message is only sent following a client
      certificate that has signing capability (i.e., all certificates
      except those containing fixed Diffie-Hellman parameters).  When
      sent, it MUST immediately follow the client key exchange message.

   Structure of this message:

      struct {
           digitally-signed struct {
               opaque handshake_messages[handshake_messages_length];
           }
      } CertificateVerify;

      Here handshake_messages refers to all handshake messages sent or
      received, starting at client hello and up to, but not including,
      this message, including the type and length fields of the
      handshake messages.  This is the concatenation of all the
      Handshake structures (as defined in Section 7.4) exchanged thus
      far.  Note that this requires both sides to either buffer the
      messages or compute running hashes for all potential hash
      algorithms up to the time of the CertificateVerify computation.
      Servers can minimize this computation cost by offering a
      restricted set of digest algorithms in the CertificateRequest
      message.

      The hash and signature algorithms used in the signature MUST be
      one of those present in the supported_signature_algorithms field
      of the CertificateRequest message.  In addition, the hash and
      signature algorithms MUST be compatible with the key in the
      client's end-entity certificate.  RSA keys MAY be used with any
      permitted hash algorithm, subject to restrictions in the
      certificate, if any.

      Because DSA signatures do not contain any secure indication of
      hash algorithm, there is a risk of hash substitution if multiple
      hashes may be used with any key.  Currently, DSA [DSS] may only be
      used with SHA-1.  Future revisions of DSS [DSS-3] are expected to
      allow the use of other digest algorithms with DSA, as well as
      guidance as to which digest algorithms should be used with each
      key size.  In addition, future revisions of [PKIX] may specify
      mechanisms for certificates to indicate which digest algorithms
      are to be used with DSA.




Dierks & Rescorla           Standards Track                    [Page 62]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


7.4.9.  Finished

   When this message will be sent:

      A Finished message is always sent immediately after a change
      cipher spec message to verify that the key exchange and
      authentication processes were successful.  It is essential that a
      change cipher spec message be received between the other handshake
      messages and the Finished message.

   Meaning of this message:

      The Finished message is the first one protected with the just
      negotiated algorithms, keys, and secrets.  Recipients of Finished
      messages MUST verify that the contents are correct.  Once a side
      has sent its Finished message and received and validated the
      Finished message from its peer, it may begin to send and receive
      application data over the connection.

   Structure of this message:

      struct {
          opaque verify_data[verify_data_length];
      } Finished;

      verify_data
         PRF(master_secret, finished_label, Hash(handshake_messages))
            [0..verify_data_length-1];

      finished_label
         For Finished messages sent by the client, the string
         "client finished".  For Finished messages sent by the server,
         the string "server finished".

      Hash denotes a Hash of the handshake messages.  For the PRF
      defined in Section 5, the Hash MUST be the Hash used as the basis
      for the PRF.  Any cipher suite which defines a different PRF MUST
      also define the Hash to use in the Finished computation.

      In previous versions of TLS, the verify_data was always 12 octets
      long.  In the current version of TLS, it depends on the cipher
      suite.  Any cipher suite which does not explicitly specify
      verify_data_length has a verify_data_length equal to 12.  This
      includes all existing cipher suites.  Note that this
      representation has the same encoding as with previous versions.
      Future cipher suites MAY specify other lengths but such length
      MUST be at least 12 bytes.




Dierks & Rescorla           Standards Track                    [Page 63]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      handshake_messages
         All of the data from all messages in this handshake (not
         including any HelloRequest messages) up to, but not including,
         this message.  This is only data visible at the handshake layer
         and does not include record layer headers.  This is the
         concatenation of all the Handshake structures as defined in
         Section 7.4, exchanged thus far.

   It is a fatal error if a Finished message is not preceded by a
   ChangeCipherSpec message at the appropriate point in the handshake.

   The value handshake_messages includes all handshake messages starting
   at ClientHello up to, but not including, this Finished message.  This
   may be different from handshake_messages in Section 7.4.8 because it
   would include the CertificateVerify message (if sent).  Also, the
   handshake_messages for the Finished message sent by the client will
   be different from that for the Finished message sent by the server,
   because the one that is sent second will include the prior one.

   Note: ChangeCipherSpec messages, alerts, and any other record types
   are not handshake messages and are not included in the hash
   computations.  Also, HelloRequest messages are omitted from handshake
   hashes.

8.  Cryptographic Computations

   In order to begin connection protection, the TLS Record Protocol
   requires specification of a suite of algorithms, a master secret, and
   the client and server random values.  The authentication, encryption,
   and MAC algorithms are determined by the cipher_suite selected by the
   server and revealed in the ServerHello message.  The compression
   algorithm is negotiated in the hello messages, and the random values
   are exchanged in the hello messages.  All that remains is to
   calculate the master secret.

8.1.  Computing the Master Secret

   For all key exchange methods, the same algorithm is used to convert
   the pre_master_secret into the master_secret.  The pre_master_secret
   should be deleted from memory once the master_secret has been
   computed.

      master_secret = PRF(pre_master_secret, "master secret",
                          ClientHello.random + ServerHello.random)
                          [0..47];

   The master secret is always exactly 48 bytes in length.  The length
   of the premaster secret will vary depending on key exchange method.



Dierks & Rescorla           Standards Track                    [Page 64]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


8.1.1.  RSA

   When RSA is used for server authentication and key exchange, a 48-
   byte pre_master_secret is generated by the client, encrypted under
   the server's public key, and sent to the server.  The server uses its
   private key to decrypt the pre_master_secret.  Both parties then
   convert the pre_master_secret into the master_secret, as specified
   above.

8.1.2.  Diffie-Hellman

   A conventional Diffie-Hellman computation is performed.  The
   negotiated key (Z) is used as the pre_master_secret, and is converted
   into the master_secret, as specified above.  Leading bytes of Z that
   contain all zero bits are stripped before it is used as the
   pre_master_secret.

   Note: Diffie-Hellman parameters are specified by the server and may
   be either ephemeral or contained within the server's certificate.

9.  Mandatory Cipher Suites

   In the absence of an application profile standard specifying
   otherwise, a TLS-compliant application MUST implement the cipher
   suite TLS_RSA_WITH_AES_128_CBC_SHA (see Appendix A.5 for the
   definition).

10.  Application Data Protocol

   Application data messages are carried by the record layer and are
   fragmented, compressed, and encrypted based on the current connection
   state.  The messages are treated as transparent data to the record
   layer.

11.  Security Considerations

   Security issues are discussed throughout this memo, especially in
   Appendices D, E, and F.

12.  IANA Considerations

   This document uses several registries that were originally created in
   [TLS1.1].  IANA has updated these to reference this document.  The
   registries and their allocation policies (unchanged from [TLS1.1])
   are listed below.






Dierks & Rescorla           Standards Track                    [Page 65]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   -  TLS ClientCertificateType Identifiers Registry: Future values in
      the range 0-63 (decimal) inclusive are assigned via Standards
      Action [RFC2434].  Values in the range 64-223 (decimal) inclusive
      are assigned via Specification Required [RFC2434].  Values from
      224-255 (decimal) inclusive are reserved for Private Use
      [RFC2434].

   -  TLS Cipher Suite Registry: Future values with the first byte in
      the range 0-191 (decimal) inclusive are assigned via Standards
      Action [RFC2434].  Values with the first byte in the range 192-254
      (decimal) are assigned via Specification Required [RFC2434].
      Values with the first byte 255 (decimal) are reserved for Private
      Use [RFC2434].

   -  This document defines several new HMAC-SHA256-based cipher suites,
      whose values (in Appendix A.5) have been allocated from the TLS
      Cipher Suite registry.

   -  TLS ContentType Registry: Future values are allocated via
      Standards Action [RFC2434].

   -  TLS Alert Registry: Future values are allocated via Standards
      Action [RFC2434].

   -  TLS HandshakeType Registry: Future values are allocated via
      Standards Action [RFC2434].

   This document also uses a registry originally created in [RFC4366].
   IANA has updated it to reference this document.  The registry and its
   allocation policy (unchanged from [RFC4366]) is listed below:

   -  TLS ExtensionType Registry: Future values are allocated via IETF
      Consensus [RFC2434].  IANA has updated this registry to include
      the signature_algorithms extension and its corresponding value
      (see Section 7.4.1.4).

   In addition, this document defines two new registries to be
   maintained by IANA:

   -  TLS SignatureAlgorithm Registry: The registry has been initially
      populated with the values described in Section 7.4.1.4.1.  Future
      values in the range 0-63 (decimal) inclusive are assigned via
      Standards Action [RFC2434].  Values in the range 64-223 (decimal)
      inclusive are assigned via Specification Required [RFC2434].
      Values from 224-255 (decimal) inclusive are reserved for Private
      Use [RFC2434].





Dierks & Rescorla           Standards Track                    [Page 66]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   -  TLS HashAlgorithm Registry: The registry has been initially
      populated with the values described in Section 7.4.1.4.1.  Future
      values in the range 0-63 (decimal) inclusive are assigned via
      Standards Action [RFC2434].  Values in the range 64-223 (decimal)
      inclusive are assigned via Specification Required [RFC2434].
      Values from 224-255 (decimal) inclusive are reserved for Private
      Use [RFC2434].

      This document also uses the TLS Compression Method Identifiers
      Registry, defined in [RFC3749].  IANA has allocated value 0 for
      the "null" compression method.








































Dierks & Rescorla           Standards Track                    [Page 67]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


Appendix A.  Protocol Data Structures and Constant Values

   This section describes protocol types and constants.

A.1.  Record Layer

   struct {
       uint8 major;
       uint8 minor;
   } ProtocolVersion;

   ProtocolVersion version = { 3, 3 };     /* TLS v1.2*/

   enum {
       change_cipher_spec(20), alert(21), handshake(22),
       application_data(23), (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSCompressed.length];
   } TLSCompressed;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       select (SecurityParameters.cipher_type) {
           case stream: GenericStreamCipher;
           case block:  GenericBlockCipher;
           case aead:   GenericAEADCipher;
       } fragment;
   } TLSCiphertext;

   stream-ciphered struct {
       opaque content[TLSCompressed.length];
       opaque MAC[SecurityParameters.mac_length];
   } GenericStreamCipher;




Dierks & Rescorla           Standards Track                    [Page 68]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   struct {
       opaque IV[SecurityParameters.record_iv_length];
       block-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[SecurityParameters.mac_length];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       };
   } GenericBlockCipher;

   struct {
      opaque nonce_explicit[SecurityParameters.record_iv_length];
      aead-ciphered struct {
          opaque content[TLSCompressed.length];
      };
   } GenericAEADCipher;

A.2.  Change Cipher Specs Message

   struct {
       enum { change_cipher_spec(1), (255) } type;
   } ChangeCipherSpec;

A.3.  Alert Messages

   enum { warning(1), fatal(2), (255) } AlertLevel;

   enum {
       close_notify(0),
       unexpected_message(10),
       bad_record_mac(20),
       decryption_failed_RESERVED(21),
       record_overflow(22),
       decompression_failure(30),
       handshake_failure(40),
       no_certificate_RESERVED(41),
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),
       unknown_ca(48),
       access_denied(49),
       decode_error(50),
       decrypt_error(51),
       export_restriction_RESERVED(60),
       protocol_version(70),



Dierks & Rescorla           Standards Track                    [Page 69]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


       insufficient_security(71),
       internal_error(80),
       user_canceled(90),
       no_renegotiation(100),
       unsupported_extension(110),           /* new */
       (255)
   } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;

A.4.  Handshake Protocol

   enum {
       hello_request(0), client_hello(1), server_hello(2),
       certificate(11), server_key_exchange (12),
       certificate_request(13), server_hello_done(14),
       certificate_verify(15), client_key_exchange(16),
       finished(20)
       (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;
       uint24 length;
       select (HandshakeType) {
           case hello_request:       HelloRequest;
           case client_hello:        ClientHello;
           case server_hello:        ServerHello;
           case certificate:         Certificate;
           case server_key_exchange: ServerKeyExchange;
           case certificate_request: CertificateRequest;
           case server_hello_done:   ServerHelloDone;
           case certificate_verify:  CertificateVerify;
           case client_key_exchange: ClientKeyExchange;
           case finished:            Finished;
       } body;
   } Handshake;











Dierks & Rescorla           Standards Track                    [Page 70]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


A.4.1.  Hello Messages

   struct { } HelloRequest;

   struct {
       uint32 gmt_unix_time;
       opaque random_bytes[28];
   } Random;

   opaque SessionID<0..32>;

   uint8 CipherSuite[2];

   enum { null(0), (255) } CompressionMethod;

   struct {
       ProtocolVersion client_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suites<2..2^16-2>;
       CompressionMethod compression_methods<1..2^8-1>;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions<0..2^16-1>;
       };
   } ClientHello;

   struct {
       ProtocolVersion server_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suite;
       CompressionMethod compression_method;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions<0..2^16-1>;
       };
   } ServerHello;

   struct {
       ExtensionType extension_type;
       opaque extension_data<0..2^16-1>;
   } Extension;




Dierks & Rescorla           Standards Track                    [Page 71]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   enum {
       signature_algorithms(13), (65535)
   } ExtensionType;

   enum{
       none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
       sha512(6), (255)
   } HashAlgorithm;
   enum {
      anonymous(0), rsa(1), dsa(2), ecdsa(3), (255)
   } SignatureAlgorithm;

   struct {
         HashAlgorithm hash;
         SignatureAlgorithm signature;
   } SignatureAndHashAlgorithm;

   SignatureAndHashAlgorithm
    supported_signature_algorithms<2..2^16-1>;

A.4.2.  Server Authentication and Key Exchange Messages

   opaque ASN.1Cert<2^24-1>;

   struct {
       ASN.1Cert certificate_list<0..2^24-1>;
   } Certificate;

   enum { dhe_dss, dhe_rsa, dh_anon, rsa,dh_dss, dh_rsa
          /* may be extended, e.g., for ECDH -- see [TLSECC] */
        } KeyExchangeAlgorithm;

   struct {
       opaque dh_p<1..2^16-1>;
       opaque dh_g<1..2^16-1>;
       opaque dh_Ys<1..2^16-1>;
   } ServerDHParams;     /* Ephemeral DH parameters */














Dierks & Rescorla           Standards Track                    [Page 72]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   struct {
       select (KeyExchangeAlgorithm) {
           case dh_anon:
               ServerDHParams params;
           case dhe_dss:
           case dhe_rsa:
               ServerDHParams params;
               digitally-signed struct {
                   opaque client_random[32];
                   opaque server_random[32];
                   ServerDHParams params;
               } signed_params;
           case rsa:
           case dh_dss:
           case dh_rsa:
               struct {} ;
              /* message is omitted for rsa, dh_dss, and dh_rsa */
           /* may be extended, e.g., for ECDH -- see [TLSECC] */
   } ServerKeyExchange;

   enum {
       rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
       rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
       fortezza_dms_RESERVED(20),
       (255)
   } ClientCertificateType;

   opaque DistinguishedName<1..2^16-1>;

   struct {
       ClientCertificateType certificate_types<1..2^8-1>;
       DistinguishedName certificate_authorities<0..2^16-1>;
   } CertificateRequest;

   struct { } ServerHelloDone;
















Dierks & Rescorla           Standards Track                    [Page 73]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


A.4.3.  Client Authentication and Key Exchange Messages

   struct {
       select (KeyExchangeAlgorithm) {
           case rsa:
               EncryptedPreMasterSecret;
           case dhe_dss:
           case dhe_rsa:
           case dh_dss:
           case dh_rsa:
           case dh_anon:
               ClientDiffieHellmanPublic;
       } exchange_keys;
   } ClientKeyExchange;

   struct {
       ProtocolVersion client_version;
       opaque random[46];
   } PreMasterSecret;

   struct {
       public-key-encrypted PreMasterSecret pre_master_secret;
   } EncryptedPreMasterSecret;

   enum { implicit, explicit } PublicValueEncoding;

   struct {
       select (PublicValueEncoding) {
           case implicit: struct {};
           case explicit: opaque DH_Yc<1..2^16-1>;
       } dh_public;
   } ClientDiffieHellmanPublic;

   struct {
        digitally-signed struct {
            opaque handshake_messages[handshake_messages_length];
        }
   } CertificateVerify;

A.4.4.  Handshake Finalization Message

   struct {
       opaque verify_data[verify_data_length];
   } Finished;







Dierks & Rescorla           Standards Track                    [Page 74]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


A.5.  The Cipher Suite

   The following values define the cipher suite codes used in the
   ClientHello and ServerHello messages.

   A cipher suite defines a cipher specification supported in TLS
   Version 1.2.

   TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a
   TLS connection during the first handshake on that channel, but MUST
   NOT be negotiated, as it provides no more protection than an
   unsecured connection.

      CipherSuite TLS_NULL_WITH_NULL_NULL               = { 0x00,0x00 };

   The following CipherSuite definitions require that the server provide
   an RSA certificate that can be used for key exchange.  The server may
   request any signature-capable certificate in the certificate request
   message.

      CipherSuite TLS_RSA_WITH_NULL_MD5                 = { 0x00,0x01 };
      CipherSuite TLS_RSA_WITH_NULL_SHA                 = { 0x00,0x02 };
      CipherSuite TLS_RSA_WITH_NULL_SHA256              = { 0x00,0x3B };
      CipherSuite TLS_RSA_WITH_RC4_128_MD5              = { 0x00,0x04 };
      CipherSuite TLS_RSA_WITH_RC4_128_SHA              = { 0x00,0x05 };
      CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA         = { 0x00,0x0A };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA          = { 0x00,0x2F };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA          = { 0x00,0x35 };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256       = { 0x00,0x3C };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256       = { 0x00,0x3D };

   The following cipher suite definitions are used for server-
   authenticated (and optionally client-authenticated) Diffie-Hellman.
   DH denotes cipher suites in which the server's certificate contains
   the Diffie-Hellman parameters signed by the certificate authority
   (CA).  DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman
   parameters are signed by a signature-capable certificate, which has
   been signed by the CA.  The signing algorithm used by the server is
   specified after the DHE component of the CipherSuite name.  The
   server can request any signature-capable certificate from the client
   for client authentication, or it may request a Diffie-Hellman
   certificate.  Any Diffie-Hellman certificate provided by the client
   must use the parameters (group and generator) described by the
   server.







Dierks & Rescorla           Standards Track                    [Page 75]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x0D };
      CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x10 };
      CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x13 };
      CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x16 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA       = { 0x00,0x30 };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA       = { 0x00,0x31 };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA      = { 0x00,0x32 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA      = { 0x00,0x33 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA       = { 0x00,0x36 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA       = { 0x00,0x37 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA      = { 0x00,0x38 };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA      = { 0x00,0x39 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256    = { 0x00,0x3E };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256    = { 0x00,0x3F };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256   = { 0x00,0x40 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256   = { 0x00,0x67 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256    = { 0x00,0x68 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256    = { 0x00,0x69 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256   = { 0x00,0x6A };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256   = { 0x00,0x6B };

   The following cipher suites are used for completely anonymous
   Diffie-Hellman communications in which neither party is
   authenticated.  Note that this mode is vulnerable to man-in-the-
   middle attacks.  Using this mode therefore is of limited use: These
   cipher suites MUST NOT be used by TLS 1.2 implementations unless the
   application layer has specifically requested to allow anonymous key
   exchange.  (Anonymous key exchange may sometimes be acceptable, for
   example, to support opportunistic encryption when no set-up for
   authentication is in place, or when TLS is used as part of more
   complex security protocols that have other means to ensure
   authentication.)

      CipherSuite TLS_DH_anon_WITH_RC4_128_MD5          = { 0x00,0x18 };
      CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x1B };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA      = { 0x00,0x34 };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA      = { 0x00,0x3A };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256   = { 0x00,0x6C };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256   = { 0x00,0x6D };

   Note that using non-anonymous key exchange without actually verifying
   the key exchange is essentially equivalent to anonymous key exchange,
   and the same precautions apply.  While non-anonymous key exchange
   will generally involve a higher computational and communicational
   cost than anonymous key exchange, it may be in the interest of
   interoperability not to disable non-anonymous key exchange when the
   application layer is allowing anonymous key exchange.




Dierks & Rescorla           Standards Track                    [Page 76]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   New cipher suite values have been assigned by IANA as described in
   Section 12.

   Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are
   reserved to avoid collision with Fortezza-based cipher suites in
   SSL 3.

A.6.  The Security Parameters

   These security parameters are determined by the TLS Handshake
   Protocol and provided as parameters to the TLS record layer in order
   to initialize a connection state.  SecurityParameters includes:

   enum { null(0), (255) } CompressionMethod;

   enum { server, client } ConnectionEnd;

   enum { tls_prf_sha256 } PRFAlgorithm;

   enum { null, rc4, 3des, aes } BulkCipherAlgorithm;

   enum { stream, block, aead } CipherType;

   enum { null, hmac_md5, hmac_sha1, hmac_sha256, hmac_sha384,
     hmac_sha512} MACAlgorithm;

   /* Other values may be added to the algorithms specified in
   CompressionMethod, PRFAlgorithm, BulkCipherAlgorithm, and
   MACAlgorithm. */

   struct {
       ConnectionEnd          entity;
       PRFAlgorithm           prf_algorithm;
       BulkCipherAlgorithm    bulk_cipher_algorithm;
       CipherType             cipher_type;
       uint8                  enc_key_length;
       uint8                  block_length;
       uint8                  fixed_iv_length;
       uint8                  record_iv_length;
       MACAlgorithm           mac_algorithm;
       uint8                  mac_length;
       uint8                  mac_key_length;
       CompressionMethod      compression_algorithm;
       opaque                 master_secret[48];
       opaque                 client_random[32];
       opaque                 server_random[32];
   } SecurityParameters;




Dierks & Rescorla           Standards Track                    [Page 77]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


A.7.  Changes to RFC 4492

   RFC 4492 [TLSECC] adds Elliptic Curve cipher suites to TLS.  This
   document changes some of the structures used in that document.  This
   section details the required changes for implementors of both RFC
   4492 and TLS 1.2.  Implementors of TLS 1.2 who are not implementing
   RFC 4492 do not need to read this section.

   This document adds a "signature_algorithm" field to the digitally-
   signed element in order to identify the signature and digest
   algorithms used to create a signature.  This change applies to
   digital signatures formed using ECDSA as well, thus allowing ECDSA
   signatures to be used with digest algorithms other than SHA-1,
   provided such use is compatible with the certificate and any
   restrictions imposed by future revisions of [PKIX].

   As described in Sections 7.4.2 and 7.4.6, the restrictions on the
   signature algorithms used to sign certificates are no longer tied to
   the cipher suite (when used by the server) or the
   ClientCertificateType (when used by the client).  Thus, the
   restrictions on the algorithm used to sign certificates specified in
   Sections 2 and 3 of RFC 4492 are also relaxed.  As in this document,
   the restrictions on the keys in the end-entity certificate remain.

Appendix B.  Glossary

   Advanced Encryption Standard (AES)
      AES [AES] is a widely used symmetric encryption algorithm.  AES is
      a block cipher with a 128-, 192-, or 256-bit keys and a 16-byte
      block size.  TLS currently only supports the 128- and 256-bit key
      sizes.

   application protocol
      An application protocol is a protocol that normally layers
      directly on top of the transport layer (e.g., TCP/IP).  Examples
      include HTTP, TELNET, FTP, and SMTP.

   asymmetric cipher
      See public key cryptography.

   authenticated encryption with additional data (AEAD)
      A symmetric encryption algorithm that simultaneously provides
      confidentiality and message integrity.

   authentication
      Authentication is the ability of one entity to determine the
      identity of another entity.




Dierks & Rescorla           Standards Track                    [Page 78]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   block cipher
      A block cipher is an algorithm that operates on plaintext in
      groups of bits, called blocks.  64 bits was, and 128 bits is, a
      common block size.

   bulk cipher
      A symmetric encryption algorithm used to encrypt large quantities
      of data.

   cipher block chaining (CBC)
      CBC is a mode in which every plaintext block encrypted with a
      block cipher is first exclusive-ORed with the previous ciphertext
      block (or, in the case of the first block, with the initialization
      vector).  For decryption, every block is first decrypted, then
      exclusive-ORed with the previous ciphertext block (or IV).

   certificate
      As part of the X.509 protocol (a.k.a. ISO Authentication
      framework), certificates are assigned by a trusted Certificate
      Authority and provide a strong binding between a party's identity
      or some other attributes and its public key.

   client
      The application entity that initiates a TLS connection to a
      server.  This may or may not imply that the client initiated the
      underlying transport connection.  The primary operational
      difference between the server and client is that the server is
      generally authenticated, while the client is only optionally
      authenticated.

   client write key
      The key used to encrypt data written by the client.

   client write MAC key
      The secret data used to authenticate data written by the client.

   connection
      A connection is a transport (in the OSI layering model definition)
      that provides a suitable type of service.  For TLS, such
      connections are peer-to-peer relationships.  The connections are
      transient.  Every connection is associated with one session.

   Data Encryption Standard
      DES [DES] still is a very widely used symmetric encryption
      algorithm although it is considered as rather weak now.  DES is a
      block cipher with a 56-bit key and an 8-byte block size.  Note
      that in TLS, for key generation purposes, DES is treated as having
      an 8-byte key length (64 bits), but it still only provides 56 bits



Dierks & Rescorla           Standards Track                    [Page 79]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


      of protection.  (The low bit of each key byte is presumed to be
      set to produce odd parity in that key byte.)  DES can also be
      operated in a mode [3DES] where three independent keys and three
      encryptions are used for each block of data; this uses 168 bits of
      key (24 bytes in the TLS key generation method) and provides the
      equivalent of 112 bits of security.

   Digital Signature Standard (DSS)
      A standard for digital signing, including the Digital Signing
      Algorithm, approved by the National Institute of Standards and
      Technology, defined in NIST FIPS PUB 186-2, "Digital Signature
      Standard", published January 2000 by the U.S. Department of
      Commerce [DSS].  A significant update [DSS-3] has been drafted and
      was published in March 2006.

   digital signatures
      Digital signatures utilize public key cryptography and one-way
      hash functions to produce a signature of the data that can be
      authenticated, and is difficult to forge or repudiate.

   handshake An initial negotiation between client and server that
      establishes the parameters of their transactions.

   Initialization Vector (IV)
      When a block cipher is used in CBC mode, the initialization vector
      is exclusive-ORed with the first plaintext block prior to
      encryption.

   Message Authentication Code (MAC)
      A Message Authentication Code is a one-way hash computed from a
      message and some secret data.  It is difficult to forge without
      knowing the secret data.  Its purpose is to detect if the message
      has been altered.

   master secret
      Secure secret data used for generating encryption keys, MAC
      secrets, and IVs.

   MD5
      MD5 [MD5] is a hashing function that converts an arbitrarily long
      data stream into a hash of fixed size (16 bytes).  Due to
      significant progress in cryptanalysis, at the time of publication
      of this document, MD5 no longer can be considered a 'secure'
      hashing function.







Dierks & Rescorla           Standards Track                    [Page 80]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   public key cryptography
      A class of cryptographic techniques employing two-key ciphers.
      Messages encrypted with the public key can only be decrypted with
      the associated private key.  Conversely, messages signed with the
      private key can be verified with the public key.

   one-way hash function
      A one-way transformation that converts an arbitrary amount of data
      into a fixed-length hash.  It is computationally hard to reverse
      the transformation or to find collisions.  MD5 and SHA are
      examples of one-way hash functions.

   RC4
      A stream cipher invented by Ron Rivest.  A compatible cipher is
      described in [SCH].

   RSA
      A very widely used public key algorithm that can be used for
      either encryption or digital signing.  [RSA]

   server
      The server is the application entity that responds to requests for
      connections from clients.  See also "client".

   session
      A TLS session is an association between a client and a server.
      Sessions are created by the handshake protocol.  Sessions define a
      set of cryptographic security parameters that can be shared among
      multiple connections.  Sessions are used to avoid the expensive
      negotiation of new security parameters for each connection.

   session identifier
      A session identifier is a value generated by a server that
      identifies a particular session.

   server write key
      The key used to encrypt data written by the server.

   server write MAC key
      The secret data used to authenticate data written by the server.

   SHA
      The Secure Hash Algorithm [SHS] is defined in FIPS PUB 180-2.  It
      produces a 20-byte output.  Note that all references to SHA
      (without a numerical suffix) actually use the modified SHA-1
      algorithm.





Dierks & Rescorla           Standards Track                    [Page 81]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   SHA-256
      The 256-bit Secure Hash Algorithm is defined in FIPS PUB 180-2.
      It produces a 32-byte output.

   SSL
      Netscape's Secure Socket Layer protocol [SSL3].  TLS is based on
      SSL Version 3.0.

   stream cipher
      An encryption algorithm that converts a key into a
      cryptographically strong keystream, which is then exclusive-ORed
      with the plaintext.

   symmetric cipher
      See bulk cipher.

   Transport Layer Security (TLS)
      This protocol; also, the Transport Layer Security working group of
      the Internet Engineering Task Force (IETF).  See "Working Group
      Information" at the end of this document (see page 99).































Dierks & Rescorla           Standards Track                    [Page 82]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


Appendix C.  Cipher Suite Definitions

Cipher Suite                            Key        Cipher         Mac
                                        Exchange

TLS_NULL_WITH_NULL_NULL                 NULL         NULL         NULL
TLS_RSA_WITH_NULL_MD5                   RSA          NULL         MD5
TLS_RSA_WITH_NULL_SHA                   RSA          NULL         SHA
TLS_RSA_WITH_NULL_SHA256                RSA          NULL         SHA256
TLS_RSA_WITH_RC4_128_MD5                RSA          RC4_128      MD5
TLS_RSA_WITH_RC4_128_SHA                RSA          RC4_128      SHA
TLS_RSA_WITH_3DES_EDE_CBC_SHA           RSA          3DES_EDE_CBC SHA
TLS_RSA_WITH_AES_128_CBC_SHA            RSA          AES_128_CBC  SHA
TLS_RSA_WITH_AES_256_CBC_SHA            RSA          AES_256_CBC  SHA
TLS_RSA_WITH_AES_128_CBC_SHA256         RSA          AES_128_CBC  SHA256
TLS_RSA_WITH_AES_256_CBC_SHA256         RSA          AES_256_CBC  SHA256
TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS       3DES_EDE_CBC SHA
TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA       3DES_EDE_CBC SHA
TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS      3DES_EDE_CBC SHA
TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA      3DES_EDE_CBC SHA
TLS_DH_anon_WITH_RC4_128_MD5            DH_anon      RC4_128      MD5
TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon      3DES_EDE_CBC SHA
TLS_DH_DSS_WITH_AES_128_CBC_SHA         DH_DSS       AES_128_CBC  SHA
TLS_DH_RSA_WITH_AES_128_CBC_SHA         DH_RSA       AES_128_CBC  SHA
TLS_DHE_DSS_WITH_AES_128_CBC_SHA        DHE_DSS      AES_128_CBC  SHA
TLS_DHE_RSA_WITH_AES_128_CBC_SHA        DHE_RSA      AES_128_CBC  SHA
TLS_DH_anon_WITH_AES_128_CBC_SHA        DH_anon      AES_128_CBC  SHA
TLS_DH_DSS_WITH_AES_256_CBC_SHA         DH_DSS       AES_256_CBC  SHA
TLS_DH_RSA_WITH_AES_256_CBC_SHA         DH_RSA       AES_256_CBC  SHA
TLS_DHE_DSS_WITH_AES_256_CBC_SHA        DHE_DSS      AES_256_CBC  SHA
TLS_DHE_RSA_WITH_AES_256_CBC_SHA        DHE_RSA      AES_256_CBC  SHA
TLS_DH_anon_WITH_AES_256_CBC_SHA        DH_anon      AES_256_CBC  SHA
TLS_DH_DSS_WITH_AES_128_CBC_SHA256      DH_DSS       AES_128_CBC  SHA256
TLS_DH_RSA_WITH_AES_128_CBC_SHA256      DH_RSA       AES_128_CBC  SHA256
TLS_DHE_DSS_WITH_AES_128_CBC_SHA256     DHE_DSS      AES_128_CBC  SHA256
TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     DHE_RSA      AES_128_CBC  SHA256
TLS_DH_anon_WITH_AES_128_CBC_SHA256     DH_anon      AES_128_CBC  SHA256
TLS_DH_DSS_WITH_AES_256_CBC_SHA256      DH_DSS       AES_256_CBC  SHA256
TLS_DH_RSA_WITH_AES_256_CBC_SHA256      DH_RSA       AES_256_CBC  SHA256
TLS_DHE_DSS_WITH_AES_256_CBC_SHA256     DHE_DSS      AES_256_CBC  SHA256
TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     DHE_RSA      AES_256_CBC  SHA256
TLS_DH_anon_WITH_AES_256_CBC_SHA256     DH_anon      AES_256_CBC  SHA256









Dierks & Rescorla           Standards Track                    [Page 83]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


                        Key      IV   Block
Cipher        Type    Material  Size  Size
------------  ------  --------  ----  -----
NULL          Stream      0       0    N/A
RC4_128       Stream     16       0    N/A
3DES_EDE_CBC  Block      24       8      8
AES_128_CBC   Block      16      16     16
AES_256_CBC   Block      32      16     16


MAC       Algorithm    mac_length  mac_key_length
--------  -----------  ----------  --------------
NULL      N/A              0             0
MD5       HMAC-MD5        16            16
SHA       HMAC-SHA1       20            20
SHA256    HMAC-SHA256     32            32

   Type
      Indicates whether this is a stream cipher or a block cipher
      running in CBC mode.

   Key Material
      The number of bytes from the key_block that are used for
      generating the write keys.

   IV Size
      The amount of data needed to be generated for the initialization
      vector.  Zero for stream ciphers; equal to the block size for
      block ciphers (this is equal to
      SecurityParameters.record_iv_length).

   Block Size
      The amount of data a block cipher enciphers in one chunk; a block
      cipher running in CBC mode can only encrypt an even multiple of
      its block size.
















Dierks & Rescorla           Standards Track                    [Page 84]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


Appendix D.  Implementation Notes

   The TLS protocol cannot prevent many common security mistakes.  This
   section provides several recommendations to assist implementors.

D.1.  Random Number Generation and Seeding

   TLS requires a cryptographically secure pseudorandom number generator
   (PRNG).  Care must be taken in designing and seeding PRNGs.  PRNGs
   based on secure hash operations, most notably SHA-1, are acceptable,
   but cannot provide more security than the size of the random number
   generator state.

   To estimate the amount of seed material being produced, add the
   number of bits of unpredictable information in each seed byte.  For
   example, keystroke timing values taken from a PC compatible's 18.2 Hz
   timer provide 1 or 2 secure bits each, even though the total size of
   the counter value is 16 bits or more.  Seeding a 128-bit PRNG would
   thus require approximately 100 such timer values.

   [RANDOM] provides guidance on the generation of random values.

D.2.  Certificates and Authentication

   Implementations are responsible for verifying the integrity of
   certificates and should generally support certificate revocation
   messages.  Certificates should always be verified to ensure proper
   signing by a trusted Certificate Authority (CA).  The selection and
   addition of trusted CAs should be done very carefully.  Users should
   be able to view information about the certificate and root CA.

D.3.  Cipher Suites

   TLS supports a range of key sizes and security levels, including some
   that provide no or minimal security.  A proper implementation will
   probably not support many cipher suites.  For instance, anonymous
   Diffie-Hellman is strongly discouraged because it cannot prevent man-
   in-the-middle attacks.  Applications should also enforce minimum and
   maximum key sizes.  For example, certificate chains containing 512-
   bit RSA keys or signatures are not appropriate for high-security
   applications.

D.4.  Implementation Pitfalls

   Implementation experience has shown that certain parts of earlier TLS
   specifications are not easy to understand, and have been a source of
   interoperability and security problems.  Many of these areas have




Dierks & Rescorla           Standards Track                    [Page 85]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   been clarified in this document, but this appendix contains a short
   list of the most important things that require special attention from
   implementors.

   TLS protocol issues:

   -  Do you correctly handle handshake messages that are fragmented to
      multiple TLS records (see Section 6.2.1)? Including corner cases
      like a ClientHello that is split to several small fragments? Do
      you fragment handshake messages that exceed the maximum fragment
      size? In particular, the certificate and certificate request
      handshake messages can be large enough to require fragmentation.

   -  Do you ignore the TLS record layer version number in all TLS
      records before ServerHello (see Appendix E.1)?

   -  Do you handle TLS extensions in ClientHello correctly, including
      omitting the extensions field completely?

   -  Do you support renegotiation, both client and server initiated?
      While renegotiation is an optional feature, supporting it is
      highly recommended.

   -  When the server has requested a client certificate, but no
      suitable certificate is available, do you correctly send an empty
      Certificate message, instead of omitting the whole message (see
      Section 7.4.6)?

   Cryptographic details:

   -  In the RSA-encrypted Premaster Secret, do you correctly send and
      verify the version number? When an error is encountered, do you
      continue the handshake to avoid the Bleichenbacher attack (see
      Section 7.4.7.1)?

   -  What countermeasures do you use to prevent timing attacks against
      RSA decryption and signing operations (see Section 7.4.7.1)?

   -  When verifying RSA signatures, do you accept both NULL and missing
      parameters (see Section 4.7)? Do you verify that the RSA padding
      doesn't have additional data after the hash value?  [FI06]

   -  When using Diffie-Hellman key exchange, do you correctly strip
      leading zero bytes from the negotiated key (see Section 8.1.2)?

   -  Does your TLS client check that the Diffie-Hellman parameters sent
      by the server are acceptable (see Section F.1.1.3)?




Dierks & Rescorla           Standards Track                    [Page 86]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   -  How do you generate unpredictable IVs for CBC mode ciphers (see
      Section 6.2.3.2)?

   -  Do you accept long CBC mode padding (up to 255 bytes; see Section
      6.2.3.2)?

   -  How do you address CBC mode timing attacks (Section 6.2.3.2)?

   -  Do you use a strong and, most importantly, properly seeded random
      number generator (see Appendix D.1) for generating the premaster
      secret (for RSA key exchange), Diffie-Hellman private values, the
      DSA "k" parameter, and other security-critical values?

Appendix E.  Backward Compatibility

E.1.  Compatibility with TLS 1.0/1.1 and SSL 3.0

   Since there are various versions of TLS (1.0, 1.1, 1.2, and any
   future versions) and SSL (2.0 and 3.0), means are needed to negotiate
   the specific protocol version to use.  The TLS protocol provides a
   built-in mechanism for version negotiation so as not to bother other
   protocol components with the complexities of version selection.

   TLS versions 1.0, 1.1, and 1.2, and SSL 3.0 are very similar, and use
   compatible ClientHello messages; thus, supporting all of them is
   relatively easy.  Similarly, servers can easily handle clients trying
   to use future versions of TLS as long as the ClientHello format
   remains compatible, and the client supports the highest protocol
   version available in the server.

   A TLS 1.2 client who wishes to negotiate with such older servers will
   send a normal TLS 1.2 ClientHello, containing { 3, 3 } (TLS 1.2) in
   ClientHello.client_version.  If the server does not support this
   version, it will respond with a ServerHello containing an older
   version number.  If the client agrees to use this version, the
   negotiation will proceed as appropriate for the negotiated protocol.

   If the version chosen by the server is not supported by the client
   (or not acceptable), the client MUST send a "protocol_version" alert
   message and close the connection.

   If a TLS server receives a ClientHello containing a version number
   greater than the highest version supported by the server, it MUST
   reply according to the highest version supported by the server.

   A TLS server can also receive a ClientHello containing a version
   number smaller than the highest supported version.  If the server
   wishes to negotiate with old clients, it will proceed as appropriate



Dierks & Rescorla           Standards Track                    [Page 87]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   for the highest version supported by the server that is not greater
   than ClientHello.client_version.  For example, if the server supports
   TLS 1.0, 1.1, and 1.2, and client_version is TLS 1.0, the server will
   proceed with a TLS 1.0 ServerHello.  If server supports (or is
   willing to use) only versions greater than client_version, it MUST
   send a "protocol_version" alert message and close the connection.

   Whenever a client already knows the highest protocol version known to
   a server (for example, when resuming a session), it SHOULD initiate
   the connection in that native protocol.

   Note: some server implementations are known to implement version
   negotiation incorrectly.  For example, there are buggy TLS 1.0
   servers that simply close the connection when the client offers a
   version newer than TLS 1.0.  Also, it is known that some servers will
   refuse the connection if any TLS extensions are included in
   ClientHello.  Interoperability with such buggy servers is a complex
   topic beyond the scope of this document, and may require multiple
   connection attempts by the client.

   Earlier versions of the TLS specification were not fully clear on
   what the record layer version number (TLSPlaintext.version) should
   contain when sending ClientHello (i.e., before it is known which
   version of the protocol will be employed).  Thus, TLS servers
   compliant with this specification MUST accept any value {03,XX} as
   the record layer version number for ClientHello.

   TLS clients that wish to negotiate with older servers MAY send any
   value {03,XX} as the record layer version number.  Typical values
   would be {03,00}, the lowest version number supported by the client,
   and the value of ClientHello.client_version.  No single value will
   guarantee interoperability with all old servers, but this is a
   complex topic beyond the scope of this document.

E.2.  Compatibility with SSL 2.0

   TLS 1.2 clients that wish to support SSL 2.0 servers MUST send
   version 2.0 CLIENT-HELLO messages defined in [SSL2].  The message
   MUST contain the same version number as would be used for ordinary
   ClientHello, and MUST encode the supported TLS cipher suites in the
   CIPHER-SPECS-DATA field as described below.

   Warning: The ability to send version 2.0 CLIENT-HELLO messages will
   be phased out with all due haste, since the newer ClientHello format
   provides better mechanisms for moving to newer versions and
   negotiating extensions.  TLS 1.2 clients SHOULD NOT support SSL 2.0.





Dierks & Rescorla           Standards Track                    [Page 88]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   However, even TLS servers that do not support SSL 2.0 MAY accept
   version 2.0 CLIENT-HELLO messages.  The message is presented below in
   sufficient detail for TLS server implementors; the true definition is
   still assumed to be [SSL2].

   For negotiation purposes, 2.0 CLIENT-HELLO is interpreted the same
   way as a ClientHello with a "null" compression method and no
   extensions.  Note that this message MUST be sent directly on the
   wire, not wrapped as a TLS record.  For the purposes of calculating
   Finished and CertificateVerify, the msg_length field is not
   considered to be a part of the handshake message.

      uint8 V2CipherSpec[3];
      struct {
          uint16 msg_length;
          uint8 msg_type;
          Version version;
          uint16 cipher_spec_length;
          uint16 session_id_length;
          uint16 challenge_length;
          V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
          opaque session_id[V2ClientHello.session_id_length];
          opaque challenge[V2ClientHello.challenge_length;
      } V2ClientHello;

   msg_length
      The highest bit MUST be 1; the remaining bits contain the length
      of the following data in bytes.

   msg_type
      This field, in conjunction with the version field, identifies a
      version 2 ClientHello message.  The value MUST be 1.

   version
      Equal to ClientHello.client_version.

   cipher_spec_length
      This field is the total length of the field cipher_specs.  It
      cannot be zero and MUST be a multiple of the V2CipherSpec length
      (3).

   session_id_length
      This field MUST have a value of zero for a client that claims to
      support TLS 1.2.







Dierks & Rescorla           Standards Track                    [Page 89]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   challenge_length
      The length in bytes of the client's challenge to the server to
      authenticate itself.  Historically, permissible values are between
      16 and 32 bytes inclusive.  When using the SSLv2 backward-
      compatible handshake the client SHOULD use a 32-byte challenge.

   cipher_specs
      This is a list of all CipherSpecs the client is willing and able
      to use.  In addition to the 2.0 cipher specs defined in [SSL2],
      this includes the TLS cipher suites normally sent in
      ClientHello.cipher_suites, with each cipher suite prefixed by a
      zero byte.  For example, the TLS cipher suite {0x00,0x0A} would be
      sent as {0x00,0x00,0x0A}.

   session_id
      This field MUST be empty.

   challenge
      Corresponds to ClientHello.random.  If the challenge length is
      less than 32, the TLS server will pad the data with leading (note:
      not trailing) zero bytes to make it 32 bytes long.

   Note: Requests to resume a TLS session MUST use a TLS client hello.

E.3.  Avoiding Man-in-the-Middle Version Rollback

   When TLS clients fall back to Version 2.0 compatibility mode, they
   MUST use special PKCS#1 block formatting.  This is done so that TLS
   servers will reject Version 2.0 sessions with TLS-capable clients.

   When a client negotiates SSL 2.0 but also supports TLS, it MUST set
   the right-hand (least-significant) 8 random bytes of the PKCS padding
   (not including the terminal null of the padding) for the RSA
   encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY
   to 0x03 (the other padding bytes are random).

   When a TLS-capable server negotiates SSL 2.0 it SHOULD, after
   decrypting the ENCRYPTED-KEY-DATA field, check that these 8 padding
   bytes are 0x03.  If they are not, the server SHOULD generate a random
   value for SECRET-KEY-DATA, and continue the handshake (which will
   eventually fail since the keys will not match).  Note that reporting
   the error situation to the client could make the server vulnerable to
   attacks described in [BLEI].








Dierks & Rescorla           Standards Track                    [Page 90]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


Appendix F.  Security Analysis

   The TLS protocol is designed to establish a secure connection between
   a client and a server communicating over an insecure channel.  This
   document makes several traditional assumptions, including that
   attackers have substantial computational resources and cannot obtain
   secret information from sources outside the protocol.  Attackers are
   assumed to have the ability to capture, modify, delete, replay, and
   otherwise tamper with messages sent over the communication channel.
   This appendix outlines how TLS has been designed to resist a variety
   of attacks.

F.1.  Handshake Protocol

   The handshake protocol is responsible for selecting a cipher spec and
   generating a master secret, which together comprise the primary
   cryptographic parameters associated with a secure session.  The
   handshake protocol can also optionally authenticate parties who have
   certificates signed by a trusted certificate authority.

F.1.1.  Authentication and Key Exchange

   TLS supports three authentication modes: authentication of both
   parties, server authentication with an unauthenticated client, and
   total anonymity.  Whenever the server is authenticated, the channel
   is secure against man-in-the-middle attacks, but completely anonymous
   sessions are inherently vulnerable to such attacks.  Anonymous
   servers cannot authenticate clients.  If the server is authenticated,
   its certificate message must provide a valid certificate chain
   leading to an acceptable certificate authority.  Similarly,
   authenticated clients must supply an acceptable certificate to the
   server.  Each party is responsible for verifying that the other's
   certificate is valid and has not expired or been revoked.

   The general goal of the key exchange process is to create a
   pre_master_secret known to the communicating parties and not to
   attackers.  The pre_master_secret will be used to generate the
   master_secret (see Section 8.1).  The master_secret is required to
   generate the Finished messages, encryption keys, and MAC keys (see
   Sections 7.4.9 and 6.3).  By sending a correct Finished message,
   parties thus prove that they know the correct pre_master_secret.

F.1.1.1.  Anonymous Key Exchange

   Completely anonymous sessions can be established using Diffie-Hellman
   for key exchange.  The server's public parameters are contained in
   the server key exchange message, and the client's are sent in the




Dierks & Rescorla           Standards Track                    [Page 91]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   client key exchange message.  Eavesdroppers who do not know the
   private values should not be able to find the Diffie-Hellman result
   (i.e., the pre_master_secret).

   Warning: Completely anonymous connections only provide protection
   against passive eavesdropping.  Unless an independent tamper-proof
   channel is used to verify that the Finished messages were not
   replaced by an attacker, server authentication is required in
   environments where active man-in-the-middle attacks are a concern.

F.1.1.2.  RSA Key Exchange and Authentication

   With RSA, key exchange and server authentication are combined.  The
   public key is contained in the server's certificate.  Note that
   compromise of the server's static RSA key results in a loss of
   confidentiality for all sessions protected under that static key.
   TLS users desiring Perfect Forward Secrecy should use DHE cipher
   suites.  The damage done by exposure of a private key can be limited
   by changing one's private key (and certificate) frequently.

   After verifying the server's certificate, the client encrypts a
   pre_master_secret with the server's public key.  By successfully
   decoding the pre_master_secret and producing a correct Finished
   message, the server demonstrates that it knows the private key
   corresponding to the server certificate.

   When RSA is used for key exchange, clients are authenticated using
   the certificate verify message (see Section 7.4.8).  The client signs
   a value derived from all preceding handshake messages.  These
   handshake messages include the server certificate, which binds the
   signature to the server, and ServerHello.random, which binds the
   signature to the current handshake process.

F.1.1.3.  Diffie-Hellman Key Exchange with Authentication

   When Diffie-Hellman key exchange is used, the server can either
   supply a certificate containing fixed Diffie-Hellman parameters or
   use the server key exchange message to send a set of temporary
   Diffie-Hellman parameters signed with a DSA or RSA certificate.
   Temporary parameters are hashed with the hello.random values before
   signing to ensure that attackers do not replay old parameters.  In
   either case, the client can verify the certificate or signature to
   ensure that the parameters belong to the server.

   If the client has a certificate containing fixed Diffie-Hellman
   parameters, its certificate contains the information required to
   complete the key exchange.  Note that in this case the client and
   server will generate the same Diffie-Hellman result (i.e.,



Dierks & Rescorla           Standards Track                    [Page 92]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   pre_master_secret) every time they communicate.  To prevent the
   pre_master_secret from staying in memory any longer than necessary,
   it should be converted into the master_secret as soon as possible.
   Client Diffie-Hellman parameters must be compatible with those
   supplied by the server for the key exchange to work.

   If the client has a standard DSA or RSA certificate or is
   unauthenticated, it sends a set of temporary parameters to the server
   in the client key exchange message, then optionally uses a
   certificate verify message to authenticate itself.

   If the same DH keypair is to be used for multiple handshakes, either
   because the client or server has a certificate containing a fixed DH
   keypair or because the server is reusing DH keys, care must be taken
   to prevent small subgroup attacks.  Implementations SHOULD follow the
   guidelines found in [SUBGROUP].

   Small subgroup attacks are most easily avoided by using one of the
   DHE cipher suites and generating a fresh DH private key (X) for each
   handshake.  If a suitable base (such as 2) is chosen, g^X mod p can
   be computed very quickly; therefore, the performance cost is
   minimized.  Additionally, using a fresh key for each handshake
   provides Perfect Forward Secrecy.  Implementations SHOULD generate a
   new X for each handshake when using DHE cipher suites.

   Because TLS allows the server to provide arbitrary DH groups, the
   client should verify that the DH group is of suitable size as defined
   by local policy.  The client SHOULD also verify that the DH public
   exponent appears to be of adequate size.  [KEYSIZ] provides a useful
   guide to the strength of various group sizes.  The server MAY choose
   to assist the client by providing a known group, such as those
   defined in [IKEALG] or [MODP].  These can be verified by simple
   comparison.

F.1.2.  Version Rollback Attacks

   Because TLS includes substantial improvements over SSL Version 2.0,
   attackers may try to make TLS-capable clients and servers fall back
   to Version 2.0.  This attack can occur if (and only if) two TLS-
   capable parties use an SSL 2.0 handshake.

   Although the solution using non-random PKCS #1 block type 2 message
   padding is inelegant, it provides a reasonably secure way for Version
   3.0 servers to detect the attack.  This solution is not secure
   against attackers who can brute-force the key and substitute a new
   ENCRYPTED-KEY-DATA message containing the same key (but with normal
   padding) before the application-specified wait threshold has expired.
   Altering the padding of the least-significant 8 bytes of the PKCS



Dierks & Rescorla           Standards Track                    [Page 93]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   padding does not impact security for the size of the signed hashes
   and RSA key lengths used in the protocol, since this is essentially
   equivalent to increasing the input block size by 8 bytes.

F.1.3.  Detecting Attacks Against the Handshake Protocol

   An attacker might try to influence the handshake exchange to make the
   parties select different encryption algorithms than they would
   normally choose.

   For this attack, an attacker must actively change one or more
   handshake messages.  If this occurs, the client and server will
   compute different values for the handshake message hashes.  As a
   result, the parties will not accept each others' Finished messages.
   Without the master_secret, the attacker cannot repair the Finished
   messages, so the attack will be discovered.

F.1.4.  Resuming Sessions

   When a connection is established by resuming a session, new
   ClientHello.random and ServerHello.random values are hashed with the
   session's master_secret.  Provided that the master_secret has not
   been compromised and that the secure hash operations used to produce
   the encryption keys and MAC keys are secure, the connection should be
   secure and effectively independent from previous connections.
   Attackers cannot use known encryption keys or MAC secrets to
   compromise the master_secret without breaking the secure hash
   operations.

   Sessions cannot be resumed unless both the client and server agree.
   If either party suspects that the session may have been compromised,
   or that certificates may have expired or been revoked, it should
   force a full handshake.  An upper limit of 24 hours is suggested for
   session ID lifetimes, since an attacker who obtains a master_secret
   may be able to impersonate the compromised party until the
   corresponding session ID is retired.  Applications that may be run in
   relatively insecure environments should not write session IDs to
   stable storage.

F.2.  Protecting Application Data

   The master_secret is hashed with the ClientHello.random and
   ServerHello.random to produce unique data encryption keys and MAC
   secrets for each connection.

   Outgoing data is protected with a MAC before transmission.  To
   prevent message replay or modification attacks, the MAC is computed
   from the MAC key, the sequence number, the message length, the



Dierks & Rescorla           Standards Track                    [Page 94]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   message contents, and two fixed character strings.  The message type
   field is necessary to ensure that messages intended for one TLS
   record layer client are not redirected to another.  The sequence
   number ensures that attempts to delete or reorder messages will be
   detected.  Since sequence numbers are 64 bits long, they should never
   overflow.  Messages from one party cannot be inserted into the
   other's output, since they use independent MAC keys.  Similarly, the
   server write and client write keys are independent, so stream cipher
   keys are used only once.

   If an attacker does break an encryption key, all messages encrypted
   with it can be read.  Similarly, compromise of a MAC key can make
   message-modification attacks possible.  Because MACs are also
   encrypted, message-alteration attacks generally require breaking the
   encryption algorithm as well as the MAC.

   Note: MAC keys may be larger than encryption keys, so messages can
   remain tamper resistant even if encryption keys are broken.

F.3.  Explicit IVs

   [CBCATT] describes a chosen plaintext attack on TLS that depends on
   knowing the IV for a record.  Previous versions of TLS [TLS1.0] used
   the CBC residue of the previous record as the IV and therefore
   enabled this attack.  This version uses an explicit IV in order to
   protect against this attack.

F.4.  Security of Composite Cipher Modes

   TLS secures transmitted application data via the use of symmetric
   encryption and authentication functions defined in the negotiated
   cipher suite.  The objective is to protect both the integrity and
   confidentiality of the transmitted data from malicious actions by
   active attackers in the network.  It turns out that the order in
   which encryption and authentication functions are applied to the data
   plays an important role for achieving this goal [ENCAUTH].

   The most robust method, called encrypt-then-authenticate, first
   applies encryption to the data and then applies a MAC to the
   ciphertext.  This method ensures that the integrity and
   confidentiality goals are obtained with ANY pair of encryption and
   MAC functions, provided that the former is secure against chosen
   plaintext attacks and that the MAC is secure against chosen-message
   attacks.  TLS uses another method, called authenticate-then-encrypt,
   in which first a MAC is computed on the plaintext and then the
   concatenation of plaintext and MAC is encrypted.  This method has
   been proven secure for CERTAIN combinations of encryption functions
   and MAC functions, but it is not guaranteed to be secure in general.



Dierks & Rescorla           Standards Track                    [Page 95]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   In particular, it has been shown that there exist perfectly secure
   encryption functions (secure even in the information-theoretic sense)
   that combined with any secure MAC function, fail to provide the
   confidentiality goal against an active attack.  Therefore, new cipher
   suites and operation modes adopted into TLS need to be analyzed under
   the authenticate-then-encrypt method to verify that they achieve the
   stated integrity and confidentiality goals.

   Currently, the security of the authenticate-then-encrypt method has
   been proven for some important cases.  One is the case of stream
   ciphers in which a computationally unpredictable pad of the length of
   the message, plus the length of the MAC tag, is produced using a
   pseudorandom generator and this pad is exclusive-ORed with the
   concatenation of plaintext and MAC tag.  The other is the case of CBC
   mode using a secure block cipher.  In this case, security can be
   shown if one applies one CBC encryption pass to the concatenation of
   plaintext and MAC and uses a new, independent, and unpredictable IV
   for each new pair of plaintext and MAC.  In versions of TLS prior to
   1.1, CBC mode was used properly EXCEPT that it used a predictable IV
   in the form of the last block of the previous ciphertext.  This made
   TLS open to chosen plaintext attacks.  This version of the protocol
   is immune to those attacks.  For exact details in the encryption
   modes proven secure, see [ENCAUTH].

F.5.  Denial of Service

   TLS is susceptible to a number of denial-of-service (DoS) attacks.
   In particular, an attacker who initiates a large number of TCP
   connections can cause a server to consume large amounts of CPU for
   doing RSA decryption.  However, because TLS is generally used over
   TCP, it is difficult for the attacker to hide his point of origin if
   proper TCP SYN randomization is used [SEQNUM] by the TCP stack.

   Because TLS runs over TCP, it is also susceptible to a number of DoS
   attacks on individual connections.  In particular, attackers can
   forge RSTs, thereby terminating connections, or forge partial TLS
   records, thereby causing the connection to stall.  These attacks
   cannot in general be defended against by a TCP-using protocol.
   Implementors or users who are concerned with this class of attack
   should use IPsec AH [AH] or ESP [ESP].

F.6.  Final Notes

   For TLS to be able to provide a secure connection, both the client
   and server systems, keys, and applications must be secure.  In
   addition, the implementation must be free of security errors.





Dierks & Rescorla           Standards Track                    [Page 96]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   The system is only as strong as the weakest key exchange and
   authentication algorithm supported, and only trustworthy
   cryptographic functions should be used.  Short public keys and
   anonymous servers should be used with great caution.  Implementations
   and users must be careful when deciding which certificates and
   certificate authorities are acceptable; a dishonest certificate
   authority can do tremendous damage.

Normative References

   [AES]      National Institute of Standards and Technology,
              "Specification for the Advanced Encryption Standard (AES)"
              FIPS 197.  November 26, 2001.

   [3DES]     National Institute of Standards and Technology,
              "Recommendation for the Triple Data Encryption Algorithm
              (TDEA) Block Cipher", NIST Special Publication 800-67, May
              2004.

   [DSS]      NIST FIPS PUB 186-2, "Digital Signature Standard",
              National Institute of Standards and Technology, U.S.
              Department of Commerce, 2000.

   [HMAC]     Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104, February
              1997.

   [MD5]      Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321,
              April 1992.

   [PKCS1]    Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications
              Version 2.1", RFC 3447, February 2003.

   [PKIX]     Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
              X.509 Public Key Infrastructure Certificate and
              Certificate Revocation List (CRL) Profile", RFC 3280,
              April 2002.

   [SCH]      B. Schneier. "Applied Cryptography: Protocols, Algorithms,
              and Source Code in C, 2nd ed.", Published by John Wiley &
              Sons, Inc. 1996.

   [SHS]      NIST FIPS PUB 180-2, "Secure Hash Standard", National
              Institute of Standards and Technology, U.S. Department of
              Commerce, August 2002.





Dierks & Rescorla           Standards Track                    [Page 97]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   [REQ]      Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2434]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 2434,
              October 1998.

   [X680]     ITU-T Recommendation X.680 (2002) | ISO/IEC 8824-1:2002,
              Information technology - Abstract Syntax Notation One
              (ASN.1): Specification of basic notation.

   [X690]     ITU-T Recommendation X.690 (2002) | ISO/IEC 8825-1:2002,
              Information technology - ASN.1 encoding Rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER).

Informative References

   [AEAD]     McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", RFC 5116, January 2008.

   [AH]       Kent, S., "IP Authentication Header", RFC 4302, December
              2005.

   [BLEI]     Bleichenbacher D., "Chosen Ciphertext Attacks against
              Protocols Based on RSA Encryption Standard PKCS #1" in
              Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462,
              pages:  1-12, 1998.

   [CBCATT]   Moeller, B., "Security of CBC Ciphersuites in SSL/TLS:
              Problems and Countermeasures",
              http://www.openssl.org/~bodo/tls-cbc.txt.

   [CBCTIME]  Canvel, B., Hiltgen, A., Vaudenay, S., and M. Vuagnoux,
              "Password Interception in a SSL/TLS Channel", Advances in
              Cryptology -- CRYPTO 2003, LNCS vol. 2729, 2003.

   [CCM]      "NIST Special Publication 800-38C: The CCM Mode for
              Authentication and Confidentiality",
              http://csrc.nist.gov/publications/nistpubs/800-38C/
              SP800-38C.pdf

   [DES]      National Institute of Standards and Technology, "Data
              Encryption Standard (DES)", FIPS PUB 46-3, October 1999.






Dierks & Rescorla           Standards Track                    [Page 98]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   [DSS-3]    NIST FIPS PUB 186-3 Draft, "Digital Signature Standard",
              National Institute of Standards and Technology, U.S.
              Department of Commerce, 2006.

   [ECDSA]    American National Standards Institute, "Public Key
              Cryptography for the Financial Services Industry: The
              Elliptic Curve Digital Signature Algorithm (ECDSA)", ANS
              X9.62-2005, November 2005.

   [ENCAUTH]  Krawczyk, H., "The Order of Encryption and Authentication
              for Protecting Communications (Or: How Secure is SSL?)",
              Crypto 2001.

   [ESP]      Kent, S., "IP Encapsulating Security Payload (ESP)", RFC
              4303, December 2005.

   [FI06]     Hal Finney, "Bleichenbacher's RSA signature forgery based
              on implementation error", ietf-openpgp@imc.org mailing
              list, 27 August 2006, http://www.imc.org/ietf-openpgp/
              mail-archive/msg14307.html.

   [GCM]      Dworkin, M., NIST Special Publication 800-38D,
              "Recommendation for Block Cipher Modes of Operation:
              Galois/Counter Mode (GCM) and GMAC", November 2007.

   [IKEALG]   Schiller, J., "Cryptographic Algorithms for Use in the
              Internet Key Exchange Version 2 (IKEv2)", RFC 4307,
              December 2005.

   [KEYSIZ]   Orman, H. and P. Hoffman, "Determining Strengths For
              Public Keys Used For Exchanging Symmetric Keys", BCP 86,
              RFC 3766, April 2004.

   [KPR03]    Klima, V., Pokorny, O., Rosa, T., "Attacking RSA-based
              Sessions in SSL/TLS", http://eprint.iacr.org/2003/052/,
              March 2003.

   [MODP]     Kivinen, T. and M. Kojo, "More Modular Exponential (MODP)
              Diffie-Hellman groups for Internet Key Exchange (IKE)",
              RFC 3526, May 2003.

   [PKCS6]    RSA Laboratories, "PKCS #6: RSA Extended Certificate
              Syntax Standard", version 1.5, November 1993.

   [PKCS7]    RSA Laboratories, "PKCS #7: RSA Cryptographic Message
              Syntax Standard", version 1.5, November 1993.





Dierks & Rescorla           Standards Track                    [Page 99]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   [RANDOM]   Eastlake, D., 3rd, Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              June 2005.

   [RFC3749]  Hollenbeck, S., "Transport Layer Security Protocol
              Compression Methods", RFC 3749, May 2004.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, April 2006.

   [RSA]      R. Rivest, A. Shamir, and L. M. Adleman, "A Method for
              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM, v. 21, n. 2,
              Feb 1978, pp. 120-126.

   [SEQNUM]   Bellovin, S., "Defending Against Sequence Number Attacks",
              RFC 1948, May 1996.

   [SSL2]     Hickman, Kipp, "The SSL Protocol", Netscape Communications
              Corp., Feb 9, 1995.

   [SSL3]     A. Freier, P. Karlton, and P. Kocher, "The SSL 3.0
              Protocol", Netscape Communications Corp., Nov 18, 1996.

   [SUBGROUP] Zuccherato, R., "Methods for Avoiding the "Small-Subgroup"
              Attacks on the Diffie-Hellman Key Agreement Method for
              S/MIME", RFC 2785, March 2000.

   [TCP]      Postel, J., "Transmission Control Protocol", STD 7, RFC
              793, September 1981.

   [TIMING]   Boneh, D., Brumley, D., "Remote timing attacks are
              practical", USENIX Security Symposium 2003.

   [TLSAES]   Chown, P., "Advanced Encryption Standard (AES)
              Ciphersuites for Transport Layer Security (TLS)", RFC
              3268, June 2002.

   [TLSECC]   Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", RFC 4492, May 2006.

   [TLSEXT]   Eastlake, D., 3rd, "Transport Layer Security (TLS)
              Extensions:  Extension Definitions", Work in Progress,
              February 2008.





Dierks & Rescorla           Standards Track                   [Page 100]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   [TLSPGP]   Mavrogiannopoulos, N., "Using OpenPGP Keys for Transport
              Layer Security (TLS) Authentication", RFC 5081, November
              2007.

   [TLSPSK]   Eronen, P., Ed., and H. Tschofenig, Ed., "Pre-Shared Key
              Ciphersuites for Transport Layer Security (TLS)", RFC
              4279, December 2005.

   [TLS1.0]   Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              RFC 2246, January 1999.

   [TLS1.1]   Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346, April 2006.

   [X501]     ITU-T Recommendation X.501: Information Technology - Open
              Systems Interconnection - The Directory: Models, 1993.

   [XDR]      Eisler, M., Ed., "XDR: External Data Representation
              Standard", STD 67, RFC 4506, May 2006.

Working Group Information

   The discussion list for the IETF TLS working group is located at the
   e-mail address <tls@ietf.org>. Information on the group and
   information on how to subscribe to the list is at
   <https://www1.ietf.org/mailman/listinfo/tls>

   Archives of the list can be found at:
   <http://www.ietf.org/mail-archive/web/tls/current/index.html>

Contributors

   Christopher Allen (co-editor of TLS 1.0)
   Alacrity Ventures
   ChristopherA@AlacrityManagement.com

   Martin Abadi
   University of California, Santa Cruz
   abadi@cs.ucsc.edu

   Steven M. Bellovin
   Columbia University
   smb@cs.columbia.edu

   Simon Blake-Wilson
   BCI
   sblakewilson@bcisse.com




Dierks & Rescorla           Standards Track                   [Page 101]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Ran Canetti
   IBM
   canetti@watson.ibm.com

   Pete Chown
   Skygate Technology Ltd
   pc@skygate.co.uk

   Taher Elgamal
   taher@securify.com
   Securify

   Pasi Eronen
   pasi.eronen@nokia.com
   Nokia

   Anil Gangolli
   anil@busybuddha.org

   Kipp Hickman

   Alfred Hoenes

   David Hopwood
   Independent Consultant
   david.hopwood@blueyonder.co.uk

   Phil Karlton (co-author of SSLv3)

   Paul Kocher (co-author of SSLv3)
   Cryptography Research
   paul@cryptography.com

   Hugo Krawczyk
   IBM
   hugo@ee.technion.ac.il

   Jan Mikkelsen
   Transactionware
   janm@transactionware.com

   Magnus Nystrom
   RSA Security
   magnus@rsasecurity.com

   Robert Relyea
   Netscape Communications
   relyea@netscape.com



Dierks & Rescorla           Standards Track                   [Page 102]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


   Jim Roskind
   Netscape Communications
   jar@netscape.com

   Michael Sabin

   Dan Simon
   Microsoft, Inc.
   dansimon@microsoft.com

   Tom Weinstein

   Tim Wright
   Vodafone
   timothy.wright@vodafone.com

Editors' Addresses

   Tim Dierks
   Independent
   EMail: tim@dierks.org

   Eric Rescorla
   RTFM, Inc.
   EMail: ekr@rtfm.com


























Dierks & Rescorla           Standards Track                   [Page 103]
   __________________________________________________________________


RFC 5246                          TLS                        August 2008


Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












Dierks & Rescorla           Standards Track                   [Page 104]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-salowey-t...] [Tracker] [Diff1] [Diff2] [IPR]
   [Errata]
   Obsoleted by: 8446 PROPOSED STANDARD
   Updated by: 8447 Errata Exist
Network Working Group                                         J. Salowey
Request for Comments: 5077                                       H. Zhou
Obsoletes: 4507                                            Cisco Systems
Category: Standards Track                                      P. Eronen
                                                                   Nokia
                                                           H. Tschofenig
                                                  Nokia Siemens Networks
                                                            January 2008


       Transport Layer Security (TLS) Session Resumption without
                           Server-Side State

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   This document describes a mechanism that enables the Transport Layer
   Security (TLS) server to resume sessions and avoid keeping per-client
   session state.  The TLS server encapsulates the session state into a
   ticket and forwards it to the client.  The client can subsequently
   resume a session using the obtained ticket.  This document obsoletes
   RFC 4507.






















Salowey, et al.             Standards Track                     [Page 1]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  3
   3.  Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . .  3
     3.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . .  4
     3.2.  SessionTicket TLS Extension  . . . . . . . . . . . . . . .  7
     3.3.  NewSessionTicket Handshake Message . . . . . . . . . . . .  8
     3.4.  Interaction with TLS Session ID  . . . . . . . . . . . . .  9
   4.  Recommended Ticket Construction  . . . . . . . . . . . . . . . 10
   5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 12
     5.1.  Invalidating Sessions  . . . . . . . . . . . . . . . . . . 12
     5.2.  Stolen Tickets . . . . . . . . . . . . . . . . . . . . . . 12
     5.3.  Forged Tickets . . . . . . . . . . . . . . . . . . . . . . 12
     5.4.  Denial of Service Attacks  . . . . . . . . . . . . . . . . 12
     5.5.  Ticket Protection Key Management . . . . . . . . . . . . . 13
     5.6.  Ticket Lifetime  . . . . . . . . . . . . . . . . . . . . . 13
     5.7.  Alternate Ticket Formats and Distribution Schemes  . . . . 13
     5.8.  Identity Privacy, Anonymity, and Unlinkability . . . . . . 14
   6.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 14
   7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 15
   8.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 15
     8.1.  Normative References . . . . . . . . . . . . . . . . . . . 15
     8.2.  Informative References . . . . . . . . . . . . . . . . . . 15
   Appendix A.  Discussion of Changes to RFC 4507 . . . . . . . . . . 17


























Salowey, et al.             Standards Track                     [Page 2]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


1.  Introduction

   This document defines a way to resume a Transport Layer Security
   (TLS) session without requiring session-specific state at the TLS
   server.  This mechanism may be used with any TLS ciphersuite.  This
   document applies to both TLS 1.0 defined in [RFC2246], and TLS 1.1
   defined in [RFC4346].  The mechanism makes use of TLS extensions
   defined in [RFC4366] and defines a new TLS message type.

   This mechanism is useful in the following situations:

   1.  servers that handle a large number of transactions from different
       users

   2.  servers that desire to cache sessions for a long time

   3.  ability to load balance requests across servers

   4.  embedded servers with little memory

   This document obsoletes RFC 4507 [RFC4507] to correct an error in the
   encoding that caused the specification to differ from deployed
   implementations.  At the time of this writing, there are no known
   implementations that follow the encoding specified in RFC 4507.  This
   update to RFC 4507 aligns the document with currently deployed
   implementations.  More details of the change are given in Appendix A.

2.  Terminology

   Within this document, the term 'ticket' refers to a cryptographically
   protected data structure that is created and consumed by the server
   to rebuild session-specific state.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

3.  Protocol

   This specification describes a mechanism to distribute encrypted
   session-state information to the client in the form of a ticket and a
   mechanism to present the ticket back to the server.  The ticket is
   created by a TLS server and sent to a TLS client.  The TLS client
   presents the ticket to the TLS server to resume a session.
   Implementations of this specification are expected to support both
   mechanisms.  Other specifications can take advantage of the session
   tickets, perhaps specifying alternative means for distribution or
   selection.  For example, a separate specification may describe an



Salowey, et al.             Standards Track                     [Page 3]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   alternate way to distribute a ticket and use the TLS extension in
   this document to resume the session.  This behavior is beyond the
   scope of the document and would need to be described in a separate
   specification.

3.1.  Overview

   The client indicates that it supports this mechanism by including a
   SessionTicket TLS extension in the ClientHello message.  The
   extension will be empty if the client does not already possess a
   ticket for the server.  The server sends an empty SessionTicket
   extension to indicate that it will send a new session ticket using
   the NewSessionTicket handshake message.  The extension is described
   in Section 3.2.

   If the server wants to use this mechanism, it stores its session
   state (such as ciphersuite and master secret) to a ticket that is
   encrypted and integrity-protected by a key known only to the server.
   The ticket is distributed to the client using the NewSessionTicket
   TLS handshake message described in Section 3.3.  This message is sent
   during the TLS handshake before the ChangeCipherSpec message, after
   the server has successfully verified the client's Finished message.

         Client                                               Server

         ClientHello
        (empty SessionTicket extension)-------->
                                                         ServerHello
                                     (empty SessionTicket extension)
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                      <--------      ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         [ChangeCipherSpec]
         Finished                     -------->
                                                    NewSessionTicket
                                                  [ChangeCipherSpec]
                                      <--------             Finished
         Application Data             <------->     Application Data

   Figure 1: Message Flow for Full Handshake Issuing New Session Ticket







Salowey, et al.             Standards Track                     [Page 4]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   The client caches this ticket along with the master secret and other
   parameters associated with the current session.  When the client
   wishes to resume the session, it includes the ticket in the
   SessionTicket extension within the ClientHello message.  Appendix A
   provides a detailed description of the encoding of the extension and
   changes from RFC 4507.  The server then decrypts the received ticket,
   verifies the ticket's validity, retrieves the session state from the
   contents of the ticket, and uses this state to resume the session.
   The interaction with the TLS Session ID is described in Section 3.4.
   If the server successfully verifies the client's ticket, then it may
   renew the ticket by including a NewSessionTicket handshake message
   after the ServerHello.

         Client                                                Server
         ClientHello
         (SessionTicket extension)      -------->
                                                          ServerHello
                                      (empty SessionTicket extension)
                                                     NewSessionTicket
                                                   [ChangeCipherSpec]
                                       <--------             Finished
         [ChangeCipherSpec]
         Finished                      -------->
         Application Data              <------->     Application Data

    Figure 2: Message Flow for Abbreviated Handshake Using New Session
                                  Ticket

   A recommended ticket format is given in Section 4.

   If the server cannot or does not want to honor the ticket, then it
   can initiate a full handshake with the client.

   In the case that the server does not wish to issue a new ticket at
   this time, it just completes the handshake without including a
   SessionTicket extension or NewSessionTicket handshake message.  This
   is shown below (this flow is identical to Figure 1 in RFC 4346,
   except for the SessionTicket extension in the first message):













Salowey, et al.             Standards Track                     [Page 5]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


         Client                                               Server

         ClientHello
         (SessionTicket extension)    -------->
                                                         ServerHello
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                      <--------      ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         [ChangeCipherSpec]
         Finished                     -------->
                                                  [ChangeCipherSpec]
                                      <--------             Finished
         Application Data             <------->     Application Data

    Figure 3: Message Flow for Server Completing Full Handshake Without
                        Issuing New Session Ticket

   It is also permissible to have an exchange similar to Figure 3 using
   the abbreviated handshake defined in Figure 2 of RFC 4346, where the
   client uses the SessionTicket extension to resume the session, but
   the server does not wish to issue a new ticket, and therefore does
   not send a SessionTicket extension.

   If the server rejects the ticket, it may still wish to issue a new
   ticket after performing the full handshake as shown below (this flow
   is identical to Figure 1, except the SessionTicket extension in the
   ClientHello is not empty):




















Salowey, et al.             Standards Track                     [Page 6]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


         Client                                               Server

         ClientHello
         (SessionTicket extension) -------->
                                                         ServerHello
                                     (empty SessionTicket extension)
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                  <--------          ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         [ChangeCipherSpec]
         Finished                 -------->
                                                    NewSessionTicket
                                                  [ChangeCipherSpec]
                                  <--------                 Finished
         Application Data         <------->         Application Data

    Figure 4: Message Flow for Server Rejecting Ticket, Performing Full
                 Handshake, and Issuing New Session Ticket

3.2.  SessionTicket TLS Extension

   The SessionTicket TLS extension is based on [RFC4366].  The format of
   the ticket is an opaque structure used to carry session-specific
   state information.  This extension may be sent in the ClientHello and
   ServerHello.

   If the client possesses a ticket that it wants to use to resume a
   session, then it includes the ticket in the SessionTicket extension
   in the ClientHello.  If the client does not have a ticket and is
   prepared to receive one in the NewSessionTicket handshake message,
   then it MUST include a zero-length ticket in the SessionTicket
   extension.  If the client is not prepared to receive a ticket in the
   NewSessionTicket handshake message, then it MUST NOT include a
   SessionTicket extension unless it is sending a non-empty ticket it
   received through some other means from the server.

   The server uses a zero-length SessionTicket extension to indicate to
   the client that it will send a new session ticket using the
   NewSessionTicket handshake message described in Section 3.3.  The
   server MUST send this extension in the ServerHello if it wishes to
   issue a new ticket to the client using the NewSessionTicket handshake
   message.  The server MUST NOT send this extension if it does not
   receive one in the ClientHello.




Salowey, et al.             Standards Track                     [Page 7]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   If the server fails to verify the ticket, then it falls back to
   performing a full handshake.  If the ticket is accepted by the server
   but the handshake fails, the client SHOULD delete the ticket.

   The SessionTicket extension has been assigned the number 35.  The
   extension_data field of SessionTicket extension contains the ticket.

3.3.  NewSessionTicket Handshake Message

   This message is sent by the server during the TLS handshake before
   the ChangeCipherSpec message.  This message MUST be sent if the
   server included a SessionTicket extension in the ServerHello.  This
   message MUST NOT be sent if the server did not include a
   SessionTicket extension in the ServerHello.  This message is included
   in the hash used to create and verify the Finished message.  In the
   case of a full handshake, the server MUST verify the client's
   Finished message before sending the ticket.  The client MUST NOT
   treat the ticket as valid until it has verified the server's Finished
   message.  If the server determines that it does not want to include a
   ticket after it has included the SessionTicket extension in the
   ServerHello, then it sends a zero-length ticket in the
   NewSessionTicket handshake message.

   If the server successfully verifies the client's ticket, then it MAY
   renew the ticket by including a NewSessionTicket handshake message
   after the ServerHello in the abbreviated handshake.  The client
   should start using the new ticket as soon as possible after it
   verifies the server's Finished message for new connections.  Note
   that since the updated ticket is issued before the handshake
   completes, it is possible that the client may not put the new ticket
   into use before it initiates new connections.  The server MUST NOT
   assume that the client actually received the updated ticket until it
   successfully verifies the client's Finished message.

   The NewSessionTicket handshake message has been assigned the number 4
   and its definition is given at the end of this section.  The
   ticket_lifetime_hint field contains a hint from the server about how
   long the ticket should be stored.  The value indicates the lifetime
   in seconds as a 32-bit unsigned integer in network byte order
   relative to when the ticket is received.  A value of zero is reserved
   to indicate that the lifetime of the ticket is unspecified.  A client
   SHOULD delete the ticket and associated state when the time expires.
   It MAY delete the ticket earlier based on local policy.  A server MAY
   treat a ticket as valid for a shorter or longer period of time than
   what is stated in the ticket_lifetime_hint.






Salowey, et al.             Standards Track                     [Page 8]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


      struct {
          HandshakeType msg_type;
          uint24 length;
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
              case session_ticket:      NewSessionTicket; /* NEW */
          } body;
      } Handshake;


      struct {
          uint32 ticket_lifetime_hint;
          opaque ticket<0..2^16-1>;
      } NewSessionTicket;

3.4.  Interaction with TLS Session ID

   If a server is planning on issuing a session ticket to a client that
   does not present one, it SHOULD include an empty Session ID in the
   ServerHello.  If the server rejects the ticket and falls back to the
   full handshake then it may include a non-empty Session ID to indicate
   its support for stateful session resumption.  If the client receives
   a session ticket from the server, then it discards any Session ID
   that was sent in the ServerHello.

   When presenting a ticket, the client MAY generate and include a
   Session ID in the TLS ClientHello.  If the server accepts the ticket
   and the Session ID is not empty, then it MUST respond with the same
   Session ID present in the ClientHello.  This allows the client to
   easily differentiate when the server is resuming a session from when
   it is falling back to a full handshake.  Since the client generates a
   Session ID, the server MUST NOT rely upon the Session ID having a
   particular value when validating the ticket.  If a ticket is
   presented by the client, the server MUST NOT attempt to use the
   Session ID in the ClientHello for stateful session resumption.
   Alternatively, the client MAY include an empty Session ID in the
   ClientHello.  In this case, the client ignores the Session ID sent in
   the ServerHello and determines if the server is resuming a session by
   the subsequent handshake messages.



Salowey, et al.             Standards Track                     [Page 9]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


4.  Recommended Ticket Construction

   This section describes a recommended format and protection for the
   ticket.  Note that the ticket is opaque to the client, so the
   structure is not subject to interoperability concerns, and
   implementations may diverge from this format.  If implementations do
   diverge from this format, they must take security concerns seriously.
   Clients MUST NOT examine the ticket under the assumption that it
   complies with this document.

   The server uses two different keys: one 128-bit key for Advanced
   Encryption Standard (AES) [AES] in Cipher Block Chaining (CBC) mode
   [CBC] encryption and one 256-bit key for HMAC-SHA-256 [RFC4634].

   The ticket is structured as follows:

      struct {
          opaque key_name[16];
          opaque iv[16];
          opaque encrypted_state<0..2^16-1>;
          opaque mac[32];
      } ticket;

   Here, key_name serves to identify a particular set of keys used to
   protect the ticket.  It enables the server to easily recognize
   tickets it has issued.  The key_name should be randomly generated to
   avoid collisions between servers.  One possibility is to generate new
   random keys and key_name every time the server is started.

   The actual state information in encrypted_state is encrypted using
   128-bit AES in CBC mode with the given IV.  The Message
   Authentication Code (MAC) is calculated using HMAC-SHA-256 over
   key_name (16 octets) and IV (16 octets), followed by the length of
   the encrypted_state field (2 octets) and its contents (variable
   length).
















Salowey, et al.             Standards Track                    [Page 10]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


      struct {
          ProtocolVersion protocol_version;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          opaque master_secret[48];
          ClientIdentity client_identity;
          uint32 timestamp;
      } StatePlaintext;

      enum {
         anonymous(0),
         certificate_based(1),
         psk(2)
     } ClientAuthenticationType;

      struct {
          ClientAuthenticationType client_authentication_type;
          select (ClientAuthenticationType) {
              case anonymous: struct {};
              case certificate_based:
                  ASN.1Cert certificate_list<0..2^24-1>;
              case psk:
                  opaque psk_identity<0..2^16-1>;   /* from [RFC4279] */
          };
       } ClientIdentity;

   The structure StatePlaintext stores the TLS session state including
   the master_secret.  The timestamp within this structure allows the
   TLS server to expire tickets.  To cover the authentication and key
   exchange protocols provided by TLS, the ClientIdentity structure
   contains the authentication type of the client used in the initial
   exchange (see ClientAuthenticationType).  To offer the TLS server
   with the same capabilities for authentication and authorization, a
   certificate list is included in case of public-key-based
   authentication.  The TLS server is therefore able to inspect a number
   of different attributes within these certificates.  A specific
   implementation might choose to store a subset of this information or
   additional information.  Other authentication mechanisms, such as
   Kerberos [RFC2712], would require different client identity data.
   Other TLS extensions may require the inclusion of additional data in
   the StatePlaintext structure.










Salowey, et al.             Standards Track                    [Page 11]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


5.  Security Considerations

   This section addresses security issues related to the usage of a
   ticket.  Tickets must be authenticated and encrypted to prevent
   modification or eavesdropping by an attacker.  Several attacks
   described below will be possible if this is not carefully done.

   Implementations should take care to ensure that the processing of
   tickets does not increase the chance of denial of service as
   described below.

5.1.  Invalidating Sessions

   The TLS specification requires that TLS sessions be invalidated when
   errors occur.  [CSSC] discusses the security implications of this in
   detail.  In the analysis within this paper, failure to invalidate
   sessions does not pose a security risk.  This is because the TLS
   handshake uses a non-reversible function to derive keys for a session
   so information about one session does not provide an advantage to
   attack the master secret or a different session.  If a session
   invalidation scheme is used, the implementation should verify the
   integrity of the ticket before using the contents to invalidate a
   session to ensure that an attacker cannot invalidate a chosen
   session.

5.2.  Stolen Tickets

   An eavesdropper or man-in-the-middle may obtain the ticket and
   attempt to use it to establish a session with the server; however,
   since the ticket is encrypted and the attacker does not know the
   secret key, a stolen ticket does not help an attacker resume a
   session.  A TLS server MUST use strong encryption and integrity
   protection for the ticket to prevent an attacker from using a brute
   force mechanism to obtain the ticket's contents.

5.3.  Forged Tickets

   A malicious user could forge or alter a ticket in order to resume a
   session, to extend its lifetime, to impersonate another user, or to
   gain additional privileges.  This attack is not possible if the
   ticket is protected using a strong integrity protection algorithm
   such as a keyed HMAC-SHA-256.

5.4.  Denial of Service Attacks

   The key_name field defined in the recommended ticket format helps the
   server efficiently reject tickets that it did not issue.  However, an
   adversary could store or generate a large number of tickets to send



Salowey, et al.             Standards Track                    [Page 12]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   to the TLS server for verification.  To minimize the possibility of a
   denial of service, the verification of the ticket should be
   lightweight (e.g., using efficient symmetric key cryptographic
   algorithms).

5.5.  Ticket Protection Key Management

   A full description of the management of the keys used to protect the
   ticket is beyond the scope of this document.  A list of RECOMMENDED
   practices is given below.

   o  The keys should be generated securely following the randomness
      recommendations in [RFC4086].

   o  The keys and cryptographic protection algorithms should be at
      least 128 bits in strength.  Some ciphersuites and applications
      may require cryptographic protection greater than 128 bits in
      strength.

   o  The keys should not be used for any purpose other than generating
      and verifying tickets.

   o  The keys should be changed regularly.

   o  The keys should be changed if the ticket format or cryptographic
      protection algorithms change.

5.6.  Ticket Lifetime

   The TLS server controls the lifetime of the ticket.  Servers
   determine the acceptable lifetime based on the operational and
   security requirements of the environments in which they are deployed.
   The ticket lifetime may be longer than the 24-hour lifetime
   recommended in [RFC4346].  TLS clients may be given a hint of the
   lifetime of the ticket.  Since the lifetime of a ticket may be
   unspecified, a client has its own local policy that determines when
   it discards tickets.

5.7.  Alternate Ticket Formats and Distribution Schemes

   If the ticket format or distribution scheme defined in this document
   is not used, then great care must be taken in analyzing the security
   of the solution.  In particular, if confidential information, such as
   a secret key, is transferred to the client, it MUST be done using
   secure communication so as to prevent attackers from obtaining or
   modifying the key.  Also, the ticket MUST have its integrity and
   confidentiality protected with strong cryptographic techniques to
   prevent a breach in the security of the system.



Salowey, et al.             Standards Track                    [Page 13]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


5.8.  Identity Privacy, Anonymity, and Unlinkability

   This document mandates that the content of the ticket is
   confidentiality protected in order to avoid leakage of its content,
   such as user-relevant information.  As such, it prevents disclosure
   of potentially sensitive information carried within the ticket.

   The initial handshake exchange, which was used to obtain the ticket,
   might not provide identity confidentiality of the client based on the
   properties of TLS.  Another relevant security threat is the ability
   for an on-path adversary to observe multiple TLS handshakes where the
   same ticket is used, therefore concluding they belong to the same
   communication endpoints.  Application designers that use the ticket
   mechanism described in this document should consider that
   unlinkability [ANON] is not necessarily provided.

   While a full discussion of these topics is beyond the scope of this
   document, it should be noted that it is possible to issue a ticket
   using a TLS renegotiation handshake that occurs after a secure tunnel
   has been established by a previous handshake.  This may help address
   some privacy and unlinkability issues in some environments.

6.  Acknowledgements

   The authors would like to thank the following people for their help
   with preparing and reviewing this document: Eric Rescorla, Mohamad
   Badra, Tim Dierks, Nelson Bolyard, Nancy Cam-Winget, David McGrew,
   Rob Dugal, Russ Housley, Amir Herzberg, Bernard Aboba, and members of
   the TLS working group.

   [CSSC] describes a solution that is very similar to the one described
   in this document and gives a detailed analysis of the security
   considerations involved.  [RFC2712] describes a mechanism for using
   Kerberos [RFC4120] in TLS ciphersuites, which helped inspire the use
   of tickets to avoid server state.  [RFC4851] makes use of a similar
   mechanism to avoid maintaining server state for the cryptographic
   tunnel.  [SC97] also investigates the concept of stateless sessions.

   The authors would also like to thank Jan Nordqvist, who found the
   encoding error in RFC 4507, corrected by this document.  In addition
   Nagendra Modadugu, Wan-Teh Chang, and Michael D'Errico provided
   useful feedback during the review of this document.









Salowey, et al.             Standards Track                    [Page 14]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


7.  IANA Considerations

   IANA has assigned a TLS extension number of 35 to the SessionTicket
   TLS extension from the TLS registry of ExtensionType values defined
   in [RFC4366].

   IANA has assigned a TLS HandshakeType number 4 to the
   NewSessionTicket handshake type from the TLS registry of
   HandshakeType values defined in [RFC4346].

   This document does not require any actions or assignments from IANA.

8.  References

8.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2246]  Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              RFC 2246, January 1999.

   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346, April 2006.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, April 2006.

   [RFC4507]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
              "Transport Layer Security (TLS) Session Resumption without
              Server-Side State", RFC 4507, May 2006.

8.2.  Informative References

   [AES]      National Institute of Standards and Technology, "Advanced
              Encryption Standard (AES)", Federal Information Processing
              Standards (FIPS) Publication 197, November 2001.

   [ANON]     Pfitzmann, A. and M. Hansen, "Anonymity, Unlinkability,
              Unobservability, Pseudonymity, and Identity Management - A
              Consolidated Proposal for Terminology", http://
              dud.inf.tu-dresden.de/literatur/
              Anon_Terminology_v0.26-1.pdf Version 0.26, December 2005.







Salowey, et al.             Standards Track                    [Page 15]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   [CBC]      National Institute of Standards and Technology,
              "Recommendation for Block Cipher Modes of Operation -
              Methods and Techniques", NIST Special Publication 800-38A,
              December 2001.

   [CSSC]     Shacham, H., Boneh, D., and E. Rescorla, "Client-side
              caching for TLS", Transactions on Information and System
              Security (TISSEC) , Volume 7, Issue 4, November 2004.

   [RFC2712]  Medvinsky, A. and M. Hur, "Addition of Kerberos Cipher
              Suites to Transport Layer Security (TLS)", RFC 2712,
              October 1999.

   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, "Randomness
              Requirements for Security", BCP 106, RFC 4086, June 2005.

   [RFC4120]  Neuman, C., Yu, T., Hartman, S., and K. Raeburn, "The
              Kerberos Network Authentication Service (V5)", RFC 4120,
              July 2005.

   [RFC4279]  Eronen, P. and H. Tschofenig, "Pre-Shared Key Ciphersuites
              for Transport Layer Security (TLS)", RFC 4279,
              December 2005.

   [RFC4634]  Eastlake, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and HMAC-SHA)", RFC 4634, July 2006.

   [RFC4851]  Cam-Winget, N., McGrew, D., Salowey, J., and H. Zhou, "The
              Flexible Authentication via Secure Tunneling Extensible
              Authentication Protocol Method (EAP-FAST)", RFC 4851,
              May 2007.

   [SC97]     Aura, T. and P. Nikander, "Stateless Connections",
              Proceedings of the First International Conference on
              Information and Communication Security (ICICS '97) , 1997.
















Salowey, et al.             Standards Track                    [Page 16]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


Appendix A.  Discussion of Changes to RFC 4507

   RFC 4507 [RFC4507] defines a mechanism to resume a TLS session
   without maintaining server side state by specifying an encrypted
   ticket that is maintained on the client.  The client presents this
   ticket to the server in a SessionTicket hello extension.  The
   encoding in RFC 4507 used the XDR style encoding specified in TLS
   [RFC4346].

   An error in the encoding caused the specification to differ from
   deployed implementations.  At the time of this writing there are no
   known implementations that follow the encoding specified in RFC 4507.
   This update to RFC 4507 aligns the document with these currently
   deployed implementations.

   Erroneous encoding in RFC 4507 resulted in two length fields; one for
   the extension contents and one for the ticket itself.  Hence, for a
   ticket that is 256 bytes long and begins with the hex value FF FF,
   the encoding of the extension would be as follows according to RFC
   4507:

        00 23          Ticket Extension type 35
        01 02          Length of extension contents
        01 00          Length of ticket
        FF FF .. ..    Actual ticket

   The update proposed in this document reflects what implementations
   actually encode, namely it removes the redundant length field.  So,
   for a ticket that is 256 bytes long and begins with the hex value FF
   FF, the encoding of the extension would be as follows according to
   this update:

        00 23          Extension type 35
        01 00          Length of extension contents (ticket)
        FF FF .. ..    Actual ticket

   A server implemented according to RFC 4507 receiving a ticket
   extension from a client conforming to this document would interpret
   the first two bytes of the ticket as the length of this ticket.  This
   will result in either an inconsistent length field or in the
   processing of a ticket missing the first two bytes.  In the first
   case, the server should reject the request based on a malformed
   length.  In the second case, the server should reject the ticket
   based on a malformed ticket, incorrect key version, or failed
   decryption.  A server implementation based on this update receiving
   an RFC 4507 extension would interpret the first length field as the





Salowey, et al.             Standards Track                    [Page 17]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


   length of the ticket and include the second two length bytes as the
   first bytes in the ticket, resulting in the ticket being rejected
   based on a malformed ticket, incorrect key version, or failed
   decryption.

   Note that the encoding of an empty SessionTicket extension was
   ambiguous in RFC 4507.  An RFC 4507 implementation may have encoded
   it as:

        00 23      Extension type 35
        00 02      Length of extension contents
        00 00      Length of ticket

   or it may have encoded it the same way as this update:

        00 23      Extension type 35
        00 00      Length of extension contents

   A server wishing to support RFC 4507 clients should respond to an
   empty SessionTicket extension encoded the same way as it received it.

   A server implementation can construct tickets such that it can detect
   an RFC 4507 implementation, if one existed, by including a cookie at
   the beginning of the tickets that can be differentiated from a valid
   length.  For example, if an implementation constructed tickets to
   start with the hex values FF FF, then it could determine where the
   ticket begins and determine the length correctly from the type of
   length fields present.

   This document makes a few additional changes to RFC 4507 listed
   below.

   o  Clarifying that the server can allow session resumption using a
      ticket without issuing a new ticket in Section 3.1.

   o  Clarifying that the lifetime is relative to when the ticket is
      received in section 3.3.

   o  Clarifying that the NewSessionTicket handshake message is included
      in the hash generated for the Finished messages in Section 3.3.

   o  Clarifying the interaction with TLS Session ID in Section 3.4.

   o  Recommending the use of SHA-256 for the integrity protection of
      the ticket in Section 4.

   o  Clarifying that additional data can be included in the
      StatePlaintext structure in Section 4.



Salowey, et al.             Standards Track                    [Page 18]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


Authors' Addresses

   Joseph Salowey
   Cisco Systems
   2901 3rd Ave
   Seattle, WA  98121
   US

   EMail: jsalowey@cisco.com


   Hao Zhou
   Cisco Systems
   4125 Highlander Parkway
   Richfield, OH  44286
   US

   EMail: hzhou@cisco.com


   Pasi Eronen
   Nokia Research Center
   P.O. Box 407
   FIN-00045 Nokia Group
   Finland

   EMail: pasi.eronen@nokia.com


   Hannes Tschofenig
   Nokia Siemens Networks
   Otto-Hahn-Ring 6
   Munich, Bayern  81739
   Germany

   EMail: Hannes.Tschofenig@nsn.com















Salowey, et al.             Standards Track                    [Page 19]
   __________________________________________________________________


RFC 5077            Stateless TLS Session Resumption        January 2008


Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












Salowey, et al.             Standards Track                    [Page 20]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2] [IPR]
   [Errata]
   Updated by: 8446, 8447 PROPOSED STANDARD
   Errata Exist
Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 5705                                    RTFM, Inc.
Category: Standards Track                                     March 2010
ISSN: 2070-1721


      Keying Material Exporters for Transport Layer Security (TLS)

Abstract

   A number of protocols wish to leverage Transport Layer Security (TLS)
   to perform key establishment but then use some of the keying material
   for their own purposes.  This document describes a general mechanism
   for allowing that.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/5705.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow



Rescorla                     Standards Track                    [Page 1]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . 2
   2.  Conventions Used In This Document . . . . . . . . . . . . . . . 3
   3.  Binding to Application Contexts . . . . . . . . . . . . . . . . 3
   4.  Exporter Definition . . . . . . . . . . . . . . . . . . . . . . 4
   5.  Security Considerations . . . . . . . . . . . . . . . . . . . . 5
   6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . . . 6
   7.  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . 6
   8.  References  . . . . . . . . . . . . . . . . . . . . . . . . . . 7
     8.1.  Normative References  . . . . . . . . . . . . . . . . . . . 7
     8.2.  Informative References  . . . . . . . . . . . . . . . . . . 7

1.  Introduction

   Note:  The mechanism described in this document was previously known
          as "TLS Extractors" but was changed to avoid a name conflict
          with the use of the term "Extractor" in the cryptographic
          community.

   A number of protocols wish to leverage Transport Layer Security (TLS)
   [RFC5246] or Datagram TLS (DTLS) [RFC4347] to perform key
   establishment but then use some of the keying material for their own
   purposes.  A typical example is DTLS-SRTP [DTLS-SRTP], a key
   management scheme for the Secure Real-time Transport Protocol (SRTP)
   that uses DTLS to perform a key exchange and negotiate the SRTP
   [RFC3711] protection suite and then uses the DTLS master_secret to
   generate the SRTP keys.

   These applications imply a need to be able to export keying material
   (later called Exported Keying Material or EKM) from TLS/DTLS to an
   application or protocol residing at an upper layer, and to securely
   agree on the upper-layer context where the keying material will be
   used.  The mechanism for exporting the keying material has the
   following requirements:

   o  Both client and server need to be able to export the same EKM
      value.





Rescorla                     Standards Track                    [Page 2]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


   o  EKM values should be indistinguishable from random data to
      attackers who don't know the master_secret.

   o  It should be possible to export multiple EKM values from the same
      TLS/DTLS association.

   o  Knowing one EKM value should not reveal any useful information
      about the master_secret or about other EKM values.

   The mechanism described in this document is intended to fulfill these
   requirements.  This mechanism is compatible with all versions of TLS.

2.  Conventions Used In This Document

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

3.  Binding to Application Contexts

   In addition to using an exporter to obtain keying material, an
   application using the keying material has to securely establish the
   upper-layer context where the keying material will be used.  The
   details of this context depend on the application, but it could
   include things such as algorithms and parameters that will be used
   with the keys, identifier(s) for the endpoint(s) who will use the
   keys, identifier(s) for the session(s) where the keys will be used,
   and the lifetime(s) for the context and/or keys.  At a minimum, there
   should be some mechanism for signaling that an exporter will be used.

   This specification does not mandate a single mechanism for agreeing
   on such context; instead, there are several possibilities that can be
   used (and can complement each other).  For example:

   o  Information about the upper-layer context can be included in the
      optional data after the exporter label (see Section 4).

   o  Information about the upper-layer context can be exchanged in TLS
      extensions included in the ClientHello and ServerHello messages.
      This approach is used in [DTLS-SRTP].  The handshake messages are
      protected by the Finished messages, so once the handshake
      completes, the peers will have the same view of the information.
      Extensions also allow a limited form of negotiation: for example,
      the TLS client could propose several alternatives for some context
      parameters, and the TLS server could select one of them.

   o  The upper-layer protocol can include its own handshake, which can
      be protected using the keys exported by TLS.



Rescorla                     Standards Track                    [Page 3]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


   No matter how the context is agreed, it is required that it has one
   part that indicates which application will use the exported keys.
   This part is the disambiguating label string (see Section 4).

   It is important to note that just embedding TLS messages in the
   upper-layer protocol may not automatically secure all the important
   context information, since the upper-layer messages are not covered
   by TLS Finished messages.

4.  Exporter Definition

   The output of the exporter is intended to be used in a single scope,
   which is associated with the TLS session, the label, and the context
   value.

   The exporter takes three input values:

   o  a disambiguating label string,

   o  a per-association context value provided by the application using
      the exporter, and

   o  a length value.

   If no context is provided, it then computes:

           PRF(SecurityParameters.master_secret, label,
               SecurityParameters.client_random +
               SecurityParameters.server_random
               )[length]

   If context is provided, it computes:

           PRF(SecurityParameters.master_secret, label,
               SecurityParameters.client_random +
               SecurityParameters.server_random +
               context_value_length + context_value
               )[length]

   Where PRF is the TLS Pseudorandom Function in use for the session.
   The output is a pseudorandom bit string of length bytes generated
   from the master_secret.  (This construction allows for
   interoperability with older exporter-type constructions which do not
   use context values, e.g., [RFC5281]).

   Labels here have the same definition as in TLS, i.e., an ASCII string
   with no terminating NULL.  Label values beginning with "EXPERIMENTAL"
   MAY be used for private use without registration.  All other label



Rescorla                     Standards Track                    [Page 4]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


   values MUST be registered via Specification Required as described by
   RFC 5226 [RFC5226].  Note that exporter labels have the potential to
   collide with existing PRF labels.  In order to prevent this, labels
   SHOULD begin with "EXPORTER".  This is not a MUST because there are
   existing uses that have labels which do not begin with this prefix.

   The context value allows the application using the exporter to mix
   its own data with the TLS PRF for the exporter output.  One example
   of where this might be useful is an authentication setting where the
   client credentials are valid for more than one identity; the context
   value could then be used to mix the expected identity into the keying
   material, thus preventing substitution attacks.  The context value
   length is encoded as an unsigned, 16-bit quantity (uint16; see
   [RFC5246], Section 4.4) representing the length of the context value.
   The context MAY be zero length.  Because the context value is mixed
   with the master_secret via the PRF, it is safe to mix confidential
   information into the exporter, provided that the master_secret will
   not be known to the attacker.

5.  Security Considerations

   The prime security requirement for exporter outputs is that they be
   independent.  More formally, after a particular TLS session, if an
   adversary is allowed to choose multiple (label, context value) pairs
   and is given the output of the PRF for those values, the attacker is
   still unable to distinguish between the output of the PRF for a
   (label, context value) pair (different from the ones that it
   submitted) and a random value of the same length.  In particular,
   there may be settings, such as the one described in Section 4, where
   the attacker can control the context value; such an attacker MUST NOT
   be able to predict the output of the exporter.  Similarly, an
   attacker who does not know the master secret should not be able to
   distinguish valid exporter outputs from random values.  The current
   set of TLS PRFs is believed to meet this objective, provided the
   master secret is randomly generated.

   Because an exporter produces the same value if applied twice with the
   same label to the same master_secret, it is critical that two EKM
   values generated with the same label not be used for two different
   purposes -- hence, the requirement for IANA registration.  However,
   because exporters depend on the TLS PRF, it is not a threat to the
   use of an EKM value generated from one label to reveal an EKM value
   generated from another label.

   With certain TLS cipher suites, the TLS master secret is not
   necessarily unique to a single TLS session.  In particular, with RSA
   key exchange, a malicious party acting as TLS server in one session
   and as TLS client in another session can cause those two sessions to



Rescorla                     Standards Track                    [Page 5]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


   have the same TLS master secret (though the sessions must be
   established simultaneously to get adequate control of the Random
   values).  Applications using the EKM need to consider this in how
   they use the EKM; in some cases, requiring the use of other cipher
   suites (such as those using a Diffie-Hellman key exchange) may be
   advisable.

   Designing a secure mechanism that uses exporters is not necessarily
   straightforward.  This document only provides the exporter mechanism,
   but the problem of agreeing on the surrounding context and the
   meaning of the information passed to and from the exporter remains.
   Any new uses of the exporter mechanism should be subject to careful
   review.

6.  IANA Considerations

   IANA has created a TLS Exporter Label registry for this purpose.  The
   initial contents of the registry are given below:

        Value                          Reference  Note
        -----------------------------  ---------  ----
        client finished                [RFC5246]  (1)
        server finished                [RFC5246]  (1)
        master secret                  [RFC5246]  (1)
        key expansion                  [RFC5246]  (1)
        client EAP encryption          [RFC5216]
        ttls keying material           [RFC5281]
        ttls challenge                 [RFC5281]

   Note: (1) These entries are reserved and MUST NOT be used for the
   purpose described in RFC 5705, in order to avoid confusion with
   similar, but distinct, use in RFC 5246.

   Future values are allocated via the RFC 5226 Specification Required
   policy.  The label is a string consisting of printable ASCII
   characters.  IANA MUST also verify that one label is not a prefix of
   any other label.  For example, labels "key" or "master secretary" are
   forbidden.

7.  Acknowledgments

   Thanks to Pasi Eronen for valuable comments and for the contents of
   the IANA section and Section 3.  Thanks to David McGrew for helpful
   discussion of the security considerations and to Vijay Gurbani and
   Alfred Hoenes for editorial comments.






Rescorla                     Standards Track                    [Page 6]
   __________________________________________________________________


RFC 5705                      TLS Exporters                   March 2010


8.  References

8.1.  Normative References

   [RFC2119]    Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC5226]    Narten, T. and H. Alvestrand, "Guidelines for Writing an
                IANA Considerations Section in RFCs", BCP 26, RFC 5226,
                May 2008.

   [RFC5246]    Dierks, T. and E. Rescorla, "The Transport Layer
                Security (TLS) Protocol Version 1.2", RFC 5246,
                August 2008.

8.2.  Informative References

   [DTLS-SRTP]  McGrew, D. and E. Rescorla, "Datagram Transport Layer
                Security (DTLS) Extension to Establish Keys for Secure
                Real-time Transport Protocol (SRTP)", Work in Progress,
                February 2009.

   [RFC3711]    Baugher, M., McGrew, D., Naslund, M., Carrara, E., and
                K. Norrman, "The Secure Real-time Transport Protocol
                (SRTP)", RFC 3711, March 2004.

   [RFC4347]    Rescorla, E. and N. Modadugu, "Datagram Transport Layer
                Security", RFC 4347, April 2006.

   [RFC5216]    Simon, D., Aboba, B., and R. Hurst, "The EAP-TLS
                Authentication Protocol", RFC 5216, March 2008.

   [RFC5281]    Funk, P. and S. Blake-Wilson, "Extensible Authentication
                Protocol Tunneled Transport Layer Security Authenticated
                Protocol Version 0 (EAP-TTLSv0)", RFC 5281, August 2008.

Author's Address

   Eric Rescorla
   RTFM, Inc.
   2064 Edgewood Drive
   Palo Alto, CA  94303
   USA

   EMail: ekr@rtfm.com






Rescorla                     Standards Track                    [Page 7]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2]
   [Errata]
   Updated by: 8446, 8449 PROPOSED STANDARD
   Errata Exist
Internet Engineering Task Force (IETF)                   D. Eastlake 3rd
Request for Comments: 6066                                        Huawei
Obsoletes: 4366                                             January 2011
Category: Standards Track
ISSN: 2070-1721


    Transport Layer Security (TLS) Extensions: Extension Definitions

Abstract

   This document provides specifications for existing TLS extensions.
   It is a companion document for RFC 5246, "The Transport Layer
   Security (TLS) Protocol Version 1.2".  The extensions specified are
   server_name, max_fragment_length, client_certificate_url,
   trusted_ca_keys, truncated_hmac, and status_request.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc6066.

Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.






Eastlake                     Standards Track                    [Page 1]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   1. Introduction ....................................................3
      1.1. Specific Extensions Covered ................................3
      1.2. Conventions Used in This Document ..........................5
   2. Extensions to the Handshake Protocol ............................5
   3. Server Name Indication ..........................................6
   4. Maximum Fragment Length Negotiation .............................8
   5. Client Certificate URLs .........................................9
   6. Trusted CA Indication ..........................................12
   7. Truncated HMAC .................................................13
   8. Certificate Status Request .....................................14
   9. Error Alerts ...................................................16
   10. IANA Considerations ...........................................17
      10.1. pkipath MIME Type Registration ...........................17
      10.2. Reference for TLS Alerts, TLS HandshakeTypes, and
            ExtensionTypes ...........................................19
   11. Security Considerations .......................................19
      11.1. Security Considerations for server_name ..................19
      11.2. Security Considerations for max_fragment_length ..........20
      11.3. Security Considerations for client_certificate_url .......20
      11.4. Security Considerations for trusted_ca_keys ..............21
      11.5. Security Considerations for truncated_hmac ...............21
      11.6. Security Considerations for status_request ...............22
   12. Normative References ..........................................22
   13. Informative References ........................................23
   Appendix A. Changes from RFC 4366 .................................24
   Appendix B. Acknowledgements ......................................25











Eastlake                     Standards Track                    [Page 2]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


1.  Introduction

   The Transport Layer Security (TLS) Protocol Version 1.2 is specified
   in [RFC5246].  That specification includes the framework for
   extensions to TLS, considerations in designing such extensions (see
   Section 7.4.1.4 of [RFC5246]), and IANA Considerations for the
   allocation of new extension code points; however, it does not specify
   any particular extensions other than Signature Algorithms (see
   Section 7.4.1.4.1 of [RFC5246]).

   This document provides the specifications for existing TLS
   extensions.  It is, for the most part, the adaptation and editing of
   material from RFC 4366, which covered TLS extensions for TLS 1.0 (RFC
   2246) and TLS 1.1 (RFC 4346).

1.1.  Specific Extensions Covered

   The extensions described here focus on extending the functionality
   provided by the TLS protocol message formats.  Other issues, such as
   the addition of new cipher suites, are deferred.

   The extension types defined in this document are:

      enum {
          server_name(0), max_fragment_length(1),
          client_certificate_url(2), trusted_ca_keys(3),
          truncated_hmac(4), status_request(5), (65535)
      } ExtensionType;

   Specifically, the extensions described in this document:

   -  Allow TLS clients to provide to the TLS server the name of the
      server they are contacting.  This functionality is desirable in
      order to facilitate secure connections to servers that host
      multiple 'virtual' servers at a single underlying network address.

   -  Allow TLS clients and servers to negotiate the maximum fragment
      length to be sent.  This functionality is desirable as a result of
      memory constraints among some clients, and bandwidth constraints
      among some access networks.

   -  Allow TLS clients and servers to negotiate the use of client
      certificate URLs.  This functionality is desirable in order to
      conserve memory on constrained clients.







Eastlake                     Standards Track                    [Page 3]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   -  Allow TLS clients to indicate to TLS servers which certification
      authority (CA) root keys they possess.  This functionality is
      desirable in order to prevent multiple handshake failures
      involving TLS clients that are only able to store a small number
      of CA root keys due to memory limitations.

   -  Allow TLS clients and servers to negotiate the use of truncated
      Message Authentication Codes (MACs).  This functionality is
      desirable in order to conserve bandwidth in constrained access
      networks.

   -  Allow TLS clients and servers to negotiate that the server sends
      the client certificate status information (e.g., an Online
      Certificate Status Protocol (OCSP) [RFC2560] response) during a
      TLS handshake.  This functionality is desirable in order to avoid
      sending a Certificate Revocation List (CRL) over a constrained
      access network and therefore saving bandwidth.

   TLS clients and servers may use the extensions described in this
   document.  The extensions are designed to be backwards compatible,
   meaning that TLS clients that support the extensions can talk to TLS
   servers that do not support the extensions, and vice versa.

   Note that any messages associated with these extensions that are sent
   during the TLS handshake MUST be included in the hash calculations
   involved in "Finished" messages.

   Note also that all the extensions defined in this document are
   relevant only when a session is initiated.  A client that requests
   session resumption does not in general know whether the server will
   accept this request, and therefore it SHOULD send the same extensions
   as it would send if it were not attempting resumption.  When a client
   includes one or more of the defined extension types in an extended
   client hello while requesting session resumption:

   -  The server name indication extension MAY be used by the server
      when deciding whether or not to resume a session as described in
      Section 3.

   -  If the resumption request is denied, the use of the extensions is
      negotiated as normal.

   -  If, on the other hand, the older session is resumed, then the
      server MUST ignore the extensions and send a server hello
      containing none of the extension types.  In this case, the
      functionality of these extensions negotiated during the original
      session initiation is applied to the resumed session.




Eastlake                     Standards Track                    [Page 4]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


1.2.  Conventions Used in This Document

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [RFC2119].

2.  Extensions to the Handshake Protocol

   This document specifies the use of two new handshake messages,
   "CertificateURL" and "CertificateStatus".  These messages are
   described in Sections 5 and 8, respectively.  The new handshake
   message structure therefore becomes:

   enum {
       hello_request(0), client_hello(1), server_hello(2),
       certificate(11), server_key_exchange (12),
       certificate_request(13), server_hello_done(14),
       certificate_verify(15), client_key_exchange(16),
       finished(20), certificate_url(21), certificate_status(22),
       (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;    /* handshake type */
       uint24 length;             /* bytes in message */
       select (HandshakeType) {
           case hello_request:       HelloRequest;
           case client_hello:        ClientHello;
           case server_hello:        ServerHello;
           case certificate:         Certificate;
           case server_key_exchange: ServerKeyExchange;
           case certificate_request: CertificateRequest;
           case server_hello_done:   ServerHelloDone;
           case certificate_verify:  CertificateVerify;
           case client_key_exchange: ClientKeyExchange;
           case finished:            Finished;
           case certificate_url:     CertificateURL;
           case certificate_status:  CertificateStatus;
       } body;
   } Handshake;










Eastlake                     Standards Track                    [Page 5]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


3.  Server Name Indication

   TLS does not provide a mechanism for a client to tell a server the
   name of the server it is contacting.  It may be desirable for clients
   to provide this information to facilitate secure connections to
   servers that host multiple 'virtual' servers at a single underlying
   network address.

   In order to provide any of the server names, clients MAY include an
   extension of type "server_name" in the (extended) client hello.  The
   "extension_data" field of this extension SHALL contain
   "ServerNameList" where:

      struct {
          NameType name_type;
          select (name_type) {
              case host_name: HostName;
          } name;
      } ServerName;

      enum {
          host_name(0), (255)
      } NameType;

      opaque HostName<1..2^16-1>;

      struct {
          ServerName server_name_list<1..2^16-1>
      } ServerNameList;

   The ServerNameList MUST NOT contain more than one name of the same
   name_type.  If the server understood the ClientHello extension but
   does not recognize the server name, the server SHOULD take one of two
   actions: either abort the handshake by sending a fatal-level
   unrecognized_name(112) alert or continue the handshake.  It is NOT
   RECOMMENDED to send a warning-level unrecognized_name(112) alert,
   because the client's behavior in response to warning-level alerts is
   unpredictable.  If there is a mismatch between the server name used
   by the client application and the server name of the credential
   chosen by the server, this mismatch will become apparent when the
   client application performs the server endpoint identification, at
   which point the client application will have to decide whether to
   proceed with the communication.  TLS implementations are encouraged
   to make information available to application callers about warning-
   level alerts that were received or sent during a TLS handshake.  Such
   information can be useful for diagnostic purposes.





Eastlake                     Standards Track                    [Page 6]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


      Note: Earlier versions of this specification permitted multiple
      names of the same name_type.  In practice, current client
      implementations only send one name, and the client cannot
      necessarily find out which name the server selected.  Multiple
      names of the same name_type are therefore now prohibited.

   Currently, the only server names supported are DNS hostnames;
   however, this does not imply any dependency of TLS on DNS, and other
   name types may be added in the future (by an RFC that updates this
   document).  The data structure associated with the host_name NameType
   is a variable-length vector that begins with a 16-bit length.  For
   backward compatibility, all future data structures associated with
   new NameTypes MUST begin with a 16-bit length field.  TLS MAY treat
   provided server names as opaque data and pass the names and types to
   the application.

   "HostName" contains the fully qualified DNS hostname of the server,
   as understood by the client.  The hostname is represented as a byte
   string using ASCII encoding without a trailing dot.  This allows the
   support of internationalized domain names through the use of A-labels
   defined in [RFC5890].  DNS hostnames are case-insensitive.  The
   algorithm to compare hostnames is described in [RFC5890], Section
   2.3.2.4.

   Literal IPv4 and IPv6 addresses are not permitted in "HostName".

   It is RECOMMENDED that clients include an extension of type
   "server_name" in the client hello whenever they locate a server by a
   supported name type.

   A server that receives a client hello containing the "server_name"
   extension MAY use the information contained in the extension to guide
   its selection of an appropriate certificate to return to the client,
   and/or other aspects of security policy.  In this event, the server
   SHALL include an extension of type "server_name" in the (extended)
   server hello.  The "extension_data" field of this extension SHALL be
   empty.

   When the server is deciding whether or not to accept a request to
   resume a session, the contents of a server_name extension MAY be used
   in the lookup of the session in the session cache.  The client SHOULD
   include the same server_name extension in the session resumption
   request as it did in the full handshake that established the session.
   A server that implements this extension MUST NOT accept the request
   to resume the session if the server_name extension contains a
   different name.  Instead, it proceeds with a full handshake to
   establish a new session.  When resuming a session, the server MUST
   NOT include a server_name extension in the server hello.



Eastlake                     Standards Track                    [Page 7]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   If an application negotiates a server name using an application
   protocol and then upgrades to TLS, and if a server_name extension is
   sent, then the extension SHOULD contain the same name that was
   negotiated in the application protocol.  If the server_name is
   established in the TLS session handshake, the client SHOULD NOT
   attempt to request a different server name at the application layer.

4.  Maximum Fragment Length Negotiation

   Without this extension, TLS specifies a fixed maximum plaintext
   fragment length of 2^14 bytes.  It may be desirable for constrained
   clients to negotiate a smaller maximum fragment length due to memory
   limitations or bandwidth limitations.

   In order to negotiate smaller maximum fragment lengths, clients MAY
   include an extension of type "max_fragment_length" in the (extended)
   client hello.  The "extension_data" field of this extension SHALL
   contain:

      enum{
          2^9(1), 2^10(2), 2^11(3), 2^12(4), (255)
      } MaxFragmentLength;

   whose value is the desired maximum fragment length.  The allowed
   values for this field are: 2^9, 2^10, 2^11, and 2^12.

   Servers that receive an extended client hello containing a
   "max_fragment_length" extension MAY accept the requested maximum
   fragment length by including an extension of type
   "max_fragment_length" in the (extended) server hello.  The
   "extension_data" field of this extension SHALL contain a
   "MaxFragmentLength" whose value is the same as the requested maximum
   fragment length.

   If a server receives a maximum fragment length negotiation request
   for a value other than the allowed values, it MUST abort the
   handshake with an "illegal_parameter" alert.  Similarly, if a client
   receives a maximum fragment length negotiation response that differs
   from the length it requested, it MUST also abort the handshake with
   an "illegal_parameter" alert.

   Once a maximum fragment length other than 2^14 has been successfully
   negotiated, the client and server MUST immediately begin fragmenting
   messages (including handshake messages) to ensure that no fragment
   larger than the negotiated length is sent.  Note that TLS already
   requires clients and servers to support fragmentation of handshake
   messages.




Eastlake                     Standards Track                    [Page 8]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   The negotiated length applies for the duration of the session
   including session resumptions.

   The negotiated length limits the input that the record layer may
   process without fragmentation (that is, the maximum value of
   TLSPlaintext.length; see [RFC5246], Section 6.2.1).  Note that the
   output of the record layer may be larger.  For example, if the
   negotiated length is 2^9=512, then, when using currently defined
   cipher suites (those defined in [RFC5246] and [RFC2712]) and null
   compression, the record-layer output can be at most 805 bytes: 5
   bytes of headers, 512 bytes of application data, 256 bytes of
   padding, and 32 bytes of MAC.  This means that in this event a TLS
   record-layer peer receiving a TLS record-layer message larger than
   805 bytes MUST discard the message and send a "record_overflow"
   alert, without decrypting the message.  When this extension is used
   with Datagram Transport Layer Security (DTLS), implementations SHOULD
   NOT generate record_overflow alerts unless the packet passes message
   authentication.

5.  Client Certificate URLs

   Without this extension, TLS specifies that when client authentication
   is performed, client certificates are sent by clients to servers
   during the TLS handshake.  It may be desirable for constrained
   clients to send certificate URLs in place of certificates, so that
   they do not need to store their certificates and can therefore save
   memory.

   In order to negotiate sending certificate URLs to a server, clients
   MAY include an extension of type "client_certificate_url" in the
   (extended) client hello.  The "extension_data" field of this
   extension SHALL be empty.

   (Note that it is necessary to negotiate the use of client certificate
   URLs in order to avoid "breaking" existing TLS servers.)

   Servers that receive an extended client hello containing a
   "client_certificate_url" extension MAY indicate that they are willing
   to accept certificate URLs by including an extension of type
   "client_certificate_url" in the (extended) server hello.  The
   "extension_data" field of this extension SHALL be empty.

   After negotiation of the use of client certificate URLs has been
   successfully completed (by exchanging hellos including
   "client_certificate_url" extensions), clients MAY send a
   "CertificateURL" message in place of a "Certificate" message as
   follows (see also Section 2):




Eastlake                     Standards Track                    [Page 9]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


      enum {
          individual_certs(0), pkipath(1), (255)
      } CertChainType;

      struct {
          CertChainType type;
          URLAndHash url_and_hash_list<1..2^16-1>;
      } CertificateURL;

      struct {
          opaque url<1..2^16-1>;
          unint8 padding;
          opaque SHA1Hash[20];
      } URLAndHash;

   Here, "url_and_hash_list" contains a sequence of URLs and hashes.
   Each "url" MUST be an absolute URI reference according to [RFC3986]
   that can be immediately used to fetch the certificate(s).

   When X.509 certificates are used, there are two possibilities:

   -  If CertificateURL.type is "individual_certs", each URL refers to a
      single DER-encoded X.509v3 certificate, with the URL for the
      client's certificate first.

   -  If CertificateURL.type is "pkipath", the list contains a single
      URL referring to a DER-encoded certificate chain, using the type
      PkiPath described in Section 10.1.

   When any other certificate format is used, the specification that
   describes use of that format in TLS should define the encoding format
   of certificates or certificate chains, and any constraint on their
   ordering.

   The "padding" byte MUST be 0x01.  It is present to make the structure
   backwards compatible.

   The hash corresponding to each URL is the SHA-1 hash of the
   certificate or certificate chain (in the case of X.509 certificates,
   the DER-encoded certificate or the DER-encoded PkiPath).

   Note that when a list of URLs for X.509 certificates is used, the
   ordering of URLs is the same as that used in the TLS Certificate
   message (see [RFC5246], Section 7.4.2), but opposite to the order in
   which certificates are encoded in PkiPath.  In either case, the self-
   signed root certificate MAY be omitted from the chain, under the
   assumption that the server must already possess it in order to
   validate it.



Eastlake                     Standards Track                   [Page 10]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   Servers receiving "CertificateURL" SHALL attempt to retrieve the
   client's certificate chain from the URLs and then process the
   certificate chain as usual.  A cached copy of the content of any URL
   in the chain MAY be used, provided that the SHA-1 hash matches the
   hash of the cached copy.

   Servers that support this extension MUST support the 'http' URI
   scheme for certificate URLs and MAY support other schemes.  Use of
   other schemes than 'http', 'https', or 'ftp' may create unexpected
   problems.

   If the protocol used is HTTP, then the HTTP server can be configured
   to use the Cache-Control and Expires directives described in
   [RFC2616] to specify whether and for how long certificates or
   certificate chains should be cached.

   The TLS server MUST NOT follow HTTP redirects when retrieving the
   certificates or certificate chain.  The URLs used in this extension
   MUST NOT be chosen to depend on such redirects.

   If the protocol used to retrieve certificates or certificate chains
   returns a MIME-formatted response (as HTTP does), then the following
   MIME Content-Types SHALL be used: when a single X.509v3 certificate
   is returned, the Content-Type is "application/pkix-cert" [RFC2585],
   and when a chain of X.509v3 certificates is returned, the Content-
   Type is "application/pkix-pkipath" (Section 10.1).

   The server MUST check that the SHA-1 hash of the contents of the
   object retrieved from that URL (after decoding any MIME Content-
   Transfer-Encoding) matches the given hash.  If any retrieved object
   does not have the correct SHA-1 hash, the server MUST abort the
   handshake with a bad_certificate_hash_value(114) alert.  This alert
   is always fatal.

   Clients may choose to send either "Certificate" or "CertificateURL"
   after successfully negotiating the option to send certificate URLs.
   The option to send a certificate is included to provide flexibility
   to clients possessing multiple certificates.

   If a server is unable to obtain certificates in a given
   CertificateURL, it MUST send a fatal certificate_unobtainable(111)
   alert if it requires the certificates to complete the handshake.  If
   the server does not require the certificates, then the server
   continues the handshake.  The server MAY send a warning-level alert
   in this case.  Clients receiving such an alert SHOULD log the alert
   and continue with the handshake if possible.





Eastlake                     Standards Track                   [Page 11]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


6.  Trusted CA Indication

   Constrained clients that, due to memory limitations, possess only a
   small number of CA root keys may wish to indicate to servers which
   root keys they possess, in order to avoid repeated handshake
   failures.

   In order to indicate which CA root keys they possess, clients MAY
   include an extension of type "trusted_ca_keys" in the (extended)
   client hello.  The "extension_data" field of this extension SHALL
   contain "TrustedAuthorities" where:

      struct {
          TrustedAuthority trusted_authorities_list<0..2^16-1>;
      } TrustedAuthorities;

      struct {
          IdentifierType identifier_type;
          select (identifier_type) {
              case pre_agreed: struct {};
              case key_sha1_hash: SHA1Hash;
              case x509_name: DistinguishedName;
              case cert_sha1_hash: SHA1Hash;
          } identifier;
      } TrustedAuthority;

      enum {
          pre_agreed(0), key_sha1_hash(1), x509_name(2),
          cert_sha1_hash(3), (255)
      } IdentifierType;

      opaque DistinguishedName<1..2^16-1>;

   Here, "TrustedAuthorities" provides a list of CA root key identifiers
   that the client possesses.  Each CA root key is identified via
   either:

   -  "pre_agreed": no CA root key identity supplied.

   -  "key_sha1_hash": contains the SHA-1 hash of the CA root key.  For
      Digital Signature Algorithm (DSA) and Elliptic Curve Digital
      Signature Algorithm (ECDSA) keys, this is the hash of the
      "subjectPublicKey" value.  For RSA keys, the hash is of the big-
      endian byte string representation of the modulus without any
      initial zero-valued bytes.  (This copies the key hash formats
      deployed in other environments.)





Eastlake                     Standards Track                   [Page 12]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   -  "x509_name": contains the DER-encoded X.509 DistinguishedName of
      the CA.

   -  "cert_sha1_hash": contains the SHA-1 hash of a DER-encoded
      Certificate containing the CA root key.

   Note that clients may include none, some, or all of the CA root keys
   they possess in this extension.

   Note also that it is possible that a key hash or a Distinguished Name
   alone may not uniquely identify a certificate issuer (for example, if
   a particular CA has multiple key pairs).  However, here we assume
   this is the case following the use of Distinguished Names to identify
   certificate issuers in TLS.

   The option to include no CA root keys is included to allow the client
   to indicate possession of some pre-defined set of CA root keys.

   Servers that receive a client hello containing the "trusted_ca_keys"
   extension MAY use the information contained in the extension to guide
   their selection of an appropriate certificate chain to return to the
   client.  In this event, the server SHALL include an extension of type
   "trusted_ca_keys" in the (extended) server hello.  The
   "extension_data" field of this extension SHALL be empty.

7.  Truncated HMAC

   Currently defined TLS cipher suites use the MAC construction HMAC
   [RFC2104] to authenticate record-layer communications.  In TLS, the
   entire output of the hash function is used as the MAC tag.  However,
   it may be desirable in constrained environments to save bandwidth by
   truncating the output of the hash function to 80 bits when forming
   MAC tags.

   In order to negotiate the use of 80-bit truncated HMAC, clients MAY
   include an extension of type "truncated_hmac" in the extended client
   hello.  The "extension_data" field of this extension SHALL be empty.

   Servers that receive an extended hello containing a "truncated_hmac"
   extension MAY agree to use a truncated HMAC by including an extension
   of type "truncated_hmac", with empty "extension_data", in the
   extended server hello.

   Note that if new cipher suites are added that do not use HMAC, and
   the session negotiates one of these cipher suites, this extension
   will have no effect.  It is strongly recommended that any new cipher
   suites using other MACs consider the MAC size an integral part of the




Eastlake                     Standards Track                   [Page 13]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   cipher suite definition, taking into account both security and
   bandwidth considerations.

   If HMAC truncation has been successfully negotiated during a TLS
   handshake, and the negotiated cipher suite uses HMAC, both the client
   and the server pass this fact to the TLS record layer along with the
   other negotiated security parameters.  Subsequently during the
   session, clients and servers MUST use truncated HMACs, calculated as
   specified in [RFC2104].  That is, SecurityParameters.mac_length is 10
   bytes, and only the first 10 bytes of the HMAC output are transmitted
   and checked.  Note that this extension does not affect the
   calculation of the pseudo-random function (PRF) as part of
   handshaking or key derivation.

   The negotiated HMAC truncation size applies for the duration of the
   session including session resumptions.

8.  Certificate Status Request

   Constrained clients may wish to use a certificate-status protocol
   such as OCSP [RFC2560] to check the validity of server certificates,
   in order to avoid transmission of CRLs and therefore save bandwidth
   on constrained networks.  This extension allows for such information
   to be sent in the TLS handshake, saving roundtrips and resources.

   In order to indicate their desire to receive certificate status
   information, clients MAY include an extension of type
   "status_request" in the (extended) client hello.  The
   "extension_data" field of this extension SHALL contain
   "CertificateStatusRequest" where:

      struct {
          CertificateStatusType status_type;
          select (status_type) {
              case ocsp: OCSPStatusRequest;
          } request;
      } CertificateStatusRequest;

      enum { ocsp(1), (255) } CertificateStatusType;

      struct {
          ResponderID responder_id_list<0..2^16-1>;
          Extensions  request_extensions;
      } OCSPStatusRequest;

      opaque ResponderID<1..2^16-1>;
      opaque Extensions<0..2^16-1>;




Eastlake                     Standards Track                   [Page 14]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   In the OCSPStatusRequest, the "ResponderIDs" provides a list of OCSP
   responders that the client trusts.  A zero-length "responder_id_list"
   sequence has the special meaning that the responders are implicitly
   known to the server, e.g., by prior arrangement.  "Extensions" is a
   DER encoding of OCSP request extensions.

   Both "ResponderID" and "Extensions" are DER-encoded ASN.1 types as
   defined in [RFC2560].  "Extensions" is imported from [RFC5280].  A
   zero-length "request_extensions" value means that there are no
   extensions (as opposed to a zero-length ASN.1 SEQUENCE, which is not
   valid for the "Extensions" type).

   In the case of the "id-pkix-ocsp-nonce" OCSP extension, [RFC2560] is
   unclear about its encoding; for clarification, the nonce MUST be a
   DER-encoded OCTET STRING, which is encapsulated as another OCTET
   STRING (note that implementations based on an existing OCSP client
   will need to be checked for conformance to this requirement).

   Servers that receive a client hello containing the "status_request"
   extension MAY return a suitable certificate status response to the
   client along with their certificate.  If OCSP is requested, they
   SHOULD use the information contained in the extension when selecting
   an OCSP responder and SHOULD include request_extensions in the OCSP
   request.

   Servers return a certificate response along with their certificate by
   sending a "CertificateStatus" message immediately after the
   "Certificate" message (and before any "ServerKeyExchange" or
   "CertificateRequest" messages).  If a server returns a
   "CertificateStatus" message, then the server MUST have included an
   extension of type "status_request" with empty "extension_data" in the
   extended server hello.  The "CertificateStatus" message is conveyed
   using the handshake message type "certificate_status" as follows (see
   also Section 2):

      struct {
          CertificateStatusType status_type;
          select (status_type) {
              case ocsp: OCSPResponse;
          } response;
      } CertificateStatus;

      opaque OCSPResponse<1..2^24-1>;

   An "ocsp_response" contains a complete, DER-encoded OCSP response
   (using the ASN.1 type OCSPResponse defined in [RFC2560]).  Only one
   OCSP response may be sent.




Eastlake                     Standards Track                   [Page 15]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   Note that a server MAY also choose not to send a "CertificateStatus"
   message, even if has received a "status_request" extension in the
   client hello message and has sent a "status_request" extension in the
   server hello message.

   Note in addition that a server MUST NOT send the "CertificateStatus"
   message unless it received a "status_request" extension in the client
   hello message and sent a "status_request" extension in the server
   hello message.

   Clients requesting an OCSP response and receiving an OCSP response in
   a "CertificateStatus" message MUST check the OCSP response and abort
   the handshake if the response is not satisfactory with
   bad_certificate_status_response(113) alert.  This alert is always
   fatal.

9.  Error Alerts

   Four new error alerts are defined for use with the TLS extensions
   defined in this document.  To avoid "breaking" existing clients and
   servers, these alerts MUST NOT be sent unless the sending party has
   received an extended hello message from the party they are
   communicating with.  These error alerts are conveyed using the
   following syntax.  The new alerts are the last four, as indicated by
   the comments on the same line as the error alert number.

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed(21),
          record_overflow(22),
          decompression_failure(30),
          handshake_failure(40),
          /* 41 is not defined, for historical reasons */
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          export_restriction(60),
          protocol_version(70),
          insufficient_security(71),



Eastlake                     Standards Track                   [Page 16]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


          internal_error(80),
          user_canceled(90),
          no_renegotiation(100),
          unsupported_extension(110),
          certificate_unobtainable(111),        /* new */
          unrecognized_name(112),               /* new */
          bad_certificate_status_response(113), /* new */
          bad_certificate_hash_value(114),      /* new */
          (255)
      } AlertDescription;

   "certificate_unobtainable" is described in Section 5.
   "unrecognized_name" is described in Section 3.
   "bad_certificate_status_response" is described in Section 8.
   "bad_certificate_hash_value" is described in Section 5.

10.  IANA Considerations

   IANA Considerations for TLS extensions and the creation of a registry
   are covered in Section 12 of [RFC5246] except for the registration of
   MIME type application/pkix-pkipath, which appears below.

   The IANA TLS extensions and MIME type application/pkix-pkipath
   registry entries that reference RFC 4366 have been updated to
   reference this document.

10.1.  pkipath MIME Type Registration

   MIME media type name: application
   MIME subtype name: pkix-pkipath
   Required parameters: none

   Optional parameters: version (default value is "1")

   Encoding considerations:
      Binary; this MIME type is a DER encoding of the ASN.1 type
      PkiPath, defined as follows:
        PkiPath ::= SEQUENCE OF Certificate
        PkiPath is used to represent a certification path.  Within the
        sequence, the order of certificates is such that the subject of
        the first certificate is the issuer of the second certificate,
        etc.
      This is identical to the definition published in [X509-4th-TC1];
      note that it is different from that in [X509-4th].

      All Certificates MUST conform to [RFC5280].  (This should be
      interpreted as a requirement to encode only PKIX-conformant
      certificates using this type.  It does not necessarily require



Eastlake                     Standards Track                   [Page 17]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


      that all certificates that are not strictly PKIX-conformant must
      be rejected by relying parties, although the security consequences
      of accepting any such certificates should be considered
      carefully.)

      DER (as opposed to BER) encoding MUST be used.  If this type is
      sent over a 7-bit transport, base64 encoding SHOULD be used.

   Security considerations:
      The security considerations of [X509-4th] and [RFC5280] (or any
      updates to them) apply, as well as those of any protocol that uses
      this type (e.g., TLS).

      Note that this type only specifies a certificate chain that can be
      assessed for validity according to the relying party's existing
      configuration of trusted CAs; it is not intended to be used to
      specify any change to that configuration.

   Interoperability considerations:
      No specific interoperability problems are known with this type,
      but for recommendations relating to X.509 certificates in general,
      see [RFC5280].

   Published specification: This document and [RFC5280].

   Applications that use this media type:
      TLS.  It may also be used by other protocols or for general
      interchange of PKIX certificate chains.

   Additional information:
      Magic number(s): DER-encoded ASN.1 can be easily recognized.
        Further parsing is required to distinguish it from other ASN.1
        types.
      File extension(s): .pkipath
      Macintosh File Type Code(s): not specified

   Person & email address to contact for further information:
      Magnus Nystrom <mnystrom@microsoft.com>

   Intended usage: COMMON

   Change controller: IESG <iesg@ietf.org>









Eastlake                     Standards Track                   [Page 18]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


10.2.  Reference for TLS Alerts, TLS HandshakeTypes, and ExtensionTypes

   The following values in the TLS Alert Registry have been updated to
   reference this document:

      111 certificate_unobtainable
      112 unrecognized_name
      113 bad_certificate_status_response
      114 bad_certificate_hash_value

   The following values in the TLS HandshakeType Registry have been
   updated to reference this document:

      21 certificate_url
      22 certificate_status

   The following ExtensionType values have been updated to reference
   this document:

      0 server_name
      1 max_fragment_length
      2 client_certificate_url
      3 trusted_ca_keys
      4 truncated_hmac
      5 status_request

11.  Security Considerations

   General security considerations for TLS extensions are covered in
   [RFC5246].  Security Considerations for particular extensions
   specified in this document are given below.

   In general, implementers should continue to monitor the state of the
   art and address any weaknesses identified.

11.1.  Security Considerations for server_name

   If a single server hosts several domains, then clearly it is
   necessary for the owners of each domain to ensure that this satisfies
   their security needs.  Apart from this, server_name does not appear
   to introduce significant security issues.

   Since it is possible for a client to present a different server_name
   in the application protocol, application server implementations that
   rely upon these names being the same MUST check to make sure the
   client did not present a different name in the application protocol.





Eastlake                     Standards Track                   [Page 19]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   Implementations MUST ensure that a buffer overflow does not occur,
   whatever the values of the length fields in server_name.

11.2.  Security Considerations for max_fragment_length

   The maximum fragment length takes effect immediately, including for
   handshake messages.  However, that does not introduce any security
   complications that are not already present in TLS, since TLS requires
   implementations to be able to handle fragmented handshake messages.

   Note that, as described in Section 4, once a non-null cipher suite
   has been activated, the effective maximum fragment length depends on
   the cipher suite and compression method, as well as on the negotiated
   max_fragment_length.  This must be taken into account when sizing
   buffers and checking for buffer overflow.

11.3.  Security Considerations for client_certificate_url

   Support for client_certificate_url involves the server's acting as a
   client in another URI-scheme-dependent protocol.  The server
   therefore becomes subject to many of the same security concerns that
   clients of the URI scheme are subject to, with the added concern that
   the client can attempt to prompt the server to connect to some
   (possibly weird-looking) URL.

   In general, this issue means that an attacker might use the server to
   indirectly attack another host that is vulnerable to some security
   flaw.  It also introduces the possibility of denial-of-service
   attacks in which an attacker makes many connections to the server,
   each of which results in the server's attempting a connection to the
   target of the attack.

   Note that the server may be behind a firewall or otherwise able to
   access hosts that would not be directly accessible from the public
   Internet.  This could exacerbate the potential security and denial-
   of-service problems described above, as well as allow the existence
   of internal hosts to be confirmed when they would otherwise be
   hidden.

   The detailed security concerns involved will depend on the URI
   schemes supported by the server.  In the case of HTTP, the concerns
   are similar to those that apply to a publicly accessible HTTP proxy
   server.  In the case of HTTPS, loops and deadlocks may be created,
   and this should be addressed.  In the case of FTP, attacks arise that
   are similar to FTP bounce attacks.






Eastlake                     Standards Track                   [Page 20]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   As a result of this issue, it is RECOMMENDED that the
   client_certificate_url extension should have to be specifically
   enabled by a server administrator, rather than be enabled by default.
   It is also RECOMMENDED that URI schemes be enabled by the
   administrator individually, and only a minimal set of schemes be
   enabled.  Unusual protocols that offer limited security or whose
   security is not well understood SHOULD be avoided.

   As discussed in [RFC3986], URLs that specify ports other than the
   default may cause problems, as may very long URLs (which are more
   likely to be useful in exploiting buffer overflow bugs).

   This extension continues to use SHA-1 (as in RFC 4366) and does not
   provide algorithm agility.  The property required of SHA-1 in this
   case is second pre-image resistance, not collision resistance.
   Furthermore, even if second pre-image attacks against SHA-1 are found
   in the future, an attack against client_certificate_url would require
   a second pre-image that is accepted as a valid certificate by the
   server and contains the same public key.

   Also note that HTTP caching proxies are common on the Internet, and
   some proxies do not check for the latest version of an object
   correctly.  If a request using HTTP (or another caching protocol)
   goes through a misconfigured or otherwise broken proxy, the proxy may
   return an out-of-date response.

11.4.  Security Considerations for trusted_ca_keys

   Potentially, the CA root keys a client possesses could be regarded as
   confidential information.  As a result, the CA root key indication
   extension should be used with care.

   The use of the SHA-1 certificate hash alternative ensures that each
   certificate is specified unambiguously.  This context does not
   require a cryptographic hash function, so the use of SHA-1 is
   considered acceptable, and no algorithm agility is provided.

11.5.  Security Considerations for truncated_hmac

   It is possible that truncated MACs are weaker than "un-truncated"
   MACs.  However, no significant weaknesses are currently known or
   expected to exist for HMAC with MD5 or SHA-1, truncated to 80 bits.

   Note that the output length of a MAC need not be as long as the
   length of a symmetric cipher key, since forging of MAC values cannot
   be done off-line: in TLS, a single failed MAC guess will cause the
   immediate termination of the TLS session.




Eastlake                     Standards Track                   [Page 21]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   Since the MAC algorithm only takes effect after all handshake
   messages that affect extension parameters have been authenticated by
   the hashes in the Finished messages, it is not possible for an active
   attacker to force negotiation of the truncated HMAC extension where
   it would not otherwise be used (to the extent that the handshake
   authentication is secure).  Therefore, in the event that any security
   problems were found with truncated HMAC in the future, if either the
   client or the server for a given session were updated to take the
   problem into account, it would be able to veto use of this extension.

11.6.  Security Considerations for status_request

   If a client requests an OCSP response, it must take into account that
   an attacker's server using a compromised key could (and probably
   would) pretend not to support the extension.  In this case, a client
   that requires OCSP validation of certificates SHOULD either contact
   the OCSP server directly or abort the handshake.

   Use of the OCSP nonce request extension (id-pkix-ocsp-nonce) may
   improve security against attacks that attempt to replay OCSP
   responses; see Section 4.4.1 of [RFC2560] for further details.

12.  Normative References

   [RFC2104]      Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
                  Keyed-Hashing for Message Authentication", RFC 2104,
                  February 1997.

   [RFC2119]      Bradner, S., "Key words for use in RFCs to Indicate
                  Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2560]      Myers, M., Ankney, R., Malpani, A., Galperin, S., and
                  C. Adams, "X.509 Internet Public Key Infrastructure
                  Online Certificate Status Protocol - OCSP", RFC 2560,
                  June 1999.

   [RFC2585]      Housley, R. and P. Hoffman, "Internet X.509 Public Key
                  Infrastructure Operational Protocols: FTP and HTTP",
                  RFC 2585, May 1999.

   [RFC2616]      Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                  Masinter, L., Leach, P., and T. Berners-Lee,
                  "Hypertext Transfer Protocol -- HTTP/1.1", RFC 2616,
                  June 1999.

   [RFC3986]      Berners-Lee, T., Fielding, R., and L. Masinter,
                  "Uniform Resource Identifier (URI): Generic Syntax",
                  STD 66, RFC 3986, January 2005.



Eastlake                     Standards Track                   [Page 22]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


   [RFC5246]      Dierks, T. and E. Rescorla, "The Transport Layer
                  Security (TLS) Protocol Version 1.2", RFC 5246, August
                  2008.

   [RFC5280]      Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
                  Housley, R., and W. Polk, "Internet X.509 Public Key
                  Infrastructure Certificate and Certificate Revocation
                  List (CRL) Profile", RFC 5280, May 2008.

   [RFC5890]      Klensin, J., "Internationalized Domain Names for
                  Applications (IDNA): Definitions and Document
                  Framework", RFC 5890, August 2010.

13.  Informative References

   [RFC2712]      Medvinsky, A. and M. Hur, "Addition of Kerberos Cipher
                  Suites to Transport Layer Security (TLS)", RFC 2712,
                  October 1999.

   [X509-4th]     ITU-T Recommendation X.509 (2000) | ISO/IEC
                  9594-8:2001, "Information Systems - Open Systems
                  Interconnection - The Directory: Public key and
                  attribute certificate frameworks".

   [X509-4th-TC1] ITU-T Recommendation X.509(2000) Corrigendum 1(2001) |
                  ISO/IEC 9594-8:2001/Cor.1:2002, Technical Corrigendum
                  1 to ISO/IEC 9594:8:2001.
























Eastlake                     Standards Track                   [Page 23]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


Appendix A.  Changes from RFC 4366

   The significant changes between RFC 4366 and this document are
   described below.

   RFC 4366 described both general extension mechanisms (for the TLS
   handshake and client and server hellos) as well as specific
   extensions.  RFC 4366 was associated with RFC 4346, TLS 1.1.  The
   client and server hello extension mechanisms have been moved into RFC
   5246, TLS 1.2, so this document, which is associated with RFC 5246,
   includes only the handshake extension mechanisms and the specific
   extensions from RFC 4366.  RFC 5246 also specifies the unknown
   extension error and new extension specification considerations, so
   that material has been removed from this document.

   The Server Name extension now specifies only ASCII representation,
   eliminating UTF-8.  It is provided that the ServerNameList can
   contain more than only one name of any particular name_type.  If a
   server name is provided but not recognized, the server should either
   continue the handshake without an error or send a fatal error.
   Sending a warning-level message is not recommended because client
   behavior will be unpredictable.  Provision was added for the user
   using the server_name extension in deciding whether or not to resume
   a session.  Furthermore, this extension should be the same in a
   session resumption request as it was in the full handshake that
   established the session.  Such a resumption request must not be
   accepted if the server_name extension is different, but instead a
   full handshake must be done to possibly establish a new session.

   The Client Certificate URLs extension has been changed to make the
   presence of a hash mandatory.

   For the case of DTLS, the requirement to report an overflow of the
   negotiated maximum fragment length is made conditional on passing
   authentication.

   TLS servers are now prohibited from following HTTP redirects when
   retrieving certificates.

   The material was also re-organized in minor ways.  For example,
   information as to which errors are fatal is moved from the "Error
   Alerts" section to the individual extension specifications.









Eastlake                     Standards Track                   [Page 24]
   __________________________________________________________________


RFC 6066                TLS Extension Definitions           January 2011


Appendix B.  Acknowledgements

   This document is based on material from RFC 4366 for which the
   authors were S. Blake-Wilson, M. Nystrom, D. Hopwood, J. Mikkelsen,
   and T. Wright.  Other contributors include Joseph Salowey, Alexey
   Melnikov, Peter Saint-Andre, and Adrian Farrel.

Author's Address

   Donald Eastlake 3rd
   Huawei
   155 Beaver Street
   Milford, MA 01757 USA

   Phone: +1-508-333-2270
   EMail: d3e3e3@gmail.com



































Eastlake                     Standards Track                   [Page 25]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2] [IPR]
   [Errata]
   Obsoleted by: 8446 PROPOSED STANDARD
   Errata Exist
Internet Engineering Task Force (IETF)                      Y. Pettersen
Request for Comments: 6961                                     June 2013
Category: Standards Track
ISSN: 2070-1721


                   The Transport Layer Security (TLS)
             Multiple Certificate Status Request Extension

Abstract

   This document defines the Transport Layer Security (TLS) Certificate
   Status Version 2 Extension to allow clients to specify and support
   several certificate status methods.  (The use of the Certificate
   Status extension is commonly referred to as "OCSP stapling".)  Also
   defined is a new method based on the Online Certificate Status
   Protocol (OCSP) that servers can use to provide status information
   about not only the server's own certificate but also the status of
   intermediate certificates in the chain.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc6961.


















Pettersen                    Standards Track                    [Page 1]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

1.  Introduction

   The Transport Layer Security (TLS) Extension [RFC6066] framework
   defines, among other extensions, the Certificate Status extension
   (also referred to as "OCSP stapling") that clients can use to request
   the server's copy of the current status of its certificate.  The
   benefits of this extension include a reduced number of roundtrips and
   network delays for the client to verify the status of the server's
   certificate and a reduced load on the certificate issuer's status
   response servers, thus solving a problem that can become significant
   when the issued certificate is presented by a frequently visited
   server.

   There are two problems with the existing Certificate Status
   extension.  First, it does not provide functionality to request the
   status information about intermediate Certification Authority (CA)
   certificates, which means the client has to request status
   information through other methods, such as Certificate Revocation
   Lists (CRLs), introducing further delays.  Second, the current format
   of the extension and requirements in the TLS protocol prevent a
   client from offering the server multiple status methods.



Pettersen                    Standards Track                    [Page 2]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


   Many CAs are now issuing intermediate CA certificates that not only
   specify the publication point for their CRLs in a CRL Distribution
   Point [RFC5280] but also specify a URL for their OCSP [RFC6960]
   server in Authority Information Access [RFC5280].  Given that
   client-cached CRLs are frequently out of date, clients would benefit
   from using OCSP to access up-to-date status information about
   intermediate CA certificates.  The benefit to the issuing CA is less
   clear, as providing the bandwidth for the OCSP responder can be
   costly, especially for CAs with many high-traffic subscriber sites,
   and this cost is a concern for many CAs.  There are cases where OCSP
   requests for a single high-traffic site caused significant network
   problems for the issuing CA.

   Clients will benefit from the TLS server providing certificate status
   information regardless of type, not just for the server certificate
   but also for the intermediate CA certificates.  Combining the status
   checks into one extension will reduce the roundtrips needed to
   complete the handshake by the client to just those needed for
   negotiating the TLS connection.  Also, for the Certification
   Authorities, the load on their servers will depend on the number of
   certificates they have issued, not on the number of visitors to those
   sites.  Additionally, using this extension significantly reduces
   privacy concerns around the clients informing the certificate issuer
   about which sites they are visiting.

   For such a new system to be introduced seamlessly, clients need to be
   able to indicate support for the existing OCSP Certificate Status
   method and a new multiple-OCSP mode.

   Unfortunately, the definition of the Certificate Status extension
   only allows a single Certificate Status extension to be defined in a
   single extension record in the handshake, and the TLS protocol
   [RFC5246] only allows a single record in the extension list for any
   given extension.  This means that it is not possible for clients to
   indicate support for new methods while still supporting older
   methods, which would cause problems for interoperability between
   newer clients and older servers.  This will not just be an issue for
   the multiple status request mode proposed above but also for any
   other future status methods that might be introduced.  This will be
   true not just for the current PKIX infrastructure [RFC5280] but also
   for alternative PKI structures.

   The solution to this problem is to define a new extension,
   "status_request_v2", with an extended format that allows the client
   to indicate support for multiple status request methods.  This is
   implemented using a list of CertificateStatusRequestItemV2 records in
   the extension record.  As the server will select the single status




Pettersen                    Standards Track                    [Page 3]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


   method based on the selected cipher suite and the certificate
   presented, no significant changes are needed in the server's
   extension format.

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

1.2.  Presentation Language

   This document defines protocol structures using the same conventions
   and presentation language as defined in Section 4 of [RFC5246].

2.  Multiple Certificate Status Extension

2.1.  New Extension

   The extension defined by this document is indicated by
   "status_request_v2" in the ExtensionType enum (originally defined by
   [RFC6066]), which uses the following value:

     enum {
       status_request_v2(17), (65535)
     } ExtensionType;

2.2.  Multiple Certificate Status Request Record

   Clients that support a certificate status protocol like OCSP may send
   the "status_request_v2" extension to the server in order to use the
   TLS handshake to transfer such data instead of downloading it through
   separate connections.  When using this extension, the
   "extension_data" field (defined in Section 7.4.1.4 of [RFC5246]) of
   the extension SHALL contain a CertificateStatusRequestListV2 where:

     struct {
       CertificateStatusType status_type;
       uint16 request_length; /* Length of request field in bytes */
       select (status_type) {
         case ocsp: OCSPStatusRequest;
         case ocsp_multi: OCSPStatusRequest;
       } request;
     } CertificateStatusRequestItemV2;

     enum { ocsp(1), ocsp_multi(2), (255) } CertificateStatusType;





Pettersen                    Standards Track                    [Page 4]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


     struct {
       ResponderID responder_id_list<0..2^16-1>;
       Extensions request_extensions;
     } OCSPStatusRequest;

     opaque ResponderID<1..2^16-1>;
     opaque Extensions<0..2^16-1>;

     struct {
       CertificateStatusRequestItemV2
                        certificate_status_req_list<1..2^16-1>;
     } CertificateStatusRequestListV2;

   In the OCSPStatusRequest (originally defined by [RFC6066]), the
   "ResponderID" provides a list of OCSP responders that the client
   trusts.  A zero-length "responder_id_list" sequence has the special
   meaning that the responders are implicitly known to the server, e.g.,
   by prior arrangement, or are identified by the certificates used by
   the server.  "Extensions" is a DER encoding [X.690] of the OCSP
   request extensions, and if the server supports the forwarding of OCSP
   request extensions, this value MUST be forwarded without
   modification.

   Both "ResponderID" and "Extensions" are DER-encoded ASN.1 types as
   defined in [RFC6960].  "Extensions" is imported from [RFC5280].  A
   zero-length "request_extensions" value means that there are no
   extensions (as opposed to a DER-encoded zero-length ASN.1 SEQUENCE,
   which is not valid for the "Extensions" type).

   Servers that support a client's selection of responders using the
   ResponderID field could implement this selection by matching the
   responder ID values from the client's list with the ResponderIDs of
   known OCSP responders, either by using a binary compare of the values
   or a hash calculation and compare method.

   In the case of the "id-pkix-ocsp-nonce" OCSP extension, [RFC2560] is
   unclear about its encoding; for clarification, the nonce MUST be a
   DER-encoded OCTET STRING, which is encapsulated as another OCTET
   STRING (note that implementations based on an existing OCSP client
   will need to be checked for conformance to this requirement).  This
   has been clarified in [RFC6960].

   The items in the list of CertificateStatusRequestItemV2 entries are
   ordered according to the client's preference (favorite choice first).

   A server that receives a client hello containing the
   "status_request_v2" extension MAY return a suitable certificate
   status response message to the client along with the server's



Pettersen                    Standards Track                    [Page 5]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


   certificate message.  If OCSP is requested, it SHOULD use the
   information contained in the extension when selecting an OCSP
   responder and SHOULD include request_extensions in the OCSP request.

   The server returns a certificate status response along with its
   certificate by sending a "CertificateStatus" message (originally
   defined by [RFC6066]) immediately after the "Certificate" message
   (Section 7.4.2 of [RFC5246]) (and before any "ServerKeyExchange" or
   "CertificateRequest" messages).  If a server returns a
   "CertificateStatus" message in response to a "status_request_v2"
   request, then the server MUST have included an extension of type
   "status_request_v2" with empty "extension_data" in the extended
   server hello.

   The "CertificateStatus" message is conveyed using the handshake
   message type "certificate_status" (defined in [RFC6066]) as follows
   (updated from the definition in [RFC6066]):

     struct {
       CertificateStatusType status_type;
       select (status_type) {
         case ocsp: OCSPResponse;
         case ocsp_multi: OCSPResponseList;
       } response;
     } CertificateStatus;

     opaque OCSPResponse<0..2^24-1>;

     struct {
       OCSPResponse ocsp_response_list<1..2^24-1>;
     } OCSPResponseList;

   An "OCSPResponse" element (originally defined by [RFC6066]) contains
   a complete, DER-encoded OCSP response (using the ASN.1 [X.680] type
   OCSPResponse defined in [RFC6960]).  Only one OCSP response, with a
   length of at least one byte, may be sent for status_type "ocsp".

   An "ocsp_response_list" contains a list of "OCSPResponse" elements,
   as specified above, each containing the OCSP response for the
   matching corresponding certificate in the server's Certificate TLS
   handshake message.  That is, the first entry is the OCSP response for
   the first certificate in the Certificate list, the second entry is
   the response for the second certificate, and so on.  The list MAY
   contain fewer OCSP responses than there were certificates in the
   Certificate handshake message, but there MUST NOT be more responses
   than there were certificates in the list.  Individual elements of the
   list MAY have a length of 0 (zero) bytes if the server does not have
   the OCSP response for that particular certificate stored, in which



Pettersen                    Standards Track                    [Page 6]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


   case the client MUST act as if a response was not received for that
   particular certificate.  If the client receives a
   "ocsp_response_list" that does not contain a response for one or more
   of the certificates in the completed certificate chain, the client
   SHOULD attempt to validate the certificate using an alternative
   retrieval method, such as downloading the relevant CRL; OCSP SHOULD
   in this situation only be used for the end-entity certificate, not
   intermediate CA certificates, for reasons stated above.

   Note that a server MAY also choose not to send a "CertificateStatus"
   message, even if it has received a "status_request_v2" extension in
   the client hello message and has sent a "status_request_v2" extension
   in the server hello message.  Additionally, note that a server MUST
   NOT send the "CertificateStatus" message unless it received either a
   "status_request" or "status_request_v2" extension in the client hello
   message and sent a corresponding "status_request" or
   "status_request_v2" extension in the server hello message.

   Clients requesting an OCSP response and receiving one or more OCSP
   responses in a "CertificateStatus" message MUST check the OCSP
   response(s) and abort the handshake if the response is a "revoked"
   status or other unacceptable responses (as determined by client
   policy) with a bad_certificate_status_response(113) alert.  This
   alert is always fatal.

   If the OCSP response received from the server does not result in a
   definite "good" or "revoked" status, it is inconclusive.  A TLS
   client in such a case MAY check the validity of the server
   certificate through other means, e.g., by directly querying the
   certificate issuer.  If such processing still results in an
   inconclusive response, then the application using the TLS connection
   will have to decide whether to close the connection or not.  Note
   that this problem cannot be decided by the generic TLS client code
   without information from the application.  If the application doesn't
   provide any such information, then the client MUST abort the
   connection, since the server certificate has not been sufficiently
   validated.

   An example of where the application might wish to continue is with
   EAP-TLS (Extensible Authentication Protocol - TLS), where the
   application can use another mechanism to check the status of a
   certificate once it obtains network access.  In this case, the
   application could have the client continue with the handshake, but it
   MUST NOT disclose a username and password until it has fully
   validated the server certificate.






Pettersen                    Standards Track                    [Page 7]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


3.  IANA Considerations

   Section 2.1 defines the new TLS extension status_request_v2 (17)
   enum, which has been added to the "ExtensionType Values" list in the
   IANA "Transport Layer Security (TLS) Extensions" registry.

   Section 2.2 describes a TLS CertificateStatusType registry that is
   now maintained by IANA.  The "TLS Certificate Status Types" registry
   has been created under the "Transport Layer Security (TLS)
   Extensions" registry.  CertificateStatusType values are to be
   assigned via IETF Review as defined in [RFC5226].  The initial
   registry corresponds to the definition of "CertificateStatusType" in
   Section 2.2.

   Value   Description   Reference
   -----------------------------------------
   0       Reserved      [RFC6961]
   1       ocsp          [RFC6066] [RFC6961]
   2       ocsp_multi    [RFC6961]
   3-255   Unassigned

4.  Security Considerations

   General security considerations for TLS extensions are covered in
   [RFC5246].  Security considerations for the particular extension
   specified in this document are given below.  In general, implementers
   should continue to monitor the state of the art and address any
   weaknesses identified.

4.1.  Security Considerations for status_request_v2

   If a client requests an OCSP response, it must take into account that
   an attacker's server using a compromised key could (and probably
   would) pretend not to support the extension.  In this case, a client
   that requires OCSP validation of certificates SHOULD either contact
   the OCSP server directly or abort the handshake.

   Use of the OCSP nonce request extension (id-pkix-ocsp-nonce) may
   improve security against attacks that attempt to replay OCSP
   responses; see Section 4.4.1 of [RFC6960] for further details.

   This extension allows the client to send arbitrary data to the
   server.  The server implementers need to handle such data carefully
   to avoid introducing security vulnerabilities.

   The security considerations of [RFC6960] apply to OCSP requests and
   responses.




Pettersen                    Standards Track                    [Page 8]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


5.  Acknowledgements

   This document is based on [RFC6066], authored by Donald Eastlake 3rd.

6.  References

6.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC6066]  Eastlake, D., "Transport Layer Security (TLS) Extensions:
              Extension Definitions", RFC 6066, January 2011.

   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,
              Galperin, S., and C. Adams, "X.509 Internet Public Key
              Infrastructure Online Certificate Status Protocol - OCSP",
              RFC 6960, June 2013.

   [X.680]    ITU-T Recommendation X.680 (2008) | ISO/IEC 8824-1:2008,
              "Abstract Syntax Notation One (ASN.1): Specification of
              basic notation", November 2008.

   [X.690]    ITU-T Recommendation X.690 (2008) | ISO/IEC 8825-1:2008,
              "ASN.1 encoding rules: Specification of Basic Encoding
              Rules (BER), Canonical Encoding Rules (CER) and
              Distinguished Encoding Rules (DER)", November 2008.

6.2.  Informative References

   [RFC2560]  Myers, M., Ankney, R., Malpani, A., Galperin, S., and C.
              Adams, "X.509 Internet Public Key Infrastructure Online
              Certificate Status Protocol - OCSP", RFC 2560, June 1999.






Pettersen                    Standards Track                    [Page 9]
   __________________________________________________________________


RFC 6961          Multiple Certificate Status Extension        June 2013


Author's Address

   Yngve N. Pettersen

   EMail: yngve@spec-work.net














































Pettersen                    Standards Track                   [Page 10]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2]
   [Errata]
   PROPOSED STANDARD
   Errata Exist
Internet Engineering Task Force (IETF)                   P. Wouters, Ed.
Request for Comments: 7250                                       Red Hat
Category: Standards Track                             H. Tschofenig, Ed.
ISSN: 2070-1721                                                 ARM Ltd.
                                                              J. Gilmore
                                          Electronic Frontier Foundation
                                                               S. Weiler
                                                                 Parsons
                                                              T. Kivinen
                                                           INSIDE Secure
                                                               June 2014


        Using Raw Public Keys in Transport Layer Security (TLS)
              and Datagram Transport Layer Security (DTLS)

Abstract

   This document specifies a new certificate type and two TLS extensions
   for exchanging raw public keys in Transport Layer Security (TLS) and
   Datagram Transport Layer Security (DTLS).  The new certificate type
   allows raw public keys to be used for authentication.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc7250.















Wouters, et al.              Standards Track                    [Page 1]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4
   3.  Structure of the Raw Public Key Extension . . . . . . . . . .   4
   4.  TLS Client and Server Handshake Behavior  . . . . . . . . . .   7
     4.1.  Client Hello  . . . . . . . . . . . . . . . . . . . . . .   7
     4.2.  Server Hello  . . . . . . . . . . . . . . . . . . . . . .   8
     4.3.  Client Authentication . . . . . . . . . . . . . . . . . .   9
     4.4.  Server Authentication . . . . . . . . . . . . . . . . . .   9
   5.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  10
     5.1.  TLS Server Uses a Raw Public Key  . . . . . . . . . . . .  10
     5.2.  TLS Client and Server Use Raw Public Keys . . . . . . . .  11
     5.3.  Combined Usage of Raw Public Keys and X.509 Certificates   12
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  13
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  14
   8.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  14
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  15
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  15
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  15
   Appendix A.  Example Encoding . . . . . . . . . . . . . . . . . .  17















Wouters, et al.              Standards Track                    [Page 2]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


1.  Introduction

   Traditionally, TLS client and server public keys are obtained in PKIX
   containers in-band as part of the TLS handshake procedure and are
   validated using trust anchors based on a [PKIX] certification
   authority (CA).  This method can add a complicated trust relationship
   that is difficult to validate.  Examples of such complexity can be
   seen in [Defeating-SSL].  TLS is, however, also commonly used with
   self-signed certificates in smaller deployments where the self-signed
   certificates are distributed to all involved protocol endpoints out-
   of-band.  This practice does, however, still require the overhead of
   the certificate generation even though none of the information found
   in the certificate is actually used.

   Alternative methods are available that allow a TLS client/server to
   obtain the TLS server/client public key:

   o  The TLS client can obtain the TLS server public key from a DNSSEC-
      secured resource record using DNS-Based Authentication of Named
      Entities (DANE) [RFC6698].

   o  The TLS client or server public key is obtained from a [PKIX]
      certificate chain from a Lightweight Directory Access Protocol
      [LDAP] server or web page.

   o  The TLS client and server public key is provisioned into the
      operating system firmware image and updated via software updates.
      For example:

      Some smart objects use the UDP-based Constrained Application
      Protocol [CoAP] to interact with a Web server to upload sensor
      data at regular intervals, such as temperature readings.  CoAP can
      utilize DTLS for securing the client-to-server communication.  As
      part of the manufacturing process, the embedded device may be
      configured with the address and the public key of a dedicated CoAP
      server, as well as a public/private key pair for the client
      itself.

   This document introduces the use of raw public keys in TLS/DTLS.
   With raw public keys, only a subset of the information found in
   typical certificates is utilized: namely, the SubjectPublicKeyInfo
   structure of a PKIX certificate that carries the parameters necessary
   to describe the public key.  Other parameters found in PKIX
   certificates are omitted.  By omitting various certificate-related
   structures, the resulting raw public key is kept fairly small in
   comparison to the original certificate, and the code to process the
   keys can be simpler.  Only a minimalistic ASN.1 parser is needed;
   code for certificate path validation and other PKIX-related



Wouters, et al.              Standards Track                    [Page 3]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   processing is not required.  Note, however, the SubjectPublicKeyInfo
   structure is still in an ASN.1 format.  To further reduce the size of
   the exchanged information, this specification can be combined with
   the TLS Cached Info extension [CACHED-INFO], which enables TLS peers
   to exchange just fingerprints of their public keys.

   The mechanism defined herein only provides authentication when an
   out-of-band mechanism is also used to bind the public key to the
   entity presenting the key.

   Section 3 defines the structure of the two new TLS extensions,
   client_certificate_type and server_certificate_type, which can be
   used as part of an extended TLS handshake when raw public keys are to
   be used.  Section 4 defines the behavior of the TLS client and the
   TLS server.  Example exchanges are described in Section 5.  Section 6
   describes security considerations with this approach.  Finally, in
   Section 7 this document registers a new value to the IANA "TLS
   Certificate Types" subregistry for the support of raw public keys.

2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

   We use the terms "TLS server" and "server" as well as "TLS client"
   and "client" interchangeably.

3.  Structure of the Raw Public Key Extension

   This section defines the two TLS extensions client_certificate_type
   and server_certificate_type, which can be used as part of an extended
   TLS handshake when raw public keys are used.  Section 4 defines the
   behavior of the TLS client and the TLS server using these extensions.

   This specification uses raw public keys whereby the already available
   encoding used in a PKIX certificate in the form of a
   SubjectPublicKeyInfo structure is reused.  To carry the raw public
   key within the TLS handshake, the Certificate payload is used as a
   container, as shown in Figure 1.  The shown Certificate structure is
   an adaptation of its original form [RFC5246].










Wouters, et al.              Standards Track                    [Page 4]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   opaque ASN.1Cert<1..2^24-1>;

   struct {
       select(certificate_type){

            // certificate type defined in this document.
            case RawPublicKey:
              opaque ASN.1_subjectPublicKeyInfo<1..2^24-1>;

           // X.509 certificate defined in RFC 5246
           case X.509:
             ASN.1Cert certificate_list<0..2^24-1>;

           // Additional certificate type based on
           // "TLS Certificate Types" subregistry
       };
   } Certificate;

    Figure 1: Certificate Payload as a Container for the Raw Public Key

   The SubjectPublicKeyInfo structure is defined in Section 4.1 of RFC
   5280 [PKIX] and not only contains the raw keys, such as the public
   exponent and the modulus of an RSA public key, but also an algorithm
   identifier.  The algorithm identifier can also include parameters.
   The SubjectPublicKeyInfo value in the Certificate payload MUST
   contain the DER encoding [X.690] of the SubjectPublicKeyInfo.  The
   structure, as shown in Figure 2, therefore also contains length
   information.  An example is provided in Appendix A.

      SubjectPublicKeyInfo  ::=  SEQUENCE  {
           algorithm               AlgorithmIdentifier,
           subjectPublicKey        BIT STRING  }

      AlgorithmIdentifier   ::=  SEQUENCE  {
           algorithm               OBJECT IDENTIFIER,
           parameters              ANY DEFINED BY algorithm OPTIONAL  }

              Figure 2: SubjectPublicKeyInfo ASN.1 Structure

   The algorithm identifiers are Object Identifiers (OIDs).  RFC 3279
   [RFC3279] and RFC 5480 [RFC5480], for example, define the OIDs shown
   in Figure 3.  Note that this list is not exhaustive, and more OIDs
   may be defined in future RFCs.








Wouters, et al.              Standards Track                    [Page 5]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   Key Type            | Document                   | OID
   --------------------+----------------------------+-------------------
   RSA                 | Section 2.3.1 of RFC 3279  | 1.2.840.113549.1.1
   ....................|............................|...................
   Digital Signature   |                            |
   Algorithm (DSA)     | Section 2.3.2 of RFC 3279  | 1.2.840.10040.4.1
   ....................|............................|...................
   Elliptic Curve      |                            |
   Digital Signature   |                            |
   Algorithm (ECDSA)   | Section 2 of RFC 5480      | 1.2.840.10045.2.1
   --------------------+----------------------------+-------------------

              Figure 3: Example Algorithm Object Identifiers

   The extension format for extended client and server hellos, which
   uses the "extension_data" field, is used to carry the
   ClientCertTypeExtension and the ServerCertTypeExtension structures.
   These two structures are shown in Figure 4.  The CertificateType
   structure is an enum with values taken from the "TLS Certificate
   Types" subregistry of the "Transport Layer Security (TLS) Extensions"
   registry [TLS-Ext-Registry].

   struct {
           select(ClientOrServerExtension) {
               case client:
                 CertificateType client_certificate_types<1..2^8-1>;
               case server:
                 CertificateType client_certificate_type;
           }
   } ClientCertTypeExtension;

   struct {
           select(ClientOrServerExtension) {
               case client:
                 CertificateType server_certificate_types<1..2^8-1>;
               case server:
                 CertificateType server_certificate_type;
           }
   } ServerCertTypeExtension;

                   Figure 4: CertTypeExtension Structure










Wouters, et al.              Standards Track                    [Page 6]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


4.  TLS Client and Server Handshake Behavior

   This specification extends the ClientHello and the ServerHello
   messages, according to the extension procedures defined in [RFC5246].
   It does not extend or modify any other TLS message.

   Note: No new cipher suites are required to use raw public keys.  All
   existing cipher suites that support a key exchange method compatible
   with the defined extension can be used.

   The high-level message exchange in Figure 5 shows the
   client_certificate_type and server_certificate_type extensions added
   to the client and server hello messages.

    client_hello,
    client_certificate_type,
    server_certificate_type   ->

                              <-  server_hello,
                                  client_certificate_type,
                                  server_certificate_type,
                                  certificate,
                                  server_key_exchange,
                                  certificate_request,
                                  server_hello_done
    certificate,
    client_key_exchange,
    certificate_verify,
    change_cipher_spec,
    finished                  ->

                              <- change_cipher_spec,
                                 finished

   Application Data        <------->     Application Data

                Figure 5: Basic Raw Public Key TLS Exchange

4.1.  Client Hello

   In order to indicate the support of raw public keys, clients include
   the client_certificate_type and/or the server_certificate_type
   extensions in an extended client hello message.  The hello extension
   mechanism is described in Section 7.4.1.4 of TLS 1.2 [RFC5246].

   The client_certificate_type extension in the client hello indicates
   the certificate types the client is able to provide to the server,
   when requested using a certificate_request message.



Wouters, et al.              Standards Track                    [Page 7]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   The server_certificate_type extension in the client hello indicates
   the types of certificates the client is able to process when provided
   by the server in a subsequent certificate payload.

   The client_certificate_type and server_certificate_type extensions
   sent in the client hello each carry a list of supported certificate
   types, sorted by client preference.  When the client supports only
   one certificate type, it is a list containing a single element.

   The TLS client MUST omit certificate types from the
   client_certificate_type extension in the client hello if it does not
   possess the corresponding raw public key or certificate that it can
   provide to the server when requested using a certificate_request
   message, or if it is not configured to use one with the given TLS
   server.  If the client has no remaining certificate types to send in
   the client hello, other than the default X.509 type, it MUST omit the
   client_certificate_type extension in the client hello.

   The TLS client MUST omit certificate types from the
   server_certificate_type extension in the client hello if it is unable
   to process the corresponding raw public key or other certificate
   type.  If the client has no remaining certificate types to send in
   the client hello, other than the default X.509 certificate type, it
   MUST omit the entire server_certificate_type extension from the
   client hello.

4.2.  Server Hello

   If the server receives a client hello that contains the
   client_certificate_type extension and/or the server_certificate_type
   extension, then three outcomes are possible:

   1.  The server does not support the extension defined in this
       document.  In this case, the server returns the server hello
       without the extensions defined in this document.

   2.  The server supports the extension defined in this document, but
       it does not have any certificate type in common with the client.
       Then, the server terminates the session with a fatal alert of
       type "unsupported_certificate".

   3.  The server supports the extensions defined in this document and
       has at least one certificate type in common with the client.  In
       this case, the processing rules described below are followed.

   The client_certificate_type extension in the client hello indicates
   the certificate types the client is able to provide to the server,
   when requested using a certificate_request message.  If the TLS



Wouters, et al.              Standards Track                    [Page 8]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   server wants to request a certificate from the client (via the
   certificate_request message), it MUST include the
   client_certificate_type extension in the server hello.  This
   client_certificate_type extension in the server hello then indicates
   the type of certificates the client is requested to provide in a
   subsequent certificate payload.  The value conveyed in the
   client_certificate_type extension MUST be selected from one of the
   values provided in the client_certificate_type extension sent in the
   client hello.  The server MUST also include a certificate_request
   payload in the server hello message.

   If the server does not send a certificate_request payload (for
   example, because client authentication happens at the application
   layer or no client authentication is required) or none of the
   certificates supported by the client (as indicated in the
   client_certificate_type extension in the client hello) match the
   server-supported certificate types, then the client_certificate_type
   payload in the server hello MUST be omitted.

   The server_certificate_type extension in the client hello indicates
   the types of certificates the client is able to process when provided
   by the server in a subsequent certificate payload.  If the client
   hello indicates support of raw public keys in the
   server_certificate_type extension and the server chooses to use raw
   public keys, then the TLS server MUST place the SubjectPublicKeyInfo
   structure into the Certificate payload.  With the
   server_certificate_type extension in the server hello, the TLS server
   indicates the certificate type carried in the Certificate payload.
   This additional indication enables avoiding parsing ambiguities since
   the Certificate payload may contain either the X.509 certificate or a
   SubjectPublicKeyInfo structure.  Note that only a single value is
   permitted in the server_certificate_type extension when carried in
   the server hello.

4.3.  Client Authentication

   When the TLS server has specified RawPublicKey as the
   client_certificate_type, authentication of the TLS client to the TLS
   server is supported only through authentication of the received
   client SubjectPublicKeyInfo via an out-of-band method.

4.4.  Server Authentication

   When the TLS server has specified RawPublicKey as the
   server_certificate_type, authentication of the TLS server to the TLS
   client is supported only through authentication of the received
   client SubjectPublicKeyInfo via an out-of-band method.




Wouters, et al.              Standards Track                    [Page 9]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


5.  Examples

   Figures 6, 7, and 8 illustrate example exchanges.  Note that TLS
   ciphersuites using a Diffie-Hellman exchange offering forward secrecy
   can be used with a raw public key, although this document does not
   show the information exchange at that level with the subsequent
   message flows.

5.1.  TLS Server Uses a Raw Public Key

   This section shows an example where the TLS client indicates its
   ability to receive and validate a raw public key from the server.  In
   this example, the client is quite restricted since it is unable to
   process other certificate types sent by the server.  It also does not
   have credentials at the TLS layer it could send to the server and
   therefore omits the client_certificate_type extension.  Hence, the
   client only populates the server_certificate_type extension with the
   raw public key type, as shown in (1).

   When the TLS server receives the client hello, it processes the
   extension.  Since it has a raw public key, it indicates in (2) that
   it had chosen to place the SubjectPublicKeyInfo structure into the
   Certificate payload (3).

   The client uses this raw public key in the TLS handshake together
   with an out-of-band validation technique, such as DANE, to verify it.

  client_hello,
  server_certificate_type=(RawPublicKey) // (1)
                         ->
                         <- server_hello,
                            server_certificate_type=RawPublicKey, // (2)
                            certificate, // (3)
                            server_key_exchange,
                            server_hello_done

  client_key_exchange,
  change_cipher_spec,
  finished               ->

                         <- change_cipher_spec,
                            finished

  Application Data       <-------> Application Data

     Figure 6: Example with Raw Public Key Provided by the TLS Server





Wouters, et al.              Standards Track                   [Page 10]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


5.2.  TLS Client and Server Use Raw Public Keys

   This section shows an example where the TLS client as well as the TLS
   server use raw public keys.  This is one of the use cases envisioned
   for smart object networking.  The TLS client in this case is an
   embedded device that is configured with a raw public key for use with
   TLS and is also able to process a raw public key sent by the server.
   Therefore, it indicates these capabilities in (1).  As in the
   previously shown example, the server fulfills the client's request,
   indicates this via the RawPublicKey value in the
   server_certificate_type payload (2), and provides a raw public key in
   the Certificate payload back to the client (see (3)).  The TLS server
   demands client authentication, and therefore includes a
   certificate_request (4).  The client_certificate_type payload in (5)
   indicates that the TLS server accepts a raw public key.  The TLS
   client, which has a raw public key pre-provisioned, returns it in the
   Certificate payload (6) to the server.

client_hello,
client_certificate_type=(RawPublicKey) // (1)
server_certificate_type=(RawPublicKey) // (1)
                         ->
                         <-  server_hello,
                             server_certificate_type=RawPublicKey // (2)
                             certificate, // (3)
                             client_certificate_type=RawPublicKey // (5)
                             certificate_request, // (4)
                             server_key_exchange,
                             server_hello_done

certificate, // (6)
client_key_exchange,
change_cipher_spec,
finished                  ->

                         <- change_cipher_spec,
                            finished

Application Data        <------->     Application Data

   Figure 7: Example with Raw Public Key provided by the TLS Server and
                                the Client









Wouters, et al.              Standards Track                   [Page 11]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


5.3.  Combined Usage of Raw Public Keys and X.509 Certificates

   This section shows an example combining a raw public key and an X.509
   certificate.  The client uses a raw public key for client
   authentication, and the server provides an X.509 certificate.  This
   exchange starts with the client indicating its ability to process an
   X.509 certificate, OpenPGP certificate, or a raw public key, if
   provided by the server.  It prefers a raw public key, since the
   RawPublicKey value precedes the other values in the
   server_certificate_type vector.  Additionally, the client indicates
   that it has a raw public key for client-side authentication (see
   (1)).  The server chooses to provide its X.509 certificate in (3) and
   indicates that choice in (2).  For client authentication, the server
   indicates in (4) that it has selected the raw public key format and
   requests a certificate from the client in (5).  The TLS client
   provides a raw public key in (6) after receiving and processing the
   TLS server hello message.

client_hello,
server_certificate_type=(RawPublicKey, X.509, OpenPGP)
client_certificate_type=(RawPublicKey) // (1)
                         ->
                         <-  server_hello,
                             server_certificate_type=X.509 // (2)
                             certificate, // (3)
                             client_certificate_type=RawPublicKey // (4)
                             certificate_request, // (5)
                             server_key_exchange,
                             server_hello_done
certificate, // (6)
client_key_exchange,
change_cipher_spec,
finished                  ->

                          <- change_cipher_spec,
                             finished

Application Data        <------->     Application Data

                   Figure 8: Hybrid Certificate Example











Wouters, et al.              Standards Track                   [Page 12]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


6.  Security Considerations

   The transmission of raw public keys, as described in this document,
   provides benefits by lowering the over-the-air transmission overhead
   since raw public keys are naturally smaller than an entire
   certificate.  There are also advantages from a code-size point of
   view for parsing and processing these keys.  The cryptographic
   procedures for associating the public key with the possession of a
   private key also follows standard procedures.

   However, the main security challenge is how to associate the public
   key with a specific entity.  Without a secure binding between
   identifier and key, the protocol will be vulnerable to man-in-the-
   middle attacks.  This document assumes that such binding can be made
   out-of-band, and we list a few examples in Section 1.  DANE [RFC6698]
   offers one such approach.  In order to address these vulnerabilities,
   specifications that make use of the extension need to specify how the
   identifier and public key are bound.  In addition to ensuring the
   binding is done out-of-band, an implementation also needs to check
   the status of that binding.

   If public keys are obtained using DANE, these public keys are
   authenticated via DNSSEC.  Using pre-configured keys is another out-
   of-band method for authenticating raw public keys.  While pre-
   configured keys are not suitable for a generic Web-based e-commerce
   environment, such keys are a reasonable approach for many smart
   object deployments where there is a close relationship between the
   software running on the device and the server-side communication
   endpoint.  Regardless of the chosen mechanism for out-of-band public
   key validation, an assessment of the most suitable approach has to be
   made prior to the start of a deployment to ensure the security of the
   system.

   An attacker might try to influence the handshake exchange to make the
   parties select different certificate types than they would normally
   choose.

   For this attack, an attacker must actively change one or more
   handshake messages.  If this occurs, the client and server will
   compute different values for the handshake message hashes.  As a
   result, the parties will not accept each others' Finished messages.
   Without the master_secret, the attacker cannot repair the Finished
   messages, so the attack will be discovered.








Wouters, et al.              Standards Track                   [Page 13]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


7.  IANA Considerations

   IANA has registered a new value in the "TLS Certificate Types"
   subregistry of the "Transport Layer Security (TLS) Extensions"
   registry [TLS-Ext-Registry], as follows:

   Value: 2
   Description: Raw Public Key
   Reference: RFC 7250

   IANA has allocated two new TLS extensions, client_certificate_type
   and server_certificate_type, from the "TLS ExtensionType Values"
   subregistry defined in [RFC5246].  These extensions are used in both
   the client hello message and the server hello message.  The new
   extension types are used for certificate type negotiation.  The
   values carried in these extensions are taken from the "TLS
   Certificate Types" subregistry of the "Transport Layer Security (TLS)
   Extensions" registry [TLS-Ext-Registry].

8.  Acknowledgements

   The feedback from the TLS working group meeting at IETF 81 has
   substantially shaped the document, and we would like to thank the
   meeting participants for their input.  The support for hashes of
   public keys has been moved to [CACHED-INFO] after the discussions at
   the IETF 82 meeting.

   We would like to thank the following persons for their review
   comments: Martin Rex, Bill Frantz, Zach Shelby, Carsten Bormann,
   Cullen Jennings, Rene Struik, Alper Yegin, Jim Schaad, Barry Leiba,
   Paul Hoffman, Robert Cragie, Nikos Mavrogiannopoulos, Phil Hunt, John
   Bradley, Klaus Hartke, Stefan Jucker, Kovatsch Matthias, Daniel Kahn
   Gillmor, Peter Sylvester, Hauke Mehrtens, Alexey Melnikov, Stephen
   Farrell, Richard Barnes, and James Manger.  Nikos Mavrogiannopoulos
   contributed the design for reusing the certificate type registry.
   Barry Leiba contributed guidance for the IANA Considerations text.
   Stefan Jucker, Kovatsch Matthias, and Klaus Hartke provided
   implementation feedback regarding the SubjectPublicKeyInfo structure.

   Christer Holmberg provided the General Area (Gen-Art) review, Yaron
   Sheffer provided the Security Directorate (SecDir) review, Bert
   Greevenbosch provided the Applications Area Directorate review, and
   Linda Dunbar provided the Operations Directorate review.

   We would like to thank our TLS working group chairs, Eric Rescorla
   and Joe Salowey, for their guidance and support.  Finally, we would
   like to thank Sean Turner, who is the responsible Security Area
   Director for this work, for his review comments and suggestions.



Wouters, et al.              Standards Track                   [Page 14]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


9.  References

9.1.  Normative References

   [PKIX]     Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC3279]  Bassham, L., Polk, W., and R. Housley, "Algorithms and
              Identifiers for the Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 3279, April 2002.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Elliptic Curve Cryptography Subject Public Key
              Information", RFC 5480, March 2009.

   [TLS-Ext-Registry]
              IANA, "Transport Layer Security (TLS) Extensions",
              <http://www.iana.org/assignments/
              tls-extensiontype-values>.

   [X.690]    ITU-T, "Information technology - ASN.1 encoding rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ITU-T Recommendation X.690, ISO/IEC 8825-1:2002,
              2002.

9.2.  Informative References

   [ASN.1-Dump]
              Gutmann, P., "ASN.1 Object Dump Program", February 2013,
              <http://www.cs.auckland.ac.nz/~pgut001/>.

   [CACHED-INFO]
              Santesson, S. and H. Tschofenig, "Transport Layer Security
              (TLS) Cached Information Extension", Work in Progress,
              February 2014.

   [CoAP]     Shelby, Z., Hartke, K., and C. Bormann, "The Constrained
              Application Protocol (CoAP)", RFC 7252, June 2014.



Wouters, et al.              Standards Track                   [Page 15]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


   [Defeating-SSL]
              Marlinspike, M., "New Tricks for Defeating SSL in
              Practice", February 2009, <http://www.blackhat.com/
              presentations/bh-dc-09/Marlinspike/
              BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf>.

   [LDAP]     Sermersheim, J., "Lightweight Directory Access Protocol
              (LDAP): The Protocol", RFC 4511, June 2006.

   [RFC6698]  Hoffman, P. and J. Schlyter, "The DNS-Based Authentication
              of Named Entities (DANE) Transport Layer Security (TLS)
              Protocol: TLSA", RFC 6698, August 2012.







































Wouters, et al.              Standards Track                   [Page 16]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


Appendix A.  Example Encoding

   For example, the hex sequence shown in Figure 9 describes a
   SubjectPublicKeyInfo structure inside the certificate payload.

          0     1     2     3     4     5     6     7     8     9
      +------+-----+-----+-----+-----+-----+-----+-----+-----+-----
   1  | 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
   2  | 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81,
   3  | 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xcd,
   4  | 0xfd, 0x89, 0x48, 0xbe, 0x36, 0xb9, 0x95, 0x76, 0xd4, 0x13,
   5  | 0x30, 0x0e, 0xbf, 0xb2, 0xed, 0x67, 0x0a, 0xc0, 0x16, 0x3f,
   6  | 0x51, 0x09, 0x9d, 0x29, 0x2f, 0xb2, 0x6d, 0x3f, 0x3e, 0x6c,
   7  | 0x2f, 0x90, 0x80, 0xa1, 0x71, 0xdf, 0xbe, 0x38, 0xc5, 0xcb,
   8  | 0xa9, 0x9a, 0x40, 0x14, 0x90, 0x0a, 0xf9, 0xb7, 0x07, 0x0b,
   9  | 0xe1, 0xda, 0xe7, 0x09, 0xbf, 0x0d, 0x57, 0x41, 0x86, 0x60,
   10 | 0xa1, 0xc1, 0x27, 0x91, 0x5b, 0x0a, 0x98, 0x46, 0x1b, 0xf6,
   11 | 0xa2, 0x84, 0xf8, 0x65, 0xc7, 0xce, 0x2d, 0x96, 0x17, 0xaa,
   12 | 0x91, 0xf8, 0x61, 0x04, 0x50, 0x70, 0xeb, 0xb4, 0x43, 0xb7,
   13 | 0xdc, 0x9a, 0xcc, 0x31, 0x01, 0x14, 0xd4, 0xcd, 0xcc, 0xc2,
   14 | 0x37, 0x6d, 0x69, 0x82, 0xd6, 0xc6, 0xc4, 0xbe, 0xf2, 0x34,
   15 | 0xa5, 0xc9, 0xa6, 0x19, 0x53, 0x32, 0x7a, 0x86, 0x0e, 0x91,
   16 | 0x82, 0x0f, 0xa1, 0x42, 0x54, 0xaa, 0x01, 0x02, 0x03, 0x01,
   17 | 0x00, 0x01

      Figure 9: Example SubjectPublicKeyInfo Structure Byte Sequence

   The decoded byte sequence shown in Figure 9 (for example, using Peter
   Gutmann's ASN.1 decoder [ASN.1-Dump]) illustrates the structure, as
   shown in Figure 10.

   Offset  Length   Description
   -------------------------------------------------------------------
      0     3+159:   SEQUENCE {
      3      2+13:     SEQUENCE {
      5       2+9:      OBJECT IDENTIFIER Value (1 2 840 113549 1 1 1)
                 :             PKCS #1, rsaEncryption
     16       2+0:      NULL
                 :      }
     18     3+141:    BIT STRING, encapsulates {
     22     3+137:      SEQUENCE {
     25     3+129:        INTEGER Value (1024 bit)
    157       2+3:        INTEGER Value (65537)
                 :        }
                 :      }
                 :    }

       Figure 10: Decoding of Example SubjectPublicKeyInfo Structure



Wouters, et al.              Standards Track                   [Page 17]
   __________________________________________________________________


RFC 7250            Using Raw Public Keys in TLS/DTLS          June 2014


Authors' Addresses

   Paul Wouters (editor)
   Red Hat

   EMail: pwouters@redhat.com


   Hannes Tschofenig (editor)
   ARM Ltd.
   6060 Hall in Tirol
   Austria

   EMail: Hannes.tschofenig@gmx.net
   URI:   http://www.tschofenig.priv.at


   John Gilmore
   Electronic Frontier Foundation
   PO Box 170608
   San Francisco, California  94117
   USA

   Phone: +1 415 221 6524
   EMail: gnu@toad.com
   URI:   https://www.toad.com/


   Samuel Weiler
   Parsons
   7110 Samuel Morse Drive
   Columbia, Maryland  21046
   US

   EMail: weiler@tislabs.com


   Tero Kivinen
   INSIDE Secure
   Eerikinkatu 28
   Helsinki  FI-00180
   FI

   EMail: kivinen@iki.fi







Wouters, et al.              Standards Track                   [Page 18]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-tls-...] [Tracker] [Diff1] [Diff2]
   PROPOSED STANDARD
Internet Engineering Task Force (IETF)                      S. Santesson
Request for Comments: 7924                               3xA Security AB
Category: Standards Track                                  H. Tschofenig
ISSN: 2070-1721                                                 ARM Ltd.
                                                               July 2016


      Transport Layer Security (TLS) Cached Information Extension

Abstract

   Transport Layer Security (TLS) handshakes often include fairly static
   information, such as the server certificate and a list of trusted
   certification authorities (CAs).  This information can be of
   considerable size, particularly if the server certificate is bundled
   with a complete certificate chain (i.e., the certificates of
   intermediate CAs up to the root CA).

   This document defines an extension that allows a TLS client to inform
   a server of cached information, thereby enabling the server to omit
   already available information.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 7841.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc7924.
















Santesson & Tschofenig       Standards Track                    [Page 1]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   3
   3.  Cached Information Extension  . . . . . . . . . . . . . . . .   3
   4.  Exchange Specification  . . . . . . . . . . . . . . . . . . .   5
     4.1.  Server Certificate Message  . . . . . . . . . . . . . . .   6
     4.2.  CertificateRequest Message  . . . . . . . . . . . . . . .   7
   5.  Fingerprint Calculation . . . . . . . . . . . . . . . . . . .   7
   6.  Example . . . . . . . . . . . . . . . . . . . . . . . . . . .   8
   7.  Security Considerations . . . . . . . . . . . . . . . . . . .  10
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  10
     8.1.  New Entry to the TLS ExtensionType Registry . . . . . . .  10
     8.2.  New Registry for CachedInformationType  . . . . . . . . .  11
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  11
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  11
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  12
   Appendix A.  Example  . . . . . . . . . . . . . . . . . . . . . .  13
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  18
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  19
















Santesson & Tschofenig       Standards Track                    [Page 2]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


1.  Introduction

   Reducing the amount of information exchanged during a Transport Layer
   Security handshake to a minimum helps to improve performance in
   environments where devices are connected to a network with a low
   bandwidth and lossy radio technology.  With the Internet of Things,
   such environments exist, for example, when devices use IEEE 802.15.4,
   Bluetooth Low Energy, or low power wide area networks.  For more
   information about the challenges with smart object deployments,
   please see [RFC6574].

   This specification defines a TLS extension that allows a client and a
   server to exclude transmission information cached in an earlier TLS
   handshake.

   A typical example exchange may therefore look as follows.  First, the
   client and the server execute the full TLS handshake.  The client
   then caches the certificate provided by the server.  When the TLS
   client connects to the TLS server some time in the future, without
   using session resumption, it then attaches the "cached_info"
   extension defined in this document to the ClientHello message to
   indicate that it has cached the certificate, and it provides the
   fingerprint of it.  If the server's certificate has not changed, then
   the TLS server does not need to send its certificate and the
   corresponding certificate chain again.  In case information has
   changed, which can be seen from the fingerprint provided by the
   client, the certificate payload is transmitted to the client to allow
   the client to update the cache.

2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "MUST", "MUST NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

   This document refers to the TLS protocol, but the description is
   equally applicable to Datagram Transport Layer Security (DTLS) as
   well.

3.  Cached Information Extension

   This document defines a new extension type (cached_info(25)), which
   is used in ClientHello and ServerHello messages.  The extension type
   is specified as follows.

         enum {
              cached_info(25), (65535)
         } ExtensionType;



Santesson & Tschofenig       Standards Track                    [Page 3]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


   The extension_data field of this extension, when included in the
   ClientHello, MUST contain the CachedInformation structure.  The
   client MAY send multiple CachedObjects of the same
   CachedInformationType.  This may, for example, be the case when the
   client has cached multiple certificates from a server.

         enum {
              cert(1), cert_req(2) (255)
         } CachedInformationType;

         struct {
              select (type) {
                case client:
                  CachedInformationType type;
                  opaque hash_value<1..255>;
                case server:
                  CachedInformationType type;
              } body;
         } CachedObject;

         struct {
              CachedObject cached_info<1..2^16-1>;
         } CachedInformation;

   This document defines the following two types:

   'cert' type for not sending the complete server certificate message:

      With the type field set to 'cert', the client MUST include the
      fingerprint of the Certificate message in the hash_value field.
      For this type, the fingerprint MUST be calculated using the
      procedure described in Section 5 with the Certificate message as
      input data.

   'cert_req' Type for not sending the complete CertificateRequest
      Message:

      With the type set to 'cert_req', the client MUST include the
      fingerprint of the CertificateRequest message in the hash_value
      field.  For this type, the fingerprint MUST be calculated using
      the procedure described in Section 5 with the CertificateRequest
      message as input data.

   New cached info types can be added following the policy described in
   the IANA Considerations (Section 8).  New message digest algorithms
   for use with these types can also be added by registering a new type
   that makes use of the updated message digest algorithm.  For
   practical reasons, we recommend reusing hash algorithms already



Santesson & Tschofenig       Standards Track                    [Page 4]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


   available with TLS ciphersuites.  To avoid additional code and to
   keep the collision probability low, new hash algorithms MUST NOT have
   a collision resistance worse than SHA-256.

4.  Exchange Specification

   Clients supporting this extension MAY include the "cached_info"
   extension in the (extended) ClientHello.  If the client includes the
   extension, then it MUST contain one or more CachedObject attributes.

   A server supporting this extension MAY include the "cached_info"
   extension in the (extended) ServerHello.  By returning the
   "cached_info" extension, the server indicates that it supports the
   cached info types.  For each indicated cached info type, the server
   MUST alter the transmission of respective payloads, according to the
   rules outlined with each type.  If the server includes the extension,
   it MUST only include CachedObjects of a type also supported by the
   client (as expressed in the ClientHello).  For example, if a client
   indicates support for 'cert' and 'cert_req', then the server cannot
   respond with a "cached_info" attribute containing support for
   ('foo-bar').

   Since the client includes a fingerprint of information it cached (for
   each indicated type), the server is able to determine whether cached
   information is stale.  If the server supports this specification and
   notices a mismatch between the data cached by the client and its own
   information, then the server MUST include the information in full and
   MUST NOT list the respective type in the "cached_info" extension.

   Note: If a server is part of a hosting environment, then the client
   may have cached multiple data items for a single server.  To allow
   the client to select the appropriate information from the cache, it
   is RECOMMENDED that the client utilizes the Server Name Indication
   (SNI) extension [RFC6066].

   Following a successful exchange of the "cached_info" extension in the
   ClientHello and ServerHello, the server alters sending the
   corresponding handshake message.  How information is altered from the
   handshake messages and for the types defined in this specification is
   defined in Sections 4.1 and 4.2, respectively.

   Appendix A shows an example hash calculation, and Section 6
   illustrates an example protocol exchange.








Santesson & Tschofenig       Standards Track                    [Page 5]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


4.1.  Server Certificate Message

   When a ClientHello message contains the "cached_info" extension with
   a type set to 'cert', then the server MAY send the Certificate
   message shown in Figure 1 under the following conditions:

   o  The server software implements the "cached_info" extension defined
      in this specification.

   o  The 'cert' "cached_info" extension is enabled (for example, a
      policy allows the use of this extension).

   o  The server compared the value in the hash_value field of the
      client-provided "cached_info" extension with the fingerprint of
      the Certificate message it normally sends to clients.  This check
      ensures that the information cached by the client is current.  The
      procedure for calculating the fingerprint is described in
      Section 5.

   The original certificate handshake message syntax is defined in
   [RFC5246] and has been extended with [RFC7250].  RFC 7250 allows the
   certificate payload to contain only the SubjectPublicKeyInfo instead
   of the full information typically found in a certificate.  Hence,
   when this specification is used in combination with [RFC7250] and the
   negotiated certificate type is a raw public key, then the TLS server
   omits sending a certificate payload that contains an ASN.1
   certificate structure with the included SubjectPublicKeyInfo rather
   than the full certificate chain.  As such, this extension is
   compatible with the raw public key extension defined in RFC 7250.
   Note: We assume that the server implementation is able to select the
   appropriate certificate or SubjectPublicKeyInfo from the received
   hash value.  If the SNI extension is used by the client, then the
   server has additional information to guide the selection of the
   appropriate cached info.

   When the cached info specification is used, then a modified version
   of the Certificate message is exchanged.  The modified structure is
   shown in Figure 1.

         struct {
             opaque hash_value<1..255>;
         } Certificate;

                 Figure 1: Cached Info Certificate Message







Santesson & Tschofenig       Standards Track                    [Page 6]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


4.2.  CertificateRequest Message

   When a fingerprint for an object of type 'cert_req' is provided in
   the ClientHello, the server MAY send the CertificateRequest message
   shown in Figure 2 under the following conditions:

   o  The server software implements the "cached_info" extension defined
      in this specification.

   o  The 'cert_req' "cached_info" extension is enabled (for example, a
      policy allows the use of this extension).

   o  The server compared the value in the hash_value field of the
      client-provided "cached_info" extension with the fingerprint of
      the CertificateRequest message it normally sends to clients.  This
      check ensures that the information cached by the client is
      current.  The procedure for calculating the fingerprint is
      described in Section 5.

   o  The server wants to request a certificate from the client.

   The original CertificateRequest handshake message syntax is defined
   in [RFC5246].  The modified structure of the CertificateRequest
   message is shown in Figure 2.

         struct {
             opaque hash_value<1..255>;
         } CertificateRequest;

             Figure 2: Cached Info CertificateRequest Message

   The CertificateRequest payload is the input parameter to the
   fingerprint calculation described in Section 5.

5.  Fingerprint Calculation

   The fingerprint for the two cached info objects defined in this
   document MUST be computed as follows:

   1.  Compute the SHA-256 [RFC6234] hash of the input data.  The input
       data depends on the cached info type.  This document defines two
       cached info types, described in Sections 4.1 and in 4.2.  Note
       that the computed hash only covers the input data structure (and
       not any type and length information of the record layer).
       Appendix A shows an example.

   2.  Use the output of the SHA-256 hash.




Santesson & Tschofenig       Standards Track                    [Page 7]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


   The purpose of the fingerprint provided by the client is to help the
   server select the correct information.  For example, in case of a
   Certificate message, the fingerprint identifies the server
   certificate (and the corresponding private key) for use with the rest
   of the handshake.  Servers may have more than one certificate, and
   therefore a hash needs to be long enough to keep the probably of hash
   collisions low.  On the other hand, the cached info design aims to
   reduce the amount of data being exchanged.  The security of the
   handshake depends on the private key and not on the size of the
   fingerprint.  Hence, the fingerprint is a way to prevent the server
   from accidentally selecting the wrong information.  If an attacker
   injects an incorrect fingerprint, then two outcomes are possible: (1)
   the fingerprint does not relate to any cached state and the server
   has to fall back to a full exchange, and (2) if the attacker manages
   to inject a fingerprint that refers to data the client has not
   cached, then the exchange will fail later when the client continues
   with the handshake and aims to verify the digital signature.  The
   signature verification will fail since the public key cached by the
   client will not correspond to the private key that was used by the
   server to sign the message.

6.  Example

   In the regular, full TLS handshake exchange, shown in Figure 3, the
   TLS server provides its certificate in the certificate payload to the
   client; see step (1).  This allows the client to store the
   certificate for future use.  After some time, the TLS client again
   interacts with the same TLS server and makes use of the TLS
   "cached_info" extension, as shown in Figure 4.  The TLS client
   indicates support for this specification via the "cached_info"
   extension, see step (2), and indicates that it has stored the
   certificate from the earlier exchange (by indicating the 'cert'
   type).  With step (3), the TLS server acknowledges the support of the
   'cert' type and by including the value in the ServerHello, it informs
   the client that the content of the certificate payload contains the
   fingerprint of the certificate instead of the payload, defined in RFC
   5246, of the Certificate message; see step (4).














Santesson & Tschofenig       Standards Track                    [Page 8]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


   ClientHello            ->
                          <-  ServerHello
                              Certificate* // (1)
                              ServerKeyExchange*
                              CertificateRequest*
                              ServerHelloDone

   Certificate*
   ClientKeyExchange
   CertificateVerify*
   [ChangeCipherSpec]
   Finished               ->

                          <- [ChangeCipherSpec]
                             Finished

   Application Data <-------> Application Data

        Figure 3: Example Message Exchange: Initial (Full) Exchange


   ClientHello
   cached_info=(cert)     -> // (2)
                          <-  ServerHello
                              cached_info=(cert) (3)
                              Certificate (4)
                              ServerKeyExchange*
                              ServerHelloDone

   ClientKeyExchange
   CertificateVerify*
   [ChangeCipherSpec]
   Finished               ->

                          <- [ChangeCipherSpec]
                             Finished

   Application Data <-------> Application Data

      Figure 4: Example Message Exchange: TLS Cached Extension Usage











Santesson & Tschofenig       Standards Track                    [Page 9]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


7.  Security Considerations

   This specification defines a mechanism to reference stored state
   using a fingerprint.  Sending a fingerprint of cached information in
   an unencrypted handshake, as the ClientHello and ServerHello does,
   may allow an attacker or observer to correlate independent TLS
   exchanges.  While some information elements used in this
   specification, such as server certificates, are public objects and
   usually do not contain sensitive information, other types that are
   not yet defined may.  Those who implement and deploy this
   specification should therefore make an informed decision whether the
   cached information is in line with their security and privacy goals.
   In case of concerns, it is advised to avoid sending the fingerprint
   of the data objects in clear.

   The use of the "cached_info" extension allows the server to send
   significantly smaller TLS messages.  Consequently, these omitted
   parts of the messages are not included in the transcript of the
   handshake in the TLS Finish message.  However, since the client and
   the server communicate the hash values of the cached data in the
   initial handshake messages, the fingerprints are included in the TLS
   Finish message.

   Clients MUST ensure that they only cache information from legitimate
   sources.  For example, when the client populates the cache from a TLS
   exchange, then it must only cache information after the successful
   completion of a TLS exchange to ensure that an attacker does not
   inject incorrect information into the cache.  Failure to do so allows
   for man-in-the-middle attacks.

   Security considerations for the fingerprint calculation are discussed
   in Section 5.

8.  IANA Considerations

8.1.  New Entry to the TLS ExtensionType Registry

   IANA has added an entry to the existing TLS "ExtensionType Values"
   registry, defined in [RFC5246], for cached_info(25) defined in this
   document.











Santesson & Tschofenig       Standards Track                   [Page 10]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


8.2.  New Registry for CachedInformationType

   IANA has established a registry titled "TLS CachedInformationType
   Values".  The entries in the registry are:

   Value    Description
   -----    -----------
     0      Reserved
     1      cert
     2      cert_req
   224-255  Reserved for Private Use

   The policy for adding new values to this registry, following the
   terminology defined in [RFC5226], is as follows:

   o  0-63 (decimal): Standards Action

   o  64-223 (decimal): Specification Required

9.  References

9.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <http://www.rfc-editor.org/info/rfc5246>.

   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <http://www.rfc-editor.org/info/rfc6066>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <http://www.rfc-editor.org/info/rfc6234>.









Santesson & Tschofenig       Standards Track                   [Page 11]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


9.2.  Informative References

   [ASN.1-Dump]
              Gutmann, P., "ASN.1 Object Dump Program", November 2010,
              <http://manpages.ubuntu.com/manpages/precise/man1/
              dumpasn1.1.html>.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              DOI 10.17487/RFC5226, May 2008,
              <http://www.rfc-editor.org/info/rfc5226>.

   [RFC6574]  Tschofenig, H. and J. Arkko, "Report from the Smart Object
              Workshop", RFC 6574, DOI 10.17487/RFC6574, April 2012,
              <http://www.rfc-editor.org/info/rfc6574>.

   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,
              Weiler, S., and T. Kivinen, "Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport
              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,
              June 2014, <http://www.rfc-editor.org/info/rfc7250>.






























Santesson & Tschofenig       Standards Track                   [Page 12]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


Appendix A.  Example

   Consider a certificate containing a NIST P256 elliptic curve public
   key displayed using Peter Gutmann's ASN.1 decoder [ASN.1-Dump] in
   Figure 5.

    0 556: SEQUENCE {
    4 434:   SEQUENCE {
    8   3:     [0] {
   10   1:       INTEGER 2
         :       }
   13   1:     INTEGER 13
   16  10:     SEQUENCE {
   18   8:      OBJECT IDENTIFIER ecdsaWithSHA256 (1 2 840 10045 4 3 2)
         :       }
   28  62:     SEQUENCE {
   30  11:       SET {
   32   9:         SEQUENCE {
   34   3:           OBJECT IDENTIFIER countryName (2 5 4 6)
   39   2:           PrintableString 'NL'
         :           }
         :         }
   43  17:       SET {
   45  15:         SEQUENCE {
   47   3:           OBJECT IDENTIFIER organizationName (2 5 4 10)
   52   8:           PrintableString 'PolarSSL'
         :           }
         :         }
   62  28:       SET {
   64  26:         SEQUENCE {
   66   3:           OBJECT IDENTIFIER commonName (2 5 4 3)
   71  19:           PrintableString 'Polarssl Test EC CA'
         :           }
         :         }
         :       }
   92  30:     SEQUENCE {
   94  13:       UTCTime 24/09/2013 15:52:04 GMT
  109  13:       UTCTime 22/09/2023 15:52:04 GMT
         :       }
  124  65:     SEQUENCE {
  126  11:       SET {
  128   9:         SEQUENCE {
  130   3:           OBJECT IDENTIFIER countryName (2 5 4 6)
  135   2:           PrintableString 'NL'
         :           }
         :         }





Santesson & Tschofenig       Standards Track                   [Page 13]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


  139  17:       SET {
  141  15:         SEQUENCE {
  143   3:           OBJECT IDENTIFIER organizationName (2 5 4 10)
  148   8:           PrintableString 'PolarSSL'
         :           }
         :         }
  158  31:       SET {
  160  29:         SEQUENCE {
  162   3:           OBJECT IDENTIFIER commonName (2 5 4 3)
  167  22:           PrintableString 'PolarSSL Test Client 2'
         :           }
         :         }
         :       }
  191  89:     SEQUENCE {
  193  19:       SEQUENCE {
  195   7:         OBJECT IDENTIFIER ecPublicKey (1 2 840 10045 2 1)
  204   8:         OBJECT IDENTIFIER prime256v1 (1 2 840 10045 3 1 7)
         :         }
  214  66:       BIT STRING
         :         04 57 E5 AE B1 73 DF D3 AC BB 93 B8 81 FF 12 AE
         :         EE E6 53 AC CE 55 53 F6 34 0E CC 2E E3 63 25 0B
         :         DF 98 E2 F3 5C 60 36 96 C0 D5 18 14 70 E5 7F 9F
         :         D5 4B 45 18 E5 B0 6C D5 5C F8 96 8F 87 70 A3 E4
         :         C7
         :       }
  282 157:     [3] {
  285 154:       SEQUENCE {
  288   9:         SEQUENCE {
  290   3:           OBJECT IDENTIFIER basicConstraints (2 5 29 19)
  295   2:           OCTET STRING, encapsulates {
  297   0:             SEQUENCE {}
         :             }
         :           }
  299  29:         SEQUENCE {
  301   3:           OBJECT IDENTIFIER subjectKeyIdentifier (2 5 29 14)
  306  22:           OCTET STRING, encapsulates {
  308  20:             OCTET STRING
         :              7A 00 5F 86 64 FC E0 5D E5 11 10 3B B2 E6 3B C4
         :              26 3F CF E2
         :             }
         :           }
  330 110:         SEQUENCE {
  332   3:          OBJECT IDENTIFIER authorityKeyIdentifier (2 5 29 35)
  337 103:          OCTET STRING, encapsulates {
  339 101:             SEQUENCE {






Santesson & Tschofenig       Standards Track                   [Page 14]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


  341  20:               [0]
         :               9D 6D 20 24 49 01 3F 2B CB 78 B5 19 BC 7E 24
         :               C9 DB FB 36 7C
  363  66:               [1] {
  365  64:                 [4] {
  367  62:                   SEQUENCE {
  369  11:                     SET {
  371   9:                      SEQUENCE {
  373   3:                       OBJECT IDENTIFIER countryName (2 5 4 6)
  378   2:                       PrintableString 'NL'
         :                       }
         :                      }
  382  17:                     SET {
  384  15:                      SEQUENCE {
  386   3:                        OBJECT IDENTIFIER organizationName
         :                               (2 5 4 10)
  391   8:                        PrintableString 'PolarSSL'
         :                        }
         :                      }
  401  28:                     SET {
  403  26:                      SEQUENCE {
  405   3:                       OBJECT IDENTIFIER commonName (2 5 4 3)
  410  19:                       PrintableString 'Polarssl Test EC CA'
         :                        }
         :                      }
         :                     }
         :                   }
         :                 }
  431   9:               [2] 00 C1 43 E2 7E 62 43 CC E8
         :               }
         :             }
         :           }
         :         }
         :       }
         :     }
  442  10:   SEQUENCE {
  444   8:     OBJECT IDENTIFIER ecdsaWithSHA256 (1 2 840 10045 4 3 2)
         :     }
  454 104:   BIT STRING, encapsulates {
  457 101:     SEQUENCE {
  459  48:       INTEGER
         :         4A 65 0D 7B 20 83 A2 99 B9 A8 0F FC 8D EE 8F 3D
         :         BB 70 4C 96 03 AC 8E 78 70 DD F2 0E A0 B2 16 CB
         :         65 8E 1A C9 3F 2C 61 7E F8 3C EF AD 1C EE 36 20







Santesson & Tschofenig       Standards Track                   [Page 15]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


  509  49:       INTEGER
         :         00 9D F2 27 A6 D5 74 B8 24 AE E1 6A 3F 31 A1 CA
         :         54 2F 08 D0 8D EE 4F 0C 61 DF 77 78 7D B4 FD FC
         :         42 49 EE E5 B2 6A C2 CD 26 77 62 8E 28 7C 9E 57
         :         45
         :       }
         :     }
         :   }

                Figure 5: ASN.1-Based Certificate: Example

   To include the certificate shown in Figure 5 in a TLS/DTLS
   Certificate message, it is prepended with a message header.  This
   Certificate message header in our example is 0b 00 02 36 00 02 33 00
   02 00 02 30, which indicates:

   Message Type:  0b -- 1-byte type field indicating a Certificate
      message

   Length:  00 02 36 -- 3-byte length field indicating a 566-byte
      payload

   Certificates Length:  00 02 33 -- 3-byte length field indicating 563
      bytes for the entire certificates_list structure, which may
      contain multiple certificates.  In our example, only one
      certificate is included.

   Certificate Length:  00 02 30 -- 3-byte length field indicating 560
      bytes of the actual certificate following immediately afterwards.
      In our example, this is the certificate content with 30 82 02 ....
      9E 57 45 shown in Figure 6.




















Santesson & Tschofenig       Standards Track                   [Page 16]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


   The hex encoding of the ASN.1-encoded certificate payload shown in
   Figure 5 leads to the following encoding.

             30 82 02 2C 30 82 01 B2  A0 03 02 01 02 02 01 0D
             30 0A 06 08 2A 86 48 CE  3D 04 03 02 30 3E 31 0B
             30 09 06 03 55 04 06 13  02 4E 4C 31 11 30 0F 06
             03 55 04 0A 13 08 50 6F  6C 61 72 53 53 4C 31 1C
             30 1A 06 03 55 04 03 13  13 50 6F 6C 61 72 73 73
             6C 20 54 65 73 74 20 45  43 20 43 41 30 1E 17 0D
             31 33 30 39 32 34 31 35  35 32 30 34 5A 17 0D 32
             33 30 39 32 32 31 35 35  32 30 34 5A 30 41 31 0B
             30 09 06 03 55 04 06 13  02 4E 4C 31 11 30 0F 06
             03 55 04 0A 13 08 50 6F  6C 61 72 53 53 4C 31 1F
             30 1D 06 03 55 04 03 13  16 50 6F 6C 61 72 53 53
             4C 20 54 65 73 74 20 43  6C 69 65 6E 74 20 32 30
             59 30 13 06 07 2A 86 48  CE 3D 02 01 06 08 2A 86
             48 CE 3D 03 01 07 03 42  00 04 57 E5 AE B1 73 DF
             D3 AC BB 93 B8 81 FF 12  AE EE E6 53 AC CE 55 53
             F6 34 0E CC 2E E3 63 25  0B DF 98 E2 F3 5C 60 36
             96 C0 D5 18 14 70 E5 7F  9F D5 4B 45 18 E5 B0 6C
             D5 5C F8 96 8F 87 70 A3  E4 C7 A3 81 9D 30 81 9A
             30 09 06 03 55 1D 13 04  02 30 00 30 1D 06 03 55
             1D 0E 04 16 04 14 7A 00  5F 86 64 FC E0 5D E5 11
             10 3B B2 E6 3B C4 26 3F  CF E2 30 6E 06 03 55 1D
             23 04 67 30 65 80 14 9D  6D 20 24 49 01 3F 2B CB
             78 B5 19 BC 7E 24 C9 DB  FB 36 7C A1 42 A4 40 30
             3E 31 0B 30 09 06 03 55  04 06 13 02 4E 4C 31 11
             30 0F 06 03 55 04 0A 13  08 50 6F 6C 61 72 53 53
             4C 31 1C 30 1A 06 03 55  04 03 13 13 50 6F 6C 61
             72 73 73 6C 20 54 65 73  74 20 45 43 20 43 41 82
             09 00 C1 43 E2 7E 62 43  CC E8 30 0A 06 08 2A 86
             48 CE 3D 04 03 02 03 68  00 30 65 02 30 4A 65 0D
             7B 20 83 A2 99 B9 A8 0F  FC 8D EE 8F 3D BB 70 4C
             96 03 AC 8E 78 70 DD F2  0E A0 B2 16 CB 65 8E 1A
             C9 3F 2C 61 7E F8 3C EF  AD 1C EE 36 20 02 31 00
             9D F2 27 A6 D5 74 B8 24  AE E1 6A 3F 31 A1 CA 54
             2F 08 D0 8D EE 4F 0C 61  DF 77 78 7D B4 FD FC 42
             49 EE E5 B2 6A C2 CD 26  77 62 8E 28 7C 9E 57 45

             Figure 6: Hex Encoding of the Example Certificate

   Applying the SHA-256 hash function to the Certificate message, which
   starts with 0b 00 02 and ends with 9E 57 45, produces
   0x086eefb4859adfe977defac494fff6b73033b4ce1f86b8f2a9fc0c6bf98605af.







Santesson & Tschofenig       Standards Track                   [Page 17]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


Acknowledgments

   We would like to thank the following persons for your detailed
   document reviews:

   o  Paul Wouters and Nikos Mavrogiannopoulos (December 2011)

   o  Rob Stradling (February 2012)

   o  Ondrej Mikle (March 2012)

   o  Ilari Liusvaara, Adam Langley, and Eric Rescorla (July 2014)

   o  Sean Turner (August 2014)

   o  Martin Thomson (August 2015)

   o  Jouni Korhonen (November 2015)

   o  Dave Garrett (December 2015)

   o  Matt Miller (December 2015)

   o  Anirudh Ramachandran (March 2016)

   We would also to thank Martin Thomson, Karthikeyan Bhargavan, Sankalp
   Bagaria, and Eric Rescorla for their feedback regarding the
   fingerprint calculation.

   Finally, we would like to thank the TLS working group chairs, Sean
   Turner and Joe Salowey, as well as the responsible Security Area
   Director, Stephen Farrell, for their support and their reviews.



















Santesson & Tschofenig       Standards Track                   [Page 18]
   __________________________________________________________________


RFC 7924            TLS Cached Information Extension           July 2016


Authors' Addresses

   Stefan Santesson
   3xA Security AB
   Forskningsbyn Ideon
   Lund  223 70
   Sweden

   Email: sts@aaa-sec.com


   Hannes Tschofenig
   ARM Ltd.
   Hall in Tirol  6060
   Austria

   Email: Hannes.tschofenig@gmx.net
   URI:   http://www.tschofenig.priv.at

































Santesson & Tschofenig       Standards Track                   [Page 19]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
   [Docs] [txt|pdf] [draft-ietf-ipse...] [Tracker] [Diff1] [Diff2]
   [Errata]
   Updated by: 6151 INFORMATIONAL
   Errata Exist
Network Working Group                                       H. Krawczyk
Request for Comments: 2104                                          IBM
Category: Informational                                      M. Bellare
                                                                   UCSD
                                                             R. Canetti
                                                                    IBM
                                                          February 1997


             HMAC: Keyed-Hashing for Message Authentication

Status of This Memo

   This memo provides information for the Internet community.  This memo
   does not specify an Internet standard of any kind.  Distribution of
   this memo is unlimited.

Abstract

   This document describes HMAC, a mechanism for message authentication
   using cryptographic hash functions. HMAC can be used with any
   iterative cryptographic hash function, e.g., MD5, SHA-1, in
   combination with a secret shared key.  The cryptographic strength of
   HMAC depends on the properties of the underlying hash function.

1. Introduction

   Providing a way to check the integrity of information transmitted
   over or stored in an unreliable medium is a prime necessity in the
   world of open computing and communications. Mechanisms that provide
   such integrity check based on a secret key are usually called
   "message authentication codes" (MAC). Typically, message
   authentication codes are used between two parties that share a secret
   key in order to validate information transmitted between these
   parties. In this document we present such a MAC mechanism based on
   cryptographic hash functions. This mechanism, called HMAC, is based
   on work by the authors [BCK1] where the construction is presented and
   cryptographically analyzed. We refer to that work for the details on
   the rationale and security analysis of HMAC, and its comparison to
   other keyed-hash methods.











Krawczyk, et. al.            Informational                      [Page 1]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


   HMAC can be used in combination with any iterated cryptographic hash
   function. MD5 and SHA-1 are examples of such hash functions. HMAC
   also uses a secret key for calculation and verification of the
   message authentication values. The main goals behind this
   construction are

   * To use, without modifications, available hash functions.
     In particular, hash functions that perform well in software,
     and for which code is freely and widely available.

   * To preserve the original performance of the hash function without
     incurring a significant degradation.

   * To use and handle keys in a simple way.

   * To have a well understood cryptographic analysis of the strength of
     the authentication mechanism based on reasonable assumptions on the
     underlying hash function.

   * To allow for easy replaceability of the underlying hash function in
     case that faster or more secure hash functions are found or
     required.

   This document specifies HMAC using a generic cryptographic hash
   function (denoted by H). Specific instantiations of HMAC need to
   define a particular hash function. Current candidates for such hash
   functions include SHA-1 [SHA], MD5 [MD5], RIPEMD-128/160 [RIPEMD].
   These different realizations of HMAC will be denoted by HMAC-SHA1,
   HMAC-MD5, HMAC-RIPEMD, etc.

   Note: To the date of writing of this document MD5 and SHA-1 are the
   most widely used cryptographic hash functions. MD5 has been recently
   shown to be vulnerable to collision search attacks [Dobb].  This
   attack and other currently known weaknesses of MD5 do not compromise
   the use of MD5 within HMAC as specified in this document (see
   [Dobb]); however, SHA-1 appears to be a cryptographically stronger
   function. To this date, MD5 can be considered for use in HMAC for
   applications where the superior performance of MD5 is critical.   In
   any case, implementers and users need to be aware of possible
   cryptanalytic developments regarding any of these cryptographic hash
   functions, and the eventual need to replace the underlying hash
   function. (See section 6 for more information on the security of
   HMAC.)








Krawczyk, et. al.            Informational                      [Page 2]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


2. Definition of HMAC

   The definition of HMAC requires a cryptographic hash function, which
   we denote by H, and a secret key K. We assume H to be a cryptographic
   hash function where data is hashed by iterating a basic compression
   function on blocks of data.   We denote by B the byte-length of such
   blocks (B=64 for all the above mentioned examples of hash functions),
   and by L the byte-length of hash outputs (L=16 for MD5, L=20 for
   SHA-1).  The authentication key K can be of any length up to B, the
   block length of the hash function.  Applications that use keys longer
   than B bytes will first hash the key using H and then use the
   resultant L byte string as the actual key to HMAC. In any case the
   minimal recommended length for K is L bytes (as the hash output
   length). See section 3 for more information on keys.

   We define two fixed and different strings ipad and opad as follows
   (the 'i' and 'o' are mnemonics for inner and outer):

                   ipad = the byte 0x36 repeated B times
                  opad = the byte 0x5C repeated B times.

   To compute HMAC over the data `text' we perform

                    H(K XOR opad, H(K XOR ipad, text))

   Namely,

    (1) append zeros to the end of K to create a B byte string
        (e.g., if K is of length 20 bytes and B=64, then K will be
         appended with 44 zero bytes 0x00)
    (2) XOR (bitwise exclusive-OR) the B byte string computed in step
        (1) with ipad
    (3) append the stream of data 'text' to the B byte string resulting
        from step (2)
    (4) apply H to the stream generated in step (3)
    (5) XOR (bitwise exclusive-OR) the B byte string computed in
        step (1) with opad
    (6) append the H result from step (4) to the B byte string
        resulting from step (5)
    (7) apply H to the stream generated in step (6) and output
        the result

   For illustration purposes, sample code based on MD5 is provided as an
   appendix.







Krawczyk, et. al.            Informational                      [Page 3]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


3. Keys

   The key for HMAC can be of any length (keys longer than B bytes are
   first hashed using H).  However, less than L bytes is strongly
   discouraged as it would decrease the security strength of the
   function.  Keys longer than L bytes are acceptable but the extra
   length would not significantly increase the function strength. (A
   longer key may be advisable if the randomness of the key is
   considered weak.)

   Keys need to be chosen at random (or using a cryptographically strong
   pseudo-random generator seeded with a random seed), and periodically
   refreshed.  (Current attacks do not indicate a specific recommended
   frequency for key changes as these attacks are practically
   infeasible.  However, periodic key refreshment is a fundamental
   security practice that helps against potential weaknesses of the
   function and keys, and limits the damage of an exposed key.)

4. Implementation Note

   HMAC is defined in such a way that the underlying hash function H can
   be used with no modification to its code. In particular, it uses the
   function H with the pre-defined initial value IV (a fixed value
   specified by each iterative hash function to initialize its
   compression function).  However, if desired, a performance
   improvement can be achieved at the cost of (possibly) modifying the
   code of H to support variable IVs.

   The idea is that the intermediate results of the compression function
   on the B-byte blocks (K XOR ipad) and (K XOR opad) can be precomputed
   only once at the time of generation of the key K, or before its first
   use. These intermediate results are stored and then used to
   initialize the IV of H each time that a message needs to be
   authenticated.  This method saves, for each authenticated message,
   the application of the compression function of H on two B-byte blocks
   (i.e., on (K XOR ipad) and (K XOR opad)). Such a savings may be
   significant when authenticating short streams of data.  We stress
   that the stored intermediate values need to be treated and protected
   the same as secret keys.

   Choosing to implement HMAC in the above way is a decision of the
   local implementation and has no effect on inter-operability.









Krawczyk, et. al.            Informational                      [Page 4]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


5. Truncated output

   A well-known practice with message authentication codes is to
   truncate the output of the MAC and output only part of the bits
   (e.g., [MM, ANSI]).  Preneel and van Oorschot [PV] show some
   analytical advantages of truncating the output of hash-based MAC
   functions. The results in this area are not absolute as for the
   overall security advantages of truncation. It has advantages (less
   information on the hash result available to an attacker) and
   disadvantages (less bits to predict for the attacker).  Applications
   of HMAC can choose to truncate the output of HMAC by outputting the t
   leftmost bits of the HMAC computation for some parameter t (namely,
   the computation is carried in the normal way as defined in section 2
   above but the end result is truncated to t bits). We recommend that
   the output length t be not less than half the length of the hash
   output (to match the birthday attack bound) and not less than 80 bits
   (a suitable lower bound on the number of bits that need to be
   predicted by an attacker).  We propose denoting a realization of HMAC
   that uses a hash function H with t bits of output as HMAC-H-t. For
   example, HMAC-SHA1-80 denotes HMAC computed using the SHA-1 function
   and with the output truncated to 80 bits.  (If the parameter t is not
   specified, e.g. HMAC-MD5, then it is assumed that all the bits of the
   hash are output.)

6. Security

   The security of the message authentication mechanism presented here
   depends on cryptographic properties of the hash function H: the
   resistance to collision finding (limited to the case where the
   initial value is secret and random, and where the output of the
   function is not explicitly available to the attacker), and the
   message authentication property of the compression function of H when
   applied to single blocks (in HMAC these blocks are partially unknown
   to an attacker as they contain the result of the inner H computation
   and, in particular, cannot be fully chosen by the attacker).

   These properties, and actually stronger ones, are commonly assumed
   for hash functions of the kind used with HMAC. In particular, a hash
   function for which the above properties do not hold would become
   unsuitable for most (probably, all) cryptographic applications,
   including alternative message authentication schemes based on such
   functions.  (For a complete analysis and rationale of the HMAC
   function the reader is referred to [BCK1].)








Krawczyk, et. al.            Informational                      [Page 5]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


   Given the limited confidence gained so far as for the cryptographic
   strength of candidate hash functions, it is important to observe the
   following two properties of the HMAC construction and its secure use
   for message authentication:

   1. The construction is independent of the details of the particular
   hash function H in use and then the latter can be replaced by any
   other secure (iterative) cryptographic hash function.

   2. Message authentication, as opposed to encryption, has a
   "transient" effect. A published breaking of a message authentication
   scheme would lead to the replacement of that scheme, but would have
   no adversarial effect on information authenticated in the past.  This
   is in sharp contrast with encryption, where information encrypted
   today may suffer from exposure in the future if, and when, the
   encryption algorithm is broken.

   The strongest attack known against HMAC is based on the frequency of
   collisions for the hash function H ("birthday attack") [PV,BCK2], and
   is totally impractical for minimally reasonable hash functions.

   As an example, if we consider a hash function like MD5 where the
   output length equals L=16 bytes (128 bits) the attacker needs to
   acquire the correct message authentication tags computed (with the
   _same_ secret key K!) on about 2**64 known plaintexts.  This would
   require the processing of at least 2**64 blocks under H, an
   impossible task in any realistic scenario (for a block length of 64
   bytes this would take 250,000 years in a continuous 1Gbps link, and
   without changing the secret key K during all this time).  This attack
   could become realistic only if serious flaws in the collision
   behavior of the function H are discovered (e.g.  collisions found
   after 2**30 messages). Such a discovery would determine the immediate
   replacement of the function H (the effects of such failure would be
   far more severe for the traditional uses of H in the context of
   digital signatures, public key certificates, etc.).

   Note: this attack needs to be strongly contrasted with regular
   collision attacks on cryptographic hash functions where no secret key
   is involved and where 2**64 off-line parallelizable (!) operations
   suffice to find collisions.  The latter attack is approaching
   feasibility [VW] while the birthday attack on HMAC is totally
   impractical.  (In the above examples, if one uses a hash function
   with, say, 160 bit of output then 2**64 should be replaced by 2**80.)








Krawczyk, et. al.            Informational                      [Page 6]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


   A correct implementation of the above construction, the choice of
   random (or cryptographically pseudorandom) keys, a secure key
   exchange mechanism, frequent key refreshments, and good secrecy
   protection of keys are all essential ingredients for the security of
   the integrity verification mechanism provided by HMAC.














































Krawczyk, et. al.            Informational                      [Page 7]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


Appendix -- Sample Code

   For the sake of illustration we provide the following sample code for
   the implementation of HMAC-MD5 as well as some corresponding test
   vectors (the code is based on MD5 code as described in [MD5]).

/*
** Function: hmac_md5
*/

void
hmac_md5(text, text_len, key, key_len, digest)
unsigned char*  text;                /* pointer to data stream */
int             text_len;            /* length of data stream */
unsigned char*  key;                 /* pointer to authentication key */
int             key_len;             /* length of authentication key */
caddr_t         digest;              /* caller digest to be filled in */

{
        MD5_CTX context;
        unsigned char k_ipad[65];    /* inner padding -
                                      * key XORd with ipad
                                      */
        unsigned char k_opad[65];    /* outer padding -
                                      * key XORd with opad
                                      */
        unsigned char tk[16];
        int i;
        /* if key is longer than 64 bytes reset it to key=MD5(key) */
        if (key_len > 64) {

                MD5_CTX      tctx;

                MD5Init(&tctx);
                MD5Update(&tctx, key, key_len);
                MD5Final(tk, &tctx);

                key = tk;
                key_len = 16;
        }

        /*
         * the HMAC_MD5 transform looks like:
         *
         * MD5(K XOR opad, MD5(K XOR ipad, text))
         *
         * where K is an n byte key
         * ipad is the byte 0x36 repeated 64 times



Krawczyk, et. al.            Informational                      [Page 8]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


         * opad is the byte 0x5c repeated 64 times
         * and text is the data being protected
         */

        /* start out by storing key in pads */
        bzero( k_ipad, sizeof k_ipad);
        bzero( k_opad, sizeof k_opad);
        bcopy( key, k_ipad, key_len);
        bcopy( key, k_opad, key_len);

        /* XOR key with ipad and opad values */
        for (i=0; i<64; i++) {
                k_ipad[i] ^= 0x36;
                k_opad[i] ^= 0x5c;
        }
        /*
         * perform inner MD5
         */
        MD5Init(&context);                   /* init context for 1st
                                              * pass */
        MD5Update(&context, k_ipad, 64)      /* start with inner pad */
        MD5Update(&context, text, text_len); /* then text of datagram */
        MD5Final(digest, &context);          /* finish up 1st pass */
        /*
         * perform outer MD5
         */
        MD5Init(&context);                   /* init context for 2nd
                                              * pass */
        MD5Update(&context, k_opad, 64);     /* start with outer pad */
        MD5Update(&context, digest, 16);     /* then results of 1st
                                              * hash */
        MD5Final(digest, &context);          /* finish up 2nd pass */
}

Test Vectors (Trailing '\0' of a character string not included in test):

  key =         0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b
  key_len =     16 bytes
  data =        "Hi There"
  data_len =    8  bytes
  digest =      0x9294727a3638bb1c13f48ef8158bfc9d

  key =         "Jefe"
  data =        "what do ya want for nothing?"
  data_len =    28 bytes
  digest =      0x750c783e6ab0b503eaa86e310a5db738

  key =         0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA



Krawczyk, et. al.            Informational                      [Page 9]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


  key_len       16 bytes
  data =        0xDDDDDDDDDDDDDDDDDDDD...
                ..DDDDDDDDDDDDDDDDDDDD...
                ..DDDDDDDDDDDDDDDDDDDD...
                ..DDDDDDDDDDDDDDDDDDDD...
                ..DDDDDDDDDDDDDDDDDDDD
  data_len =    50 bytes
  digest =      0x56be34521d144c88dbb8c733f0e8b3f6

Acknowledgments

   Pau-Chen Cheng, Jeff Kraemer, and Michael Oehler, have provided
   useful comments on early drafts, and ran the first interoperability
   tests of this specification. Jeff and Pau-Chen kindly provided the
   sample code and test vectors that appear in the appendix.  Burt
   Kaliski, Bart Preneel, Matt Robshaw, Adi Shamir, and Paul van
   Oorschot have provided useful comments and suggestions during the
   investigation of the HMAC construction.

References

   [ANSI]  ANSI X9.9, "American National Standard for Financial
           Institution Message Authentication (Wholesale)," American
           Bankers Association, 1981.   Revised 1986.

   [Atk]   Atkinson, R., "IP Authentication Header", RFC 1826, August
           1995.

   [BCK1]  M. Bellare, R. Canetti, and H. Krawczyk,
           "Keyed Hash Functions and Message Authentication",
           Proceedings of Crypto'96, LNCS 1109, pp. 1-15.
           (http://www.research.ibm.com/security/keyed-md5.html)

   [BCK2]  M. Bellare, R. Canetti, and H. Krawczyk,
           "Pseudorandom Functions Revisited: The Cascade Construction",
           Proceedings of FOCS'96.

   [Dobb]  H. Dobbertin, "The Status of MD5  After a Recent Attack",
           RSA Labs' CryptoBytes, Vol. 2 No. 2, Summer 1996.
           http://www.rsa.com/rsalabs/pubs/cryptobytes.html

   [PV]    B. Preneel and P. van Oorschot, "Building fast MACs from hash
           functions", Advances in Cryptology -- CRYPTO'95 Proceedings,
           Lecture Notes in Computer Science, Springer-Verlag Vol.963,
           1995, pp. 1-14.

   [MD5]   Rivest, R., "The MD5 Message-Digest Algorithm",
           RFC 1321, April 1992.



Krawczyk, et. al.            Informational                     [Page 10]
   __________________________________________________________________


RFC 2104                          HMAC                     February 1997


   [MM]    Meyer, S. and Matyas, S.M., Cryptography, New York Wiley,
           1982.

   [RIPEMD] H. Dobbertin, A. Bosselaers, and B. Preneel, "RIPEMD-160: A
            strengthened version of RIPEMD", Fast Software Encryption,
            LNCS Vol 1039, pp. 71-82.
            ftp://ftp.esat.kuleuven.ac.be/pub/COSIC/bosselae/ripemd/.

   [SHA]   NIST, FIPS PUB 180-1: Secure Hash Standard, April 1995.

   [Tsu]   G. Tsudik, "Message authentication with one-way hash
           functions", In Proceedings of Infocom'92, May 1992.
           (Also in "Access Control and Policy Enforcement in
            Internetworks", Ph.D. Dissertation, Computer Science
            Department, University of Southern California, April 1991.)

   [VW]    P. van Oorschot and M. Wiener, "Parallel Collision
           Search with Applications to Hash Functions and Discrete
           Logarithms", Proceedings of the 2nd ACM Conf. Computer and
           Communications Security, Fairfax, VA, November 1994.

Authors' Addresses

   Hugo Krawczyk
   IBM T.J. Watson Research Center
   P.O.Box 704
   Yorktown Heights, NY 10598

   EMail: hugo@watson.ibm.com

   Mihir Bellare
   Dept of Computer Science and Engineering
   Mail Code 0114
   University of California at San Diego
   9500 Gilman Drive
   La Jolla, CA 92093

   EMail: mihir@cs.ucsd.edu

   Ran Canetti
   IBM T.J. Watson Research Center
   P.O.Box 704
   Yorktown Heights, NY 10598

   EMail: canetti@watson.ibm.com






Krawczyk, et. al.            Informational                     [Page 11]


   Html markup produced by rfcmarkup 1.129c, available from
   https://tools.ietf.org/tools/rfcmarkup/
