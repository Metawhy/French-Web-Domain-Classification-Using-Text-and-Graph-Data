    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Multiple file access functions Installation

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
          + A simple example program
          + Modules and Libraries
          + Types
          + Constants
     * Multiple file access functions
     * Single file access functions
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Library interface
     *
     __________________________________________________________________

Library interface¶

A simple example program¶

   The following example program shows the typical usage of the Fortran
   2003 interface.

   Other examples using the Fortran 2003 interface can be found in the
   directory examples of the library sources.
program f2003multiple
    USE, INTRINSIC :: ISO_C_BINDING
    use calceph
    integer res
    real(8) AU
    TYPE(C_PTR) :: peph

    peph = calceph_open("example1.dat"//C_NULL_CHAR)
    if (C_ASSOCIATED(peph)) then

       if (calceph_getconstant(peph, "AU"//C_NULL_CHAR, AU).eq.1) then
            write (*,*) "AU=", AU
       endif

       call calceph_close(peph)
     endif
stop
end

Modules and Libraries¶

   All declarations needed to use CALCEPH Library are collected in the
   module files calceph.mod. The library is designed to work with Fortran
   compilers compliant with the Fortran 2003 standard. All declarations
   use the standard ISO_C_BINDING module.

   You should include that module in any program using the CALCEPH
   library:
use calceph

   When a fortran string is given as a parameter to a function of this
   library, you should append this string with //C_NULL_CHAR because the C
   library works only with C string.

Compilation on a Unix-like system¶

   All programs using CALCEPH must link against the libcalceph library. On
   Unix-like system this can be done with -lcalceph, for example

gfortran -I/usr/local/include myprogram.f -o myprogram -lcalceph

   If CALCEPH Library has been installed to a non-standard location then
   it may be necessary to use -I and -L compiler options to point to the
   right directories, and some sort of run-time path for a shared library.

Compilation on a Windows system¶

   All programs using CALCEPH must link against the libcalceph.lib. On
   Windows system this can be done with libcalceph.lib, for example

gfortran.exe /out:myprogram.exe myprogram.f libcalceph.lib

   If CALCEPH Library has been installed to a non-standard location then
   it may be necessary to use /I and /LIBPATH: compiler options to point
   to the right directories.

Types¶

Constants¶

   The following constants are defined in the module calceph.mod.

   CALCEPH_MAX_CONSTANTNAME [integer]¶

   This integer defines the maximum number of characters, including the
   trailing '\0', that the name of a constant, available from the
   ephemeris file, could contain.

   CALCEPH_MAX_CONSTANTVALUE [integer]¶

   This integer defines the maximum number of characters, including the
   trailing '\0', that the value of a constant, available from the
   ephemeris file, could contain if the value is stored as a string of
   characters.

   CALCEPH_VERSION_MAJOR [integer]¶

   This integer constant defines the major revision of this library. It
   can be used to distinguish different releases of this library.

   CALCEPH_VERSION_MINOR [integer]¶

   This integer constant defines the minor revision of this library. It
   can be used to distinguish different releases of this library.

   CALCEPH_VERSION_PATCH [integer]¶

   This integer constant defines the patch level revision of this library.
   It can be used to distinguish different releases of this library.

   CALCEPH_VERSION_STRING [character(len=*)]¶

   This string is the version of the library, which can be compared to the
   result of calceph_getversion to check at run time if the header file
   and library used match:

   Note: Obtaining different strings is not necessarily an error, as in
   general, a program compiled with some old CALCEPH version can be
   dynamically linked with a newer CALCEPH library version (if allowed by
   the operating system).

   CALCEPH_ASTEROID [integer]¶

   This integer defines the offset value for the asteroids that must be
   used as target or center for the computation functions, such as
   calceph_compute().

   The following constants specify in which units are expressed the output
   of the computation functions, such as calceph_compute_unit() :

   CALCEPH_UNIT_AU [integer]¶

   This integer defines that the unit of the positions and velocities is
   expressed in astronomical unit.

   CALCEPH_UNIT_KM [integer]¶

   This integer defines that the unit of the positions and velocities is
   expressed in kilometer.

   CALCEPH_UNIT_DAY [integer]¶

   This integer defines that the unit of the velocities or the quantity
   TT-TDB or TCG-TCB is expressed in day (one day=86400 seconds).

   CALCEPH_UNIT_SEC [integer]¶

   This integer defines that the unit of the velocities or the quantity
   TT-TDB or TCG-TCB is expressed in second.

   CALCEPH_UNIT_RAD [integer]¶

   This integer defines that the unit of the angles is expressed in
   radian.

   CALCEPH_OUTPUT_EULERANGLES [integer]¶

   This integer defines that the output array contains the euler angles.

   CALCEPH_OUTPUT_NUTATIONANGLES [integer]¶

   This integer defines that the output array contains the nutation
   angles.

   CALCEPH_USE_NAIFID [integer]¶

   This integer defines that the NAIF identification numbers are used as
   target or center for the computation functions, such as
   calceph_compute_unit().

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Single file access functions Library interface

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
          + Thread notes
          + Usage
          + Functions
               o calceph_open
               o calceph_open_array
               o calceph_prefetch
               o calceph_isthreadsafe
               o calceph_compute
               o calceph_compute_unit
               o calceph_orient_unit
               o calceph_rotangmom_unit
               o calceph_compute_order
               o calceph_orient_order
               o calceph_rotangmom_order
               o calceph_getconstant
               o calceph_getconstantsd
               o calceph_getconstantvd
               o calceph_getconstantss
               o calceph_getconstantvs
               o calceph_getconstantcount
               o calceph_getconstantindex
               o calceph_getfileversion
               o calceph_gettimescale
               o calceph_gettimespan
               o calceph_getpositionrecordcount
               o calceph_getpositionrecordindex
               o calceph_getorientrecordcount
               o calceph_getorientrecordindex
               o calceph_close
     * Single file access functions
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Multiple file access functions
     *
     __________________________________________________________________

Multiple file access functions¶

   The following group of functions should be the preferred method to
   access to the library. They allow to access to multiple ephemeris files
   at the same time, even by multiple threads.

   When an error occurs, these functions execute error handlers according
   to the behavior defined by the function calceph_seterrorhandler().

Thread notes¶

   If the standard I/O functions such as fread are not reentrant then the
   CALCEPH I/O functions using them will not be reentrant either.

   It's safe for two threads to call the functions with the same handle of
   ephemeris object if and only if the function calceph_isthreadsafe()
   returns a non-zero value. A previous call to the function
   calceph_prefetch() is required for the function calceph_isthreadsafe()
   to return a non-zero value.

   It's safe for two threads to access simultaneously to the same
   ephemeris file with two different objects. In this case, each thread
   must open the same file.

Usage¶

   The following examples, that can be found in the directory examples of
   the library sources, show the typical usage of this group of functions.

   The example in Fortran 2003 language is f2003multiple.f.
 program f2003multiple
     USE, INTRINSIC :: ISO_C_BINDING
     use calceph
     implicit none
     integer res
     real(8) AU, EMRAT, GM_Mer
     real(8) jd0
     real(8) dt
     real(8) PV(6)
     TYPE(C_PTR) :: peph

     jd0 = 2451624
     dt = 0.5E0
     ! open the ephemeris file
     peph = calceph_open("example1.dat"//C_NULL_CHAR)
     if (C_ASSOCIATED(peph)) then
         write (*,*) "The ephemeris is already opened"
         ! print the values of AU, EMRAT and GM_Mer
         if (calceph_getconstant(peph, "AU"//C_NULL_CHAR, AU).eq.1) then
             write (*,*) "AU=", AU
        endif
        if (calceph_getconstant(peph,"EMRAT"//C_NULL_CHAR, EMRAT).eq.1) then
             write (*,*) "EMRAT=", EMRAT
        endif
        if (calceph_getconstant(peph,"GM_Mer"//C_NULL_CHAR, GM_Mer).eq.1) then
             write (*,*) "GM_Mer=", GM_Mer
        endif

        ! compute and print the coordinates
        ! the geocentric moon coordinates
        res = calceph_compute(peph,jd0, dt, 10, 3, PV)
        call printcoord(PV,"geocentric coordinates of the Moon")
        ! the value TT-TDB
        if (calceph_compute(peph,jd0, dt, 16, 0, PV).eq.1) then
         write (*,*) "TT-TDB = ", PV(1)
        endif
        ! the heliocentric coordinates of Mars
        res = calceph_compute(peph,jd0, dt, 4, 11, PV)
        call printcoord(PV,"heliocentric coordinates of Mars")

        ! close the ephemeris file
        call calceph_close(peph)
        write (*,*) "The ephemeris is already closed"
    else
        write (*,*) "The ephemeris can't be opened"
    endif
stop
end

Functions¶

calceph_open¶

   function calceph_open(filename) BIND(C)¶

   Parameters: filename [CHARACTER(len=1,kind=C_CHAR), intent(in)] ::
   pathname of the file.
   Return: calceph_open [TYPE(C_PTR)] :: ephemeris descriptor. This value
   is C_NULL_PTR if an error occurs, otherwise non-C_NULL_PTR value.

   This function opens the file whose pathname is the string pointed to by
   filename, reads the two header blocks of this file and returns an
   ephemeris descriptor associated to it. This file must be compliant to
   the format specified by the 'original JPL binary' , 'INPOP 2.0 binary'
   or 'SPICE' ephemeris file. At the moment, supported SPICE files are the
   following :

     * text Planetary Constants Kernel (KPL/PCK) files
     * binary PCK (DAF/PCK) files.
     * binary SPK (DAF/SPK) files containing segments of type 1, 2, 3, 5,
       8, 9, 12, 13, 17, 18, 20, 21, 102, 103 and 120.
     * meta kernel (KPL/MK) files.
     * frame kernel (KPL/FK) files. Only a basic support is provided.

   Just after the call of calceph_open(), the function calceph_prefetch()
   should be called to accelerate future computations.

   The function calceph_close() must be called to free allocated memory by
   this function.

   The following example opens the ephemeris file example1.dat
USE, INTRINSIC :: ISO_C_BINDING
use calceph
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

     ! ... computation ...

endif
call calceph_close(peph)

calceph_open_array¶

   function calceph_open_array(n, array_filename, len_filename) BIND(C)¶

   Parameters:
          + n [INTEGER(C_INT), VALUE, intent(in)] :: number of files.
          + array_filename [CHARACTER(len=1,kind=C_CHAR), dimension(*),
            intent(in)] :: array of pathname of the files.
          + len_filename [INTEGER(C_INT), VALUE, intent(in)] :: number of
            characters of each file's name.

            Return:

   calceph_open_array [TYPE(C_PTR)] :: ephemeris descriptor. This value is
   C_NULL_PTR if an error occurs, otherwise non-C_NULL_PTR value.

   This function opens n files whose pathnames are the string pointed to
   by array_filename, reads the header blocks of these files and returns
   an ephemeris descriptor associated to them.

   These files must have the same type (e.g., all files are SPICE files or
   original JPL files). This file must be compliant to the format
   specified by the 'original JPL binary' , 'INPOP 2.0 or 3.0 binary' or
   'SPICE' ephemeris file. At the moment, supported SPICE files are the
   following :

     * text Planetary Constants Kernel (KPL/PCK) files
     * binary PCK (DAF/PCK) files.
     * binary SPK (DAF/SPK) files containing segments of type 1, 2, 3, 5,
       8, 9, 12, 13, 17, 18, 20, 21, 102, 103 and 120.
     * meta kernel (KPL/MK) files.
     * frame kernel (KPL/FK) files. Only a basic support is provided.

   Just after the call of calceph_open_array(), the function
   calceph_prefetch() should be called to accelerate future computations.

   The function calceph_close() must be called to free allocated memory by
   this function.

   The following example opens the ephemeris file example1.bsp and
   example1.tpc
TYPE(C_PTR) :: peph
character(len=256), dimension (2) :: filear
filear(1) = "example1.bsp"//C_NULL_CHAR
filear(2) = "example1.tpc"//C_NULL_CHAR
peph = calceph_open_array(2, filear, 256)
if (C_ASSOCIATED(peph)) then
  res = calceph_prefetch(peph)
  ! ...  computation ...
  call calceph_close(peph)
endif

calceph_prefetch¶

   function calceph_prefetch(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor.
   Return: calceph_prefetch [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function prefetches to the main memory all files associated to the
   ephemeris descriptor eph. This prefetching operation will accelerate
   the further computations performed with calceph_compute(),
   calceph_compute_unit(), calceph_compute_order(), calceph_orient_unit(),
   ... .

   It requires that the file is smaller than the main memory. If multiple
   threads (e.g. threads of openMP or Posix Pthreads) prefetch the data
   for the same ephemeris file, the used memory will remain the same as if
   the prefetch operation was done by a single thread if and if the
   endianess of the file is the same as the computer and if the operating
   system, such as Linux, MacOS X other unix, supports the function mmap.

calceph_isthreadsafe¶

   function calceph_isthreadsafe(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor.
   Return: calceph_isthreadsafe [INTEGER(C_INT)] :: returns 1 if multiple
   threads can access the same ephemeris ephemeris descriptor, otherwise
   0.

   This function returns 1 if multiple threads can access the same
   ephemeris ephemeris descriptor, otherwise 0.

   A previous call to the function calceph_prefetch() is required, and the
   library should becompiled with --enable-thread=yes on Unix-like
   operating system, for the function calceph_isthreadsafe() to return a
   non-zero value.

   If this function returns 1, severals threads may use the same ephemeris
   descriptor for the computational functions calceph_compute(), .... It
   allows to use the same object for parallel loops.

calceph_compute¶

   function calceph_compute(eph, JD0, time, target, center, PV ) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body or
            reference point whose coordinates are required (see the list,
            below).
          + center [INTEGER(C_INT), VALUE, intent(in)] :: The origin of
            the coordinate system (see the list, below). If target is 14,
            15, 16 or 17 (nutation, libration, TT-TDB or TCG-TCB), center
            must be 0.
          + PV [REAL(C_DOUBLE), dimension(1:6), intent(out)] :: Depending
            on the target value, an array to receive the cartesian
            position (x,y,z) and the velocity (xdot, ydot, zdot), or a
            time scale transformation value, or the angles of the
            librations of the Moon and their derivatives, or the nutation
            angles and their derivatives.

            Return:

   calceph_compute [INTEGER(C_INT)] :: 0 if an error occurs, otherwise
   non-zero value.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates a single object, usually the position and velocity of
   one body (target) relative to another (center) for the time JD0+time
   and stores the results to PV. The ephemeris file associated to eph must
   have been previously opened with the function calceph_open().

   The returned array PV has the following properties

     * If the target is TT-TDB, only the first element of this array will
       get the result. The time scale transformation TT-TDB is expressed
       in seconds.
     * If the target is TCG-TCB, only the first element of this array will
       get the result. The time scale transformation TCG-TCB is expressed
       in seconds.
     * If the target is Librations, the array contains the angles of the
       librations of the Moon and their derivatives. The angles of the
       librations of the Moon are expressed in radians and their
       derivatives are expressed in radians per day.
     * If the target is Nutations, the array contains the nutation angles
       and their derivatives. The nutation angles are expressed in radians
       and their derivatives are expressed in radians per day.
     * Otherwise the returned values is the cartesian position (x,y,z),
       expressed in Astronomical Unit (au), and the velocity (xdot, ydot,
       zdot), expressed in Astronomical Unit per day (au/day).

   To get the best numerical precision for the interpolation, the time is
   splitted in two floating-point numbers. The argument JD0 should be an
   integer and time should be a fraction of the day. But you may call this
   function with time=0 and JD0, the desired time, if you don't take care
   about numerical precision.

   The possible values for target and center are :
                 value                       meaning
   1                                  Mercury Barycenter
   2                                  Venus Barycenter
   3                                  Earth
   4                                  Mars Barycenter
   5                                  Jupiter Barycenter
   6                                  Saturn Barycenter
   7                                  Uranus Barycenter
   8                                  Neptune Barycenter
   9                                  Pluto Barycenter
   10                                 Moon
   11                                 Sun
   12                                 Solar Sytem barycenter
   13                                 Earth-moon barycenter
   14                                 Nutation angles
   15                                 Librations
   16                                 TT-TDB
   17                                 TCG-TCB
   asteroid number + CALCEPH_ASTEROID asteroid

   These accepted values by this function are the same as the value for
   the JPL function PLEPH, except for the values TT-TDB, TCG-TCB and
   asteroids.

   For example, the value "CALCEPH_ASTEROID+4" for target or center
   specifies the asteroid Vesta.

   The following example prints the heliocentric coordinates of Mars at
   time=2442457.5 and at 2442457.9
integer*8 peph
integer res
real(8) jd0
real(8) dt1, dt2
real(8) PV(6)
TYPE(C_PTR) :: peph

jd0 = 2442457
dt1 = 0.5D0
dt2 = 0.9D0
peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   ! the heliocentric coordinates of Mars
   res = calceph_compute(peph,jd0, dt1, 4, 11, PV)
   write(*,*) PV

   res = calceph_compute(peph,jd0, dt2, 4, 11, PV)
   write(*,*) PV

    call calceph_close(peph)
 endif

calceph_compute_unit¶

   function calceph_compute_unit(eph, JD0, time, target, center, unit, PV
          ) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body or
            reference point whose coordinates are required. The numbering
            system depends on the parameter unit.
          + center [INTEGER(C_INT), VALUE, intent(in)] :: The origin of
            the coordinate system. The numbering system depends on the
            parameter unit.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PV.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target and the
            center (NAIF identification numbers for the list).
            If the unit doesnot contain CALCEPH_USE_NAIFID, the old number
            system is used for the target and the center (see the list in
            the function calceph_compute()).
          + PV [REAL(C_DOUBLE), dimension(1:6), intent(out)] :: Depending
            on the target value, an array to receive the cartesian
            position (x,y,z) and the velocity (xdot, ydot, zdot), or a
            time scale transformation value, or the angles of the
            librations of the Moon and their derivatives, or the nutation
            angles and their derivatives.

            Return:

   calceph_compute_unit [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function is similar to the function calceph_compute(), except that
   the units of the output are specified.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates a single object, usually the position and velocity of
   one body (target) relative to another (center) for the time JD0+time
   and stores the results to PV. The ephemeris file associated to eph must
   have been previously opened with the function calceph_open(). The
   output values are expressed in the units specified by unit.

   This function checks the units if invalid combinations of units are
   given to the function.

   The returned array PV has the following properties

     * If the target is the time scale transformation TT-TDB, only the
       first element of this array will get the result.
     * If the target is the time scale transformation TCG-TCB, only the
       first element of this array will get the result.
     * If the target is Librations, the array contains the angles of the
       librations of the Moon and their derivatives.
     * If the target is Nutations, the array contains the nutation angles
       and their derivatives.
     * Otherwise the returned value is the cartesian position (x,y,z) and
       the velocity (xdot, ydot, zdot).

   The values stored in the array PV are expressed in the following units

     * The position and velocity are expressed in Astronomical Unit (au)
       if unit contains CALCEPH_UNIT_AU.
     * The position and velocity are expressed in kilometers if unit
       contains CALCEPH_UNIT_KM.
     * The velocity, TT-TDB, TCG-TCB, the derivatives of the angles of the
       nutation, or the derivatives of the librations of the Moon or are
       expressed in days if unit contains CALCEPH_UNIT_DAY.
     * The velocity, TT-TDB, TCG-TCB, the derivatives of the angles of the
       nutation, or the derivatives of the librations of the Moon are
       expressed in seconds if unit contains CALCEPH_UNIT_SEC.
     * The angles of the librations of the Moon or the nutation angles are
       expressed in radians if unit contains CALCEPH_UNIT_RAD.

   For example, to get the position and velocities expressed in kilometers
   and kilometers/seconds, the unit must be set to CALCEPH_UNIT_KM +
   CALCEPH_UNIT_SEC.

   The following example prints the heliocentric coordinates of Mars at
   time=2442457.5
integer res
real(8) jd0
real(8) dt1
real(8) PV(6)
TYPE(C_PTR) :: peph

jd0 = 2442457
dt1 = 0.5D0
peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   ! the heliocentric coordinates of Mars  in km and km/s
   res = calceph_compute_unit(peph,jd0, dt1, 4, 11,
&                            CALCEPH_UNIT_KM+CALCEPH_UNIT_SEC,
&                            PV)
   write(*,*) PV

   ! compute same quantity as the previous call using NAIF ID
   res = calceph_compute_unit(peph,jd0, dt1,
&                            NAIFID_MARS_BARYCENTER, NAIFID_SUN,
&                            CALCEPH_USE_NAIFID+CALCEPH_UNIT_KM+CALCEPH_UNIT_SEC
,
&                            PV)
   write(*,*) PV

    call calceph_close(peph)
 endif

calceph_orient_unit¶

   function calceph_orient_unit(eph, JD0, time, target, unit, PV) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body whose
            orientations are requested. The numbering system depends on
            the parameter unit.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PV.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target (NAIF
            identification numbers for the list).
            If the unit does not contain CALCEPH_USE_NAIFID, the old
            number system is used for the target (see the list in the
            function calceph_compute()).
          + PV [REAL(C_DOUBLE), dimension(1:6), intent(out)] :: An array
            to receive the euler angles, or nutation angles, and their
            derivatives for the orientation of the body.

            Return:

   calceph_orient_unit [INTEGER(C_INT)] :: 0 if an error occurs, otherwise
   non-zero value.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates the orientation of a single body (target) for the time
   JD0+time and stores the results to PV. The ephemeris file associated to
   eph must have been previously opened with the function calceph_open().
   The output values are expressed in the units specified by unit.

   This function checks the units if invalid combinations of units are
   given to the function.

   The returned array PV has the following properties

     * If unit contains CALCEPH_OUTPUT_NUTATIONANGLES, the array contains
       the nutation angles and their derivatives for the orientation of
       the body. At the present moment, only the nutation for the earth
       are supported in the original DE files.
     * If unit contains CALCEPH_OUTPUT_EULERANGLES, or doesnot contain
       CALCEPH_OUTPUT_NUTATIONANGLES, the array contains the euler angles
       and their derivatives for the orientation of the body.

   The values stored in the array PV are expressed in the following units

     * The derivatives of the angles are expressed in days if unit
       contains CALCEPH_UNIT_DAY.
     * The derivatives of the angles are expressed in seconds if unit
       contains CALCEPH_UNIT_SEC.
     * The angles and their derivatives are expressed in radians if unit
       contains CALCEPH_UNIT_RAD.

   For example, to get the nutation angles of the Earth and their
   derivatives expressed in radian and radian/seconds using the NAIF
   identification numbering system, the target must be set to NAIFID_EARTH
   and the unit must be set to CALCEPH_OUTPUT_NUTATIONANGLES +
   CALCEPH_UNIT_RAD + CALCEPH_UNIT_SEC.

   The following example prints the angles of libration of the Moon at
   time=2442457.5
integer res
real(8) jd0
real(8) dt1
real(8) PV(6)
TYPE(C_PTR) :: peph

jd0 = 2442457
dt1 = 0.5D0
peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   res = calceph_orient_unit(peph,jd0, dt1, NAIFID_MOON,
&                            CALCEPH_USE_NAIFID+CALCEPH_UNIT_RAD+CALCEPH_UNIT_SE
C,
&                            PV)
   write(*,*) PV

    call calceph_close(peph)
 endif

calceph_rotangmom_unit¶

   function calceph_rotangmom_unit(eph, JD0, time, target, unit, PV)
          BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body whose
            orientations are requested. The numbering system depends on
            the parameter unit.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PV.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target (NAIF
            identification numbers for the list).
            If the unit does not contain CALCEPH_USE_NAIFID, the old
            number system is used for the target (see the list in the
            function calceph_compute()).
          + PV [REAL(C_DOUBLE), dimension(1:6), intent(out)] :: An array
            to receive the angular momentum due to its rotation, divided
            by the product of the mass and of the square of the radius,
            and the derivatives, of the body.

            Return:

   calceph_rotangmom_unit [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates the angular momentum vector due to the rotation of the
   body, divided by the product of the mass m and of the square of the
   radius R , of a single body (target) for the time JD0+time and stores
   the results to PV. The ephemeris file associated to eph must have been
   previously opened with the function calceph_open(). The angular
   momentum L , due to the rotation of the body, is defined as the product
   of the inertia matrix I by the angular velocity vector {\omega} . So
   the returned value is L/(mR^2)=(I\omega)/(mR^2) The output values are
   expressed in the units specified by unit.

   This function checks the units if invalid combinations of units are
   given to the function.

   The values stored in the array PV are expressed in the following units

     * The angular momentum and its derivative are expressed in days if
       unit contains CALCEPH_UNIT_DAY.
     * The angular momentum and its derivative are expressed in seconds if
       unit contains CALCEPH_UNIT_SEC.

   The following example prints the angular momentum, due to its rotation,
   for the Earth at time=2451419.5
integer res
real(8) jd0
real(8) dt1
real(8) G(6)
TYPE(C_PTR) :: peph

jd0 = 2451419
dt1 = 0.5D0
peph = calceph_open("example2_rotangmom.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   res = calceph_rotangmom_unit(peph,jd0, dt1, NAIFID_EARTH,
&                            CALCEPH_USE_NAIFID+CALCEPH_UNIT_SEC,
&                            G)
   write(*,*) G

    call calceph_close(peph)
 endif

calceph_compute_order¶

   function calceph_compute_order(eph, JD0, time, target, center, unit,
          order, PVAJ ) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body or
            reference point whose coordinates are required (see the list,
            below).
          + center [INTEGER(C_INT), VALUE, intent(in)] :: The origin of
            the coordinate system (see the list, below). If target is 14,
            15, 16 or 17 (nutation, libration, TT-TDB or TCG-TCB), center
            must be 0.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PVAJ.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target and the
            center (NAIF identification numbers for the list).
            If the unit doesnot contain CALCEPH_USE_NAIFID, the old number
            system is used for the target and the center (see the list in
            the function calceph_compute()).
          + order [INTEGER(C_INT), VALUE, intent(in)] ::
            The order of derivatives

               o = 0 , only the position is computed. The first three
                 numbers of PVAJ are valid for the results.
               o = 1 , only the position and velocity are computed. The
                 first six numbers of PVAJ are valid for the results.
               o = 2 , only the position, velocity and acceleration are
                 computed. The first nine numbers of PVAJ are valid for
                 the results.
               o = 3 , the position, velocity and acceleration and jerk
                 are computed. The first twelve numbers of PVAJ are valid
                 for the results.

            If order equals to 1, the behavior of calceph_compute_order()
            is the same as calceph_compute_unit().
          + PVAJ [REAL(C_DOUBLE), dimension(1:12), intent(out)] ::
            Depending on the target value, an array to receive the
            cartesian position (x,y,z), the velocity (xdot, ydot, zdot),
            the acceleration and the jerk, or a time scale transformation
            value, or the angles of the librations of the Moon and their
            successive derivatives, or the nutation angles and their
            successive derivatives.

            Return:

   calceph_compute_order [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function is similar to the function calceph_compute_unit(), except
   that the order of the computed derivatives is specified.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates a single object, usually the position and their
   derivatives of one body (target) relative to another (center) for the
   time JD0+time and stores the results to PVAJ. The ephemeris file
   associated to eph must have been previously opened with the function
   calceph_open(). The order of the derivatives are specified by order.
   The output values are expressed in the units specified by unit.

   The returned array PVAJ has the following properties

     * If the target is the time scale transformation TT-TDB, only the
       first elements of each component will get the result.
     * If the target is the time scale transformation TCG-TCB, only the
       first elements of each component will get the result.
     * If the target is Librations, the array contains the angles of the
       librations of the Moon and their successive derivatives.
     * If the target is Nutations, the array contains the nutation angles
       and their successive derivatives.
     * Otherwise the returned value is the cartesian position (x,y,z), the
       velocity (xdot, ydot, zdot), the jerk and the acceleration.

   The returned array PVAJ must be large enough to store the results.

     * PVAJ[1:3] contain the position (x,y,z) and is always valid.
     * PVAJ[4:6] contain the velocity (dx/dt,dy/dt,dz/dt) and is only
       valid if order is greater or equal to 1.
     * PVAJ[7:9] contain the acceleration (d^2x/dt^2,d^2y/dt^2,d^2z/dt^2)
       and is only valid if order is greater or equal to 2.
     * PVAJ[10:12] contain the jerk (d^3x/dt^3,d^3y/dt^3,d^3z/dt^3) and is
       only valid if order is equal to 3.

   The values stored in the array PVAJ are expressed in the following
   units

     * The position, velocity, acceleration and jerk are expressed in
       Astronomical Unit (au) if unit contains CALCEPH_UNIT_AU.
     * The position, velocity, acceleration and jerk are expressed in
       kilometers if unit contains CALCEPH_UNIT_KM.
     * The velocity, acceleration, jerk, TT-TDB, TCG-TCB or the
       derivatives of the angles of the librations of the Moon are
       expressed in days if unit contains CALCEPH_UNIT_DAY.
     * The velocity, acceleration, jerk, TT-TDB, TCG-TCB or the
       derivatives of the angles of the librations of the Moon are
       expressed in seconds if unit contains CALCEPH_UNIT_SEC.
     * The angles of the librations of the Moon are expressed in radians
       if unit contains CALCEPH_UNIT_RAD.

   For example, to get the positions, velocities, accelerations and jerks
   expressed in kilometers and kilometers/seconds, the unit must be set to
   CALCEPH_UNIT_KM + CALCEPH_UNIT_SEC.

   This function checks the units if invalid combinations of units are
   given to the function.

   The following example prints the heliocentric coordinates of Mars at
   time=2442457.5
integer res
real(8) jd0
real(8) dt1
real(8) P(3)
real(8) PVAJ(12)
TYPE(C_PTR) :: peph

jd0 = 2442457
dt1 = 0.5D0
peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   ! compute only the heliocentric position of Mars in km
   res = calceph_compute_order(peph, jd0, dt1,
&                     NAIFID_MARS_BARYCENTER,
&                     NAIFID_SUN,
&                     CALCEPH_USE_NAIFID+CALCEPH_UNIT_KM+CALCEPH_UNIT_SEC,
&                     0, P);
   write(*,*) P

   ! compute positions, velocities, accelerations and jerks of Mars in km and se
conds
   res = calceph_compute_order(peph, jd0, dt1,
&                     NAIFID_MARS_BARYCENTER,
&                     NAIFID_SUN,
&                     CALCEPH_USE_NAIFID+CALCEPH_UNIT_KM+CALCEPH_UNIT_SEC,
&                     3, PVAJ);
   write(*,*) PVAJ

    call calceph_close(peph)
 endif

calceph_orient_order¶

   function calceph_orient_order(eph, JD0, time, target, unit, order, PVAJ
          ) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body whose
            orientations are requested. The numbering system depends on
            the parameter unit.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PVAJ.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target and the
            center (NAIF identification numbers for the list).
            If the unit doesnot contain CALCEPH_USE_NAIFID, the old number
            system is used for the target and the center (see the list in
            the function calceph_compute()).
          + order [INTEGER(C_INT), VALUE, intent(in)] ::
            The order of derivatives.

               o = 0 , only the angles is computed. The first three
                 numbers of PVAJ are valid for the results.
               o = 1 , only the angles and the first derivative are
                 computed. The first six numbers of PVAJ are valid for the
                 results.
               o = 2 , only the angles and the first and second
                 derivatives are computed. The first nine numbers of PVAJ
                 are valid for the results.
               o = 3 , the angles and the first, second and third
                 derivatives are computed. The first twelve numbers of
                 PVAJ are valid for the results.

            If order equals to 1, the behavior of calceph_orient_order()
            is the same as calceph_orient_unit().
          + PVAJ [REAL(C_DOUBLE), dimension(1:12), intent(out)] :: An
            array to receive the euler angles, or nutation angles, and
            their derivatives for the orientation of the body.

            Return:

   calceph_compute_order [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function is similar to the function calceph_orient_unit(), except
   that the order of the computed derivatives is specified.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates the orientation of a single body (target) for the time
   JD0+time and stores the results to PVAJ. The order of the derivatives
   are specified by order. The ephemeris file associated to eph must have
   been previously opened with the function calceph_open(). The output
   values are expressed in the units specified by unit.

   This function checks the units if invalid combinations of units are
   given to the function.

   The returned array PVAJ has the following properties

     * If unit contains CALCEPH_OUTPUT_NUTATIONANGLES, the array contains
       the nutation angles and their successive derivatives for the
       orientation of the body. At the present moment, only the nutation
       for the earth are supported in the original DE files.
     * If unit contains CALCEPH_OUTPUT_EULERANGLES, or doesnot contain
       CALCEPH_OUTPUT_NUTATIONANGLES, the array contains the euler angles
       and their successive derivatives for the orientation of the body.

   The returned array PVAJ must be large enough to store the results.

     * PVAJ[1:3] contain the angles and is always valid.
     * PVAJ[4:6] contain the first derivative and is only valid if order
       is greater or equal to 1.
     * PVAJ[7:9] contain the second derivative and is only valid if order
       is greater or equal to 2.
     * PVAJ[10:12] contain the third derivative and is only valid if order
       is equal to 3.

   The values stored in the array PVAJ are expressed in the following
   units

     * The derivatives of the angles are expressed in days if unit
       contains CALCEPH_UNIT_DAY.
     * The derivatives of the angles are expressed in seconds if unit
       contains CALCEPH_UNIT_SEC.
     * The angles and their derivatives are expressed in radians if unit
       contains CALCEPH_UNIT_RAD.

   The following example prints only the angles of libration of the Moon
   at time=2442457.5
integer res
real(8) jd0
real(8) dt1
real(8) P(3)
TYPE(C_PTR) :: peph

jd0 = 2442457
dt1 = 0.5D0
peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   res = calceph_orient_order(peph,jd0, dt1, NAIFID_MOON,
&                            CALCEPH_USE_NAIFID+CALCEPH_UNIT_RAD+CALCEPH_UNIT_SE
C,
&                            0, P)
   write(*,*) P

    call calceph_close(peph)
 endif

calceph_rotangmom_order¶

   function calceph_rotangmom_order(eph, JD0, time, target, unit, order,
          PVAJ ) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body whose
            orientations are requested. The numbering system depends on
            the parameter unit.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PVAJ.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target and the
            center (NAIF identification numbers for the list).
            If the unit doesnot contain CALCEPH_USE_NAIFID, the old number
            system is used for the target and the center (see the list in
            the function calceph_compute()).
          + order [INTEGER(C_INT), VALUE, intent(in)] ::
            The order of derivatives.

               o = 0 , only the angular momentum is computed. The first
                 three numbers of PVAJ are valid for the results.
               o = 1 , only the angular momentum and the first derivative
                 are computed. The first six numbers of PVAJ are valid for
                 the results.
               o = 2 , only the angular momentum and the first and second
                 derivatives are computed. The first nine numbers of PVAJ
                 are valid for the results.
               o = 3 , the angular momentum and the first, second and
                 third derivatives are computed. The first twelve numbers
                 of PVAJ are valid for the results.

            If order equals to 1, the behavior of
            calceph_rotangmom_order() is the same as
            calceph_rotangmom_unit().
          + PVAJ [REAL(C_DOUBLE), dimension(1:12), intent(out)] :: An
            array to receive the angular momentum due to its rotation,
            divided by the product of the mass and of the square of the
            radius, and their different order of the derivatives, of the
            body.

            Return:

   calceph_rotangmom_order [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function is similar to the function calceph_orient_unit(), except
   that the order of the computed derivatives is specified.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates the angular momentum vector due to the rotation of the
   body, divided by the product of the mass m and of the square of the
   radius R , of a single body (target) for the time JD0+time and stores
   the results to PVAJ. The angular momentum L , due to the rotation of
   the body, is defined as the product of the inertia matrix I by the
   angular velocity vector {\omega} . So the returned value is
   L/(mR^2)=(I\omega)/(mR^2) The order of the derivatives are specified by
   order. The ephemeris file associated to eph must have been previously
   opened with the function calceph_open(). The output values are
   expressed in the units specified by unit.

   This function checks the units if invalid combinations of units are
   given to the function.

   The returned array PVAJ must be large enough to store the results.

     * PVAJ[1:3] contain the angular momentum and is always valid.
     * PVAJ[4:6] contain the first derivative and is only valid if order
       is greater or equal to 1.
     * PVAJ[7:9] contain the second derivative and is only valid if order
       is greater or equal to 2.
     * PVAJ[10:12] contain the third derivative and is only valid if order
       is equal to 3.

   The values stored in the array PVAJ are expressed in the following
   units

     * The angular momentum and its derivatives are expressed in days if
       unit contains CALCEPH_UNIT_DAY.
     * The angular momentum and its derivatives are expressed in seconds
       if unit contains CALCEPH_UNIT_SEC.

   The following example prints only the angular momentum, due to its
   rotation, of the Earth at time=2451419.5
integer res
real(8) jd0
real(8) dt1
real(8) G(3)
TYPE(C_PTR) :: peph

jd0 = 2451419
dt1 = 0.5D0
peph = calceph_open("example2_rotangmom.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   res = calceph_rotangmom_order(peph,jd0, dt1, NAIFID_EARTH,
&                            CALCEPH_USE_NAIFID+CALCEPH_UNIT_SEC,
&                            G)
   write(*,*) G

    call calceph_close(peph)
 endif

calceph_getconstant¶

   function calceph_getconstant(eph, name, value) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor.
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [REAL(C_DOUBLE), intent(out)] :: first value of the
            constant.

            Return:

   calceph_getconstant [INTEGER(C_INT)] :: returns 0 if an error occurs,
   otherwise the number of values associated to the constant.

   This function returns the value associated to the constant name in the
   header of the ephemeris file associated to eph. Only the first value is
   returned if multiple values are associated to a constant, such as a
   list of values.

   This function is the same function as calceph_getconstantsd().

   The following example prints the value of the astronomical unit stored
   in the ephemeris file
integer res
real(8) AU
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     ! print the value of AU
     if (calceph_getconstant(peph, "AU"//C_NULL_CHAR, AU).eq.1) then
        write (*,*) "AU=", AU
    endif

    call calceph_close(peph)
 endif

calceph_getconstantsd¶

   function calceph_getconstantsd(eph, name, value) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor.
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [REAL(C_DOUBLE), intent(out)] :: first value of the
            constant.

            Return:

   calceph_getconstantsd [INTEGER(C_INT)] :: returns 0 if an error occurs,
   otherwise the number of values associated to the constant.

   This function returns, as a floating-point number, the value associated
   to the constant name in the header of the ephemeris file associated to
   eph. Only the first value is returned if multiple values are associated
   to a constant, such as a list of values. The value must be a
   floating-point or integer number, otherwise an error is reported.

   This function is the same function as calceph_getconstant().

   The following example prints the value of the astronomical unit stored
   in the ephemeris file
integer res
real(8) AU
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     ! print the value of AU
     if (calceph_getconstantsd(peph, "AU"//C_NULL_CHAR, AU).eq.1) then
        write (*,*) "AU=", AU
    endif

    call calceph_close(peph)
 endif

calceph_getconstantvd¶

   function calceph_getconstantvd(eph, name, arrayvalue, nvalue) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor.
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [REAL(C_DOUBLE), dimension(1:nvalue), intent(out)] ::
            array of values for the constant.
          + nvalue [INTEGER(C_INT), VALUE, intent(in)] :: number of
            elements of the array

            Return:

   calceph_getconstantvd [INTEGER(C_INT)] :: returns 0 if an error occurs,
   otherwise the number of values associated to the constant.

   This function stores, to the array arrayvalue as floating-point
   numbers, the nvalue first values associated to the constant name in the
   header of the ephemeris file associated to eph. The integer value
   returned by the function is equal to the number of valid entries in the
   arrayvalue if nvalue is greater or equal to that integer value..

   The required value nvalue to store all values can be determinated with
   the previous call to calceph_getconstantsd.

   The values must be floating-point or integer numbers, otherwise an
   error is reported.

   The following example prints the body radii of the earth stored in the
   ephemeris file
integer res, nvalue
real(8) svalue
real(8), allocatable :: radii
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     ! get the number of values
     nvalue = calceph_getconstantsd(peph, "BODY399_RADII"//C_NULL_CHAR, svalue)
     ! fill the array
     allocate(radii(1:nvalue))
     res = calceph_getconstantvd(peph, "BODY399_RADII"//C_NULL_CHAR, radii, nval
ue)
     write(*,*) radii

    call calceph_close(peph)
 endif

calceph_getconstantss¶

   function calceph_getconstantss(eph, name, value) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor.
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [CHARACTER(len=1,kind=C_CHAR),
            dimension(CALCEPH_MAX_CONSTANTNAME), intent(out)] :: first
            value of the constant.

            Return:

   calceph_getconstantss [INTEGER(C_INT)] :: returns 0 if an error occurs,
   otherwise the number of values associated to the constant.

   This function returns, as a string of character, the value associated
   to the constant name in the header of the ephemeris file associated to
   eph. Only the first value is returned if multiple values are associated
   to a constant, such as a list of values. The value must be a string,
   otherwise an error is reported.

   Trailing blanks are added to each value.

   The following example prints the value of the unit stored in the
   ephemeris file
integer res
character(len=CALCEPH_MAX_CONSTANTVALUE, kind=C_CHAR) UNIT
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
    ! print the value of UNIT
    if (calceph_getconstantss(peph, "UNIT"//C_NULL_CHAR, UNIT).eq.1) then
        write (*,*) "UNIT=", trim(UNIT)
    endif

    call calceph_close(peph)
 endif

calceph_getconstantvs¶

   function calceph_getconstantvs(eph, name, arrayvalue, nvalue) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor.
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [CHARACTER(len=1,kind=C_CHAR), dimension(1:nvalue),
            intent(out)] :: array of values for the constant.
          + nvalue [INTEGER(C_INT), VALUE, intent(in)] :: number of
            elements of the array

            Return:

   calceph_getconstantvs [INTEGER(C_INT)] :: returns 0 if an error occurs,
   otherwise the number of values associated to the constant.

   This function stores, to the array arrayvalue as strings of characters,
   the nvalue first values associated to the constant name in the header
   of the ephemeris file associated to eph. The integer value returned by
   the function is equal to the number of valid entries in the arrayvalue
   if nvalue is greater or equal to that integer value.

   The required value nvalue to store all values can be determinated with
   the previous call to calceph_getconstantss.

   The values must be strings, otherwise an error is reported.

   Trailing blanks are added to each value.

   The following example prints the units of the mission stored in the
   ephemeris file
integer res, nvalue
character(len=CALCEPH_MAX_CONSTANTVALUE, kind=C_CHAR) svalue
character(len=CALCEPH_MAX_CONSTANTVALUE, kind=C_CHAR), allocatable :: mission_un
its
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     ! get the number of values
     nvalue = calceph_getconstantss(peph, "MISSION_UNITS"//C_NULL_CHAR, svalue)
     ! fill the array
     allocate(mission_units(1:nvalue))
     res = calceph_getconstantvs(peph, "MISSION_UNITS"//C_NULL_CHAR, mission_uni
ts, nvalue)
     write(*,*) mission_units
     deallocate(mission_units)

    call calceph_close(peph)
 endif

calceph_getconstantcount¶

   function calceph_getconstantcount(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor
   Return: calceph_getconstantcount [INTEGER(C_INT)] :: number of
   constants. 0 if an error occurs, otherwise non-zero value.

   This function returns the number of constants available in the header
   of the ephemeris file associated to eph.

   The following example prints the number of available constants stored
   in the ephemeris file
integer res
integer n
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
  n = calceph_getconstantcount(peph)
  write (*,*) "number of constants", n
  call calceph_close(peph)
endif

calceph_getconstantindex¶

   function calceph_getconstantindex(eph, index, name, value) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + index [INTEGER(C_INT), VALUE, intent(in)] :: index of the
            constant, between 1 and calceph_getconstantcount()
          + name [CHARACTER(len=1,kind=C_CHAR),
            dimension(CALCEPH_MAX_CONSTANTNAME), intent(out)] :: name of
            the constant.
          + value [REAL(C_DOUBLE), intent(out)] :: first value of the
            constant

            Return:

   calceph_getconstantindex [INTEGER(C_INT)] :: returns 0 if an error
   occurs, otherwise the number of values associated to the constant.

   This function returns the name and its value of the constant available
   at the specified index in the header of the ephemeris file associated
   to eph. The value of index must be between 1 and
   calceph_getconstantcount().

   Only the first value is returned if multiple values are associated to a
   constant, such as a list of values.

   The following example displays the name of the constants, stored in the
   ephemeris file, and their values
   USE, INTRINSIC :: ISO_C_BINDING
   use calceph
   implicit none
   integer res
   integer j
   real(8) valueconstant
   character(len=CALCEPH_MAX_CONSTANTNAME) nameconstant
   TYPE(C_PTR) :: peph

! open the ephemeris file
   peph = calceph_open("example1.dat"//C_NULL_CHAR)
   if (C_ASSOCIATED(peph)) then

! print the list of constants
     do j=1, calceph_getconstantcount(peph)
       res = calceph_getconstantindex(peph,j,nameconstant, valueconstant)
       write (*,*) nameconstant,"=",valueconstant
     enddo

     call calceph_close(peph)
   endif

calceph_getfileversion¶

   function calceph_getfileversion(eph, version) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + version [CHARACTER(len=1,kind=C_CHAR),
            dimension(CALCEPH_MAX_CONSTANTVALUE), intent(out)] :: version
            of the file

            Return:

   calceph_getfileversion [INTEGER(C_INT)] :: returns 0 if the file
   version was not found, otherwise non-zero value.

   This function returns the version of the ephemeris file, as a string.
   For example, the argument version will contain 'INPOP10B', 'EPM2017' or
   'DE405', ... .

   If the file is an original JPL binary planetary ephemeris, then the
   version of the file can always be determined. If the file is a spice
   kernel, the version of the file is retrieved from the constant
   INPOP_PCK_VERSION, EPM_PCK_VERSION, or PCK_VERSION.

   The following example prints the version of the ephemeris file.
integer res
character(len=CALCEPH_MAX_CONSTANTVALUE) version
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     res = calceph_getfileversion(peph, version)
     write (*,*) "The version of the file is ", version

    call calceph_close(peph)
 endif

calceph_gettimescale¶

   function calceph_gettimescale(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor
   Return: calceph_gettimescale [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function returns the timescale of the ephemeris file associated to
          eph :

          + 1 if the quantities of all bodies are expressed in the TDB
            time scale.
          + 2 if the quantities of all bodies are expressed in the TCB
            time scale.

   The following example prints the time scale available in the ephemeris
   file
integer res
integer timescale
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
   ! print the time scale
   timescale = calceph_gettimescale(peph)
   write (*,*) "timescale=", timescale

   call calceph_close(peph)
 endif

calceph_gettimespan¶

   function calceph_gettimespan(eph, firsttime, lasttime, continuous)
          BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + firsttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            first time
          + lasttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            last time
          + continuous [INTEGER(C_INT), intent(out)] :: information about
            the availability of the quantities over the time span

            Return:

   calceph_gettimespan [INTEGER(C_INT)] :: 0 if an error occurs, otherwise
   non-zero value.

   This function returns the first and last time available in the
   ephemeris file associated to eph. The Julian date for the first and
   last time are expressed in the time scale returned by
   calceph_gettimescale() .

   It returns the following value in the parameter continuous :

     * 1 if the quantities of all bodies are available for any time
       between the first and last time.
     * 2 if the quantities of some bodies are available on discontinuous
       time intervals between the first and last time.
     * 3 if the quantities of each body are available on a continuous time
       interval between the first and last time, but not available for any
       time between the first and last time.

   The following example prints the first and last time available in the
   ephemeris file
integer res
integer :: continuous
real(8) :: firsttime, lasttime
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     if (calceph_gettimespan(peph, firsttime, lasttime, continuous).eq.1) then
        write (*,*) firsttime, lasttime, countinuous
    endif

    call calceph_close(peph)
 endif

calceph_getpositionrecordcount¶

   function calceph_getpositionrecordcount(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor
   Return: calceph_getpositionrecordcount [INTEGER(C_INT)] :: number of
   position's records. 0 if an error occurs, otherwise non-zero value.

   This function returns the number of position's records available in the
   ephemeris file associated to eph. Usually, the number of records is
   equal to the number of bodies in the ephemeris file if the timespan is
   continuous. If the timespan is discontinuous for the target and center
   bodies, then each different timespan is counted as a different record.
   If the ephemeris file contain timescale transformations' records, such
   as TT-TDB or TCG-TCB, then these records are included in the returned
   value.

   The following example prints the number of position's records available
   in the ephemeris file
integer res
integer n
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
  n = calceph_getpositionrecordcount(peph)
  write (*,*) "number of position's record", n
  call calceph_close(peph)
endif

calceph_getpositionrecordindex¶

   function calceph_getpositionrecordindex(eph, index, target, center,
          firsttime, lasttime, frame) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + index [INTEGER(C_INT), intent(int)] :: index of the position's
            record, between 1 and calceph_getpositionrecordcount()
          + target [INTEGER(C_INT), intent(out)] :: The target body
          + center [INTEGER(C_INT), intent(out)] :: The origin body
          + firsttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            first time
          + lasttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            last time
          + frame [INTEGER(C_INT), intent(out)] :: reference frame (see
            the list, below)

            Return:

   calceph_getpositionrecordindex [INTEGER(C_INT)] :: 0 if an error
   occurs, otherwise non-zero value.

   This function returns the target and origin bodies, the first and last
   time, and the reference frame available at the specified index for the
   position's records of the ephemeris file associated to eph. The NAIF
   identification numbering system is used for the target and center
   integers (NAIF identification numbers for the list). The Julian date
   for the first and last time are expressed in the time scale returned by
   calceph_gettimescale().

   It returns the following value in the parameter frame :
   value Name
   1     ICRF

   The following example displays the position's records stored in the
   ephemeris file.
   USE, INTRINSIC :: ISO_C_BINDING
   use calceph
   implicit none
   integer res
   integer j, itarget, icenter, iframe
   real(C_DOUBLE) firsttime, lasttime
   TYPE(C_PTR) :: peph

! open the ephemeris file
   peph = calceph_open("example1.dat"//C_NULL_CHAR)
   if (C_ASSOCIATED(peph)) then

! print the list of positionrecords
     do j=1, calceph_getpositionrecordcount(peph)
       res = calceph_getpositionrecordindex(peph,j,itarget, icenter, firsttime,
lasttime, iframe)
       write (*,*) itarget, icenter, firsttime, lasttime, iframe
     enddo

     call calceph_close(peph)
   endif

calceph_getorientrecordcount¶

   function calceph_getorientrecordcount(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor
   Return: calceph_getorientrecordcount [INTEGER(C_INT)] :: number of
   orientation's records. 0 if an error occurs, otherwise non-zero value.

   This function returns the number of orientation's records available in
   the ephemeris file associated to eph. Usually, the number of records is
   equal to the number of bodies in the ephemeris file if the timespan is
   continuous. If the timespan is discontinuous for the target body, then
   each different timespan is counted as a different record.

   The following example prints the number of orientation's records
   available in the ephemeris file
integer res
integer n
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
  n = calceph_getorientrecordcount(peph)
  write (*,*) "number of orientation's record", n
  call calceph_close(peph)
endif

calceph_getorientrecordindex¶

   function calceph_getorientrecordindex(eph, index, target, firsttime,
          lasttime, frame) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + index [INTEGER(C_INT), intent(int)] :: index of the
            orientation's record, between 1 and
            calceph_getorientrecordcount()
          + target [INTEGER(C_INT), intent(out)] :: The target body
          + firsttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            first time
          + lasttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            last time
          + frame [INTEGER(C_INT), intent(out)] :: reference frame (see
            the list, below)

            Return:

   calceph_getorientrecordindex [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function returns the target body, the first and last time, and the
   reference frame available at the specified index for the orientation's
   records of the ephemeris file associated to eph. The NAIF
   identification numbering system is used for the target body (NAIF
   identification numbers for the list). The Julian date for the first and
   last time are expressed in the time scale returned by
   calceph_gettimescale().

   It returns the following value in the parameter frame :
   value Name
   1     ICRF

   The following example displays the orientation's records stored in the
   ephemeris file.
   USE, INTRINSIC :: ISO_C_BINDING
   use calceph
   implicit none
   integer res
   integer j, itarget, iframe
   real(C_DOUBLE) firsttime, lasttime
   TYPE(C_PTR) :: peph

! open the ephemeris file
   peph = calceph_open("example1.dat"//C_NULL_CHAR)
   if (C_ASSOCIATED(peph)) then

! print the list of orientation records
     do j=1, calceph_getorientrecordcount(peph)
       res = calceph_getorientrecordindex(peph,j,itarget, firsttime, lasttime, i
frame)
       write (*,*) itarget, firsttime, lasttime, iframe
     enddo

     call calceph_close(peph)
   endif

calceph_close¶

   subroutine calceph_close(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor

   This function closes the access associated to the ephemeris descriptor
   eph and frees allocated memory for it.

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Error functions Multiple file access functions

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
     * Single file access functions
          + Thread notes
          + Usage
          + Functions
               o calceph_sopen
               o calceph_scompute
               o calceph_sgetconstant
               o calceph_sgetconstantcount
               o calceph_sgetconstantindex
               o calceph_sgetfileversion
               o calceph_sgettimescale
               o calceph_sgettimespan
               o calceph_sclose
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Single file access functions
     *
     __________________________________________________________________

Single file access functions¶

   This group of functions works on a single ephemeris file at a given
   instant. They use an internal global variable to store information
   about the current opened ephemeris file.

   They are provided to have a similar interface of the fortran PLEPH
   function, supplied with the JPL ephemeris files. So the following call
   to PLEPH
PLEPH(46550D0, 3, 12, PV)

   could be replaced by
calceph_sopen("ephemerisfile.dat")
calceph_scompute(46550D0, 0, 3, 12, PV)
calceph_sclose()

   While the function PLEPH could access only one file in a program, these
   functions could access on multiple files in a program but not at same
   time. To access multiple files at a same time, the functions listed in
   the section Multiple file access functions must be used.

   When an error occurs, these functions execute error handlers according
   to the behavior defined by the function calceph_seterrorhandler().

   The python interface does not provide these functions, the listed in
   the section Multiple file access functions must be used.

Thread notes¶

   If the standard I/O functions such as fread are not reentrant then the
   CALCEPH I/O functions using them will not be reentrant either.

   If the library was configured with the option --enable-thread=yes,
   these functions use an internal global variable per thread. Each thread
   could access to different ephemeris file and compute ephemeris data at
   same time. But each thread must call the function calceph_sopen() to
   open ephemeris file even if all threads work on the same file.

   If the library was configured with the default option
   --enable-thread=no, these functions use an internal global variable per
   process and are not thread-safe. If multiple threads are used in the
   process and call the function calceph_scompute() at the same time, the
   caller thread must surround the call to this function with locking
   primitives, such as pthread_lock/pthread_unlock if POSIX Pthreads are
   used.

Usage¶

   The following examples, that can be found in the directory examples of
   the library sources, show the typical usage of this group of functions.

   The example in Fortran 2003 language is f2003single.f.
USE, INTRINSIC :: ISO_C_BINDING
use calceph
implicit none
integer res
real(8) AU, EMRAT, GM_Mer
real(8) jd0
real(8) dt
real(8) PV(6)
integer j
real(8) valueconstant
character(len=CALCEPH_MAX_CONSTANTNAME) nameconstant

jd0 = 2442457
dt = 0.5E0
! open the ephemeris file
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then
  write (*,*) "The ephemeris is already opened"
  ! print the values of AU, EMRAT and GM_Mer
  if (calceph_sgetconstant("AU"//C_NULL_CHAR, AU).eq.1) then
      write (*,*) "AU=", AU
  endif
  if (calceph_sgetconstant("EMRAT"//C_NULL_CHAR,EMRAT).eq.1) then
      write (*,*) "EMRAT=", EMRAT
  endif
  if (calceph_sgetconstant("GM_Mer"//C_NULL_CHAR,GM_Mer).eq.1) then
      write (*,*) "GM_Mer=", GM_Mer
  endif

  ! compute and print the coordinates
  ! the geocentric moon coordinates
  res = calceph_scompute(jd0, dt, 10, 3, PV)
  call printcoord(PV,"geocentric coordinates of the Moon")
  ! the value TT-TDB
  if (calceph_scompute(jd0, dt, 16, 0, PV).eq.1) then
    write (*,*) "TT-TDB = ", PV(1)
  endif
  ! the heliocentric coordinates of Mars
  res = calceph_scompute(jd0, dt, 4, 11, PV)
  call printcoord(PV,"heliocentric coordinates of Mars")


  ! print the whole list of the constants
  write (*,*) "list of constants"
  do j=1, calceph_sgetconstantcount()
    res = calceph_sgetconstantindex(j,nameconstant, valueconstant)
    write (*,*) nameconstant,"=",valueconstant
  enddo


  ! close the ephemeris file
  call calceph_sclose
  write (*,*) "The ephemeris is already closed"
else
  write (*,*) "The ephemeris can't be opened"
endif

Functions¶

calceph_sopen¶

   function calceph_sopen(filename) BIND(C)¶

   Parameters: filename [CHARACTER(len=1,kind=C_CHAR), intent(in)] ::
   pathname of the file.
   Return: calceph_sopen [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function opens the file whose pathname is the string pointed to by
   filename, reads the header of this file and associates an ephemeris
   descriptor to an internal variable. This file must be an ephemeris
   file.

   This file must be compliant to the format specified by the 'original
   JPL binary' , 'INPOP 2.0 binary' or 'SPICE' ephemeris file. At the
   moment, supported SPICE files are the following :

     * text Planetary Constants Kernel (KPL/PCK) files
     * binary PCK (DAF/PCK) files.
     * binary SPK (DAF/SPK) files containing segments of type 1, 2, 3, 5,
       8, 9, 12, 13, 17, 18, 20, 21, 102, 103 and 120.
     * meta kernel (KPL/MK) files.
     * frame kernel (KPL/FK) files. Only a basic support is provided.

   The function calceph_sclose() must be called to free allocated memory
   by this function.

   The following example opens the ephemeris file example1.dat
integer res
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then
     ! ...  computation ...
endif
call calceph_sclose

calceph_scompute¶

   function calceph_scompute(JD0, time, target, center, PV) BIND(C)¶

   Parameters:
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body or
            reference point whose coordinates are required (see the list,
            below).
          + center [INTEGER(C_INT), VALUE, intent(in)] :: The origin of
            the coordinate system (see the list, below). If target is 14,
            15, 16 or 17 (nutation, libration, TT-TDB or TCG-TCB), center
            must be 0.
          + PV [REAL(C_DOUBLE), dimension(1:6), intent(out)] :: Depending
            on the target value, an array to receive the cartesian
            position (x,y,z) and the velocity (xdot, ydot, zdot), or a
            time scale transformation value, or the angles of the
            librations of the Moon and their derivatives, or the nutation
            angles and their derivatives.

            Return:

   calceph_scompute [INTEGER(C_INT)] :: 0 if an error occurs, otherwise
   non-zero value.

   This function reads, if needed, and interpolates a single object,
   usually the position and velocity of one body (target) relative to
   another (center), from the ephemeris file, previously opened with the
   function calceph_sopen(), for the time JD0+time and stores the results
   to PV.

   To get the best precision for the interpolation, the time is splitted
   in two floating-point numbers. The argument JD0 should be an integer
   and time should be a fraction of the day. But you may call this
   function with time=0 and JD0, the desired time, if you don't take care
   about precision.

   The possible values for target and center are :
                 value                       meaning
   1                                  Mercury Barycenter
   2                                  Venus Barycenter
   3                                  Earth
   4                                  Mars Barycenter
   5                                  Jupiter Barycenter
   6                                  Saturn Barycenter
   7                                  Uranus Barycenter
   8                                  Neptune Barycenter
   9                                  Pluto Barycenter
   10                                 Moon
   11                                 Sun
   12                                 Solar Sytem barycenter
   13                                 Earth-moon barycenter
   14                                 Nutations
   15                                 Librations
   16                                 TT-TDB
   17                                 TCG-TCB
   asteroid number + CALCEPH_ASTEROID asteroid

   These accepted values by this function are the same as the value for
   the JPL function PLEPH, except for the values TT-TDB, TCG-TCB and
   asteroids.

   For example, the value "CALCEPH_ASTEROID+4" for target or center
   specifies the asteroid Vesta.

   The following example prints the heliocentric coordinates of Mars at
   time=2451624.5 and at 2451624.9
integer res
real(8) jd0
real(8) dt1, dt2
real(8) PV(6)

jd0 = 2442457
dt1 = 0.5D0
dt2 = 0.9D0

res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then
     ! the heliocentric coordinates of Mars
     res = calceph_scompute(jd0, dt1, 4, 11, PV)
     write (*,*) PV

     res = calceph_scompute(jd0, dt2, 4, 11, PV)
     write (*,*) PV

     call calceph_sclose
endif

calceph_sgetconstant¶

   function calceph_sgetconstant(name, value) BIND(C)¶

   Parameters:
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [REAL(C_DOUBLE), intent(out)] :: first value of the
            constant.

            Return:

   calceph_getconstant [INTEGER(C_INT)] :: 0 if an error occurs, otherwise
   non-zero value.

   This function returns the value associated to the constant name in the
   header of the ephemeris file.

   Only the first value is returned if multiple values are associated to a
   constant, such as a list of values.

   The function calceph_sopen() must be previously called before.

   The following example prints the value of the astronomical unit stored
   in the ephemeris file
integer res
real(8) AU
! open the ephemeris file
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then
    if (calceph_sgetconstant("AU"//C_NULL_CHAR, AU).eq.1) then
        write (*,*) "AU=", AU
    endif
endif

calceph_sgetconstantcount¶

   function calceph_sgetconstantcount() BIND(C)¶

   Return: calceph_sgetconstantcount [INTEGER(C_INT)] :: 0 if an error
   occurs, otherwise non-zero value.

   This function returns the number of constants available in the header
   of the ephemeris file.

   The function calceph_sopen() must be previously called before.

   The following example prints the number of available constants stored
   in the ephemeris file
integer res
integer n
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then

  n = calceph_sgetconstantcount()
  write (*,*) "number of constants", n

  call calceph_sclose
endif

calceph_sgetconstantindex¶

   function calceph_sgetconstantindex(index, name, value) BIND(C)¶

   Parameters:
          + index [INTEGER(C_INT), VALUE, intent(in)] :: index of the
            constant, between 1 and calceph_getconstantcount()
          + name [CHARACTER(len=1,kind=C_CHAR),
            dimension(CALCEPH_MAX_CONSTANTNAME), intent(out)] :: name of
            the constant.
          + value [REAL(C_DOUBLE), intent(out)] :: first value of the
            constant

            Return:

   calceph_sgetconstantindex [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function returns the name and its value of the constant available
   at the specified index in the header of the ephemeris file. The value
   of index must be between 1 and calceph_sgetconstantcount().

   The function calceph_sopen() must be previously called before.

   The following example displays the name of the constants, stored in the
   ephemeris file, and their values
integer res
integer j
real(8) valueconstant
character(len=CALCEPH_MAX_CONSTANTNAME) nameconstant

res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then

  do j=1, calceph_sgetconstantcount()
    res = calceph_sgetconstantindex(j,nameconstant,valueconstant)
    write (*,*) nameconstant,"=",valueconstant
  enddo

call calceph_sclose

calceph_sgetfileversion¶

   function calceph_sgetfileversion(version) BIND(C)¶

   Parameters: version [CHARACTER(len=1,kind=C_CHAR),
   dimension(CALCEPH_MAX_CONSTANTVALUE), intent(out)] :: version of the
   file
   Return: calceph_sgetfileversion [INTEGER(C_INT)] :: returns 0 if the
   file version was not found, otherwise non-zero value.

   This function returns the version of the ephemeris file, as a string.
   For example, the argument version will contain 'INPOP10B', 'EPM2017' or
   'DE405', ... .

   If the file is an original JPL binary planetary ephemeris, then the
   version of the file can always be determined. If the file is a spice
   kernel, the version of the file is retrieved from the constant
   INPOP_PCK_VERSION, EPM_PCK_VERSION, or PCK_VERSION.

   The function calceph_sopen() must be previously called before.

   The following example prints the version of the ephemeris file.
integer res
character(len=CALCEPH_MAX_CONSTANTVALUE) version
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then

  res = calceph_sgetfileversion(version)
  write (*,*) "The version of the file is ", version

  call calceph_sclose
endif

calceph_sgettimescale¶

   function calceph_sgettimescale() BIND(C)¶

   Return: calceph_sgettimescale [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function returns the timescale of the ephemeris file :

          + 1 if the quantities of all bodies are expressed in the TDB
            time scale.
          + 2 if the quantities of all bodies are expressed in the TCB
            time scale.

   The function calceph_sopen() must be previously called before.

   The following example prints the time scale available in the ephemeris
   file
integer res
integer t
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then

  t = calceph_sgettimescale()
  write (*,*) "timescale ", t

  call calceph_sclose
endif

calceph_sgettimespan¶

   function calceph_sgettimespan(firsttime, lasttime, continuous) BIND(C)¶

   Parameters:
          + firsttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            first time
          + lasttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            last time
          + continuous [INTEGER(C_INT), intent(out)] :: information about
            the availability of the quantities over the time span

            Return:

   calceph_sgettimespan [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function returns the first and last time available in the
   ephemeris file. The Julian date for the first and last time are
   expressed in the time scale returned by calceph_sgettimescale() .

   It returns the following value in the parameter continuous :

     * 1 if the quantities of all bodies are available for any time
       between the first and last time.
     * 2 if the quantities of some bodies are available on discontinuous
       time intervals between the first and last time.
     * 3 if the quantities of each body are available on a continuous time
       interval between the first and last time, but not available for any
       time between the first and last time.

   The function calceph_sopen() must be previously called before.

   The following example prints the first and last time available in the
   ephemeris file
integer res
integer cont
real(8) jdfirst, jdlast
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then

  res = calceph_sgettimespan(jdfirst, jdlast, cont)
  write (*,*) "data available between ", jdfirst, "and", jdlast
  write (*,*) "continuous data ", cont

  call calceph_sclose
endif

calceph_sclose¶

   subroutine calceph_sclose()¶

   This function closes the ephemeris data file and frees allocated memory
   by the function calceph_sopen().

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Miscellaneous functions Single file access functions

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
     * Single file access functions
     * Error functions
          + Usage
          + calceph_seterrorhandler
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Error functions
     *
     __________________________________________________________________

Error functions¶

   The following group of functions defines the behavior of the library
   when errors occur during the execution.

Usage¶

   The following examples, that can be found in the directory examples of
   the library sources, show the typical usage of this group of functions.

   The example in Fortran 2003 language is f2003error.f.

   The following example shows how to stop the execution on the error.
program f2003error
    USE, INTRINSIC :: ISO_C_BINDING
    use calceph
    implicit none
    integer res
    real(8) jd0
    real(8) dt
    real(8) PV(6)

 ! set the  error handler to stop on error
     call calceph_seterrorhandler(2, C_NULL_FUNPTR)

 ! open the ephemeris file
    res = calceph_sopen("example1.dat"//C_NULL_CHAR)
    ...

stop
end

   The following example shows how to define a custom error handler
   function.
!/*-----------------------------------------------------------------*/
!/* custom error handler */
!/*-----------------------------------------------------------------*/
     subroutine myhandler(msg, msglen) BIND(C)
        USE, INTRINSIC :: ISO_C_BINDING
        implicit none
        character(kind=C_CHAR), dimension(msglen), intent(in) :: msg
        integer(C_INT), VALUE, intent(in) :: msglen
        write (*,*) "The calceph calls the function myhandler"
        write (*,*) "The message contains ",msglen," characters"
        write(*,*) "The error message is :"
        write(*,*) "----------------------"
        write(*,*) msg
        write(*,*) "----------------------"
        write(*,*) "The error handler returns"
     end

!/*-----------------------------------------------------------------*/
!/* main program */
!/*-----------------------------------------------------------------*/
     program f2003error
         USE, INTRINSIC :: ISO_C_BINDING
         use calceph
         implicit none
         integer res
         real(8) jd0
         real(8) dt
         real(8) PV(6)

         interface
          subroutine myhandler(msg, msglen) BIND(C)
              USE, INTRINSIC :: ISO_C_BINDING
              implicit none
              character(kind=C_CHAR), dimension(msglen), intent(in) &
    &          :: msg
              integer(C_INT), VALUE, intent(in) :: msglen
          end subroutine
         end interface


! set the  error handler to use my own callback
         call calceph_seterrorhandler(3, c_funloc(myhandler))

! open the ephemeris file
        res = calceph_sopen("example1.dat"//C_NULL_CHAR)

   ! ...

     stop
     end

calceph_seterrorhandler¶

   subroutine calceph_seterrorhandler(typehandler, userfunc ) BIND(C)¶

   Parameters:
          + typehandler [TYPE(C_INT), VALUE, intent(in)] :: type of
            handler
          + userfunc [TYPE(C_FUNPTR), VALUE, intent(in)] :: user function

   This function defines the behavior of the library when an error occurs
   during the execution of the library's functions. This function should
   be (not mandatory) called before any other functions of the library.
   The behavior depends on the value of typehandler.

   The possible values for typehandler are :
   value meaning
   1
   The library displays a message and continues the execution.
   The functions return an error code. The python and Octave/Matlab
   interfaces raise
   an exception.
   This is the default behavior of the library.
   2
   The library displays a message
   and terminates the execution with a system call to thefunction exit.
   3
   The library calls the user function userfunc with the message.

   If the function is called with 1 or 2 for typehandler, the parameter
   userfunc must be set to C_NULL_FUNPTR.

   The function userfunc must be defined as
subroutine userfunc (msg, msglen)  BIND(C)
USE, INTRINSIC :: ISO_C_BINDING
implicit none
CHARACTER(kind=C_CHAR), dimension(msglen), intent(in) :: msg
INTEGER(C_INT), VALUE, intent(in) :: msglen

   This function must have an explicit interface.

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation NAIF
   identification numbers Error functions

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
     * Single file access functions
     * Error functions
     * Miscellaneous functions
          + calceph_getversion_str
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Miscellaneous functions
     *
     __________________________________________________________________

Miscellaneous functions¶

calceph_getversion_str¶

   subroutine calceph_getversion_str(version) BIND(C)¶

   Parameters: version [CHARACTER(len=1,kind=C_CHAR),
   dimension(CALCEPH_MAX_CONSTANTNAME), intent(out)] :: version of the
   library

   This function returns the version of the CALCEPH Library, as a string.

   Trailing blanks are added to the name version.
character(len=CALCEPH_MAX_CONSTANTNAME) version

call calceph_getversion_str(version)
write(*,*) 'library version is ', version

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Multiple file access functions Installation

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
          + A simple example program
          + Modules and Libraries
          + Types
          + Constants
     * Multiple file access functions
     * Single file access functions
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Library interface
     *
     __________________________________________________________________

Library interface¶

A simple example program¶

   The following example program shows the typical usage of the Fortran
   2003 interface.

   Other examples using the Fortran 2003 interface can be found in the
   directory examples of the library sources.
program f2003multiple
    USE, INTRINSIC :: ISO_C_BINDING
    use calceph
    integer res
    real(8) AU
    TYPE(C_PTR) :: peph

    peph = calceph_open("example1.dat"//C_NULL_CHAR)
    if (C_ASSOCIATED(peph)) then

       if (calceph_getconstant(peph, "AU"//C_NULL_CHAR, AU).eq.1) then
            write (*,*) "AU=", AU
       endif

       call calceph_close(peph)
     endif
stop
end

Modules and Libraries¶

   All declarations needed to use CALCEPH Library are collected in the
   module files calceph.mod. The library is designed to work with Fortran
   compilers compliant with the Fortran 2003 standard. All declarations
   use the standard ISO_C_BINDING module.

   You should include that module in any program using the CALCEPH
   library:
use calceph

   When a fortran string is given as a parameter to a function of this
   library, you should append this string with //C_NULL_CHAR because the C
   library works only with C string.

Compilation on a Unix-like system¶

   All programs using CALCEPH must link against the libcalceph library. On
   Unix-like system this can be done with -lcalceph, for example

gfortran -I/usr/local/include myprogram.f -o myprogram -lcalceph

   If CALCEPH Library has been installed to a non-standard location then
   it may be necessary to use -I and -L compiler options to point to the
   right directories, and some sort of run-time path for a shared library.

Compilation on a Windows system¶

   All programs using CALCEPH must link against the libcalceph.lib. On
   Windows system this can be done with libcalceph.lib, for example

gfortran.exe /out:myprogram.exe myprogram.f libcalceph.lib

   If CALCEPH Library has been installed to a non-standard location then
   it may be necessary to use /I and /LIBPATH: compiler options to point
   to the right directories.

Types¶

Constants¶

   The following constants are defined in the module calceph.mod.

   CALCEPH_MAX_CONSTANTNAME [integer]¶

   This integer defines the maximum number of characters, including the
   trailing '\0', that the name of a constant, available from the
   ephemeris file, could contain.

   CALCEPH_MAX_CONSTANTVALUE [integer]¶

   This integer defines the maximum number of characters, including the
   trailing '\0', that the value of a constant, available from the
   ephemeris file, could contain if the value is stored as a string of
   characters.

   CALCEPH_VERSION_MAJOR [integer]¶

   This integer constant defines the major revision of this library. It
   can be used to distinguish different releases of this library.

   CALCEPH_VERSION_MINOR [integer]¶

   This integer constant defines the minor revision of this library. It
   can be used to distinguish different releases of this library.

   CALCEPH_VERSION_PATCH [integer]¶

   This integer constant defines the patch level revision of this library.
   It can be used to distinguish different releases of this library.

   CALCEPH_VERSION_STRING [character(len=*)]¶

   This string is the version of the library, which can be compared to the
   result of calceph_getversion to check at run time if the header file
   and library used match:

   Note: Obtaining different strings is not necessarily an error, as in
   general, a program compiled with some old CALCEPH version can be
   dynamically linked with a newer CALCEPH library version (if allowed by
   the operating system).

   CALCEPH_ASTEROID [integer]¶

   This integer defines the offset value for the asteroids that must be
   used as target or center for the computation functions, such as
   calceph_compute().

   The following constants specify in which units are expressed the output
   of the computation functions, such as calceph_compute_unit() :

   CALCEPH_UNIT_AU [integer]¶

   This integer defines that the unit of the positions and velocities is
   expressed in astronomical unit.

   CALCEPH_UNIT_KM [integer]¶

   This integer defines that the unit of the positions and velocities is
   expressed in kilometer.

   CALCEPH_UNIT_DAY [integer]¶

   This integer defines that the unit of the velocities or the quantity
   TT-TDB or TCG-TCB is expressed in day (one day=86400 seconds).

   CALCEPH_UNIT_SEC [integer]¶

   This integer defines that the unit of the velocities or the quantity
   TT-TDB or TCG-TCB is expressed in second.

   CALCEPH_UNIT_RAD [integer]¶

   This integer defines that the unit of the angles is expressed in
   radian.

   CALCEPH_OUTPUT_EULERANGLES [integer]¶

   This integer defines that the output array contains the euler angles.

   CALCEPH_OUTPUT_NUTATIONANGLES [integer]¶

   This integer defines that the output array contains the nutation
   angles.

   CALCEPH_USE_NAIFID [integer]¶

   This integer defines that the NAIF identification numbers are used as
   target or center for the computation functions, such as
   calceph_compute_unit().

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Single file access functions Library interface

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
          + Thread notes
          + Usage
          + Functions
               o calceph_open
               o calceph_open_array
               o calceph_prefetch
               o calceph_isthreadsafe
               o calceph_compute
               o calceph_compute_unit
               o calceph_orient_unit
               o calceph_rotangmom_unit
               o calceph_compute_order
               o calceph_orient_order
               o calceph_rotangmom_order
               o calceph_getconstant
               o calceph_getconstantsd
               o calceph_getconstantvd
               o calceph_getconstantss
               o calceph_getconstantvs
               o calceph_getconstantcount
               o calceph_getconstantindex
               o calceph_getfileversion
               o calceph_gettimescale
               o calceph_gettimespan
               o calceph_getpositionrecordcount
               o calceph_getpositionrecordindex
               o calceph_getorientrecordcount
               o calceph_getorientrecordindex
               o calceph_close
     * Single file access functions
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Multiple file access functions
     *
     __________________________________________________________________

Multiple file access functions¶

   The following group of functions should be the preferred method to
   access to the library. They allow to access to multiple ephemeris files
   at the same time, even by multiple threads.

   When an error occurs, these functions execute error handlers according
   to the behavior defined by the function calceph_seterrorhandler().

Thread notes¶

   If the standard I/O functions such as fread are not reentrant then the
   CALCEPH I/O functions using them will not be reentrant either.

   It's safe for two threads to call the functions with the same handle of
   ephemeris object if and only if the function calceph_isthreadsafe()
   returns a non-zero value. A previous call to the function
   calceph_prefetch() is required for the function calceph_isthreadsafe()
   to return a non-zero value.

   It's safe for two threads to access simultaneously to the same
   ephemeris file with two different objects. In this case, each thread
   must open the same file.

Usage¶

   The following examples, that can be found in the directory examples of
   the library sources, show the typical usage of this group of functions.

   The example in Fortran 2003 language is f2003multiple.f.
 program f2003multiple
     USE, INTRINSIC :: ISO_C_BINDING
     use calceph
     implicit none
     integer res
     real(8) AU, EMRAT, GM_Mer
     real(8) jd0
     real(8) dt
     real(8) PV(6)
     TYPE(C_PTR) :: peph

     jd0 = 2451624
     dt = 0.5E0
     ! open the ephemeris file
     peph = calceph_open("example1.dat"//C_NULL_CHAR)
     if (C_ASSOCIATED(peph)) then
         write (*,*) "The ephemeris is already opened"
         ! print the values of AU, EMRAT and GM_Mer
         if (calceph_getconstant(peph, "AU"//C_NULL_CHAR, AU).eq.1) then
             write (*,*) "AU=", AU
        endif
        if (calceph_getconstant(peph,"EMRAT"//C_NULL_CHAR, EMRAT).eq.1) then
             write (*,*) "EMRAT=", EMRAT
        endif
        if (calceph_getconstant(peph,"GM_Mer"//C_NULL_CHAR, GM_Mer).eq.1) then
             write (*,*) "GM_Mer=", GM_Mer
        endif

        ! compute and print the coordinates
        ! the geocentric moon coordinates
        res = calceph_compute(peph,jd0, dt, 10, 3, PV)
        call printcoord(PV,"geocentric coordinates of the Moon")
        ! the value TT-TDB
        if (calceph_compute(peph,jd0, dt, 16, 0, PV).eq.1) then
         write (*,*) "TT-TDB = ", PV(1)
        endif
        ! the heliocentric coordinates of Mars
        res = calceph_compute(peph,jd0, dt, 4, 11, PV)
        call printcoord(PV,"heliocentric coordinates of Mars")

        ! close the ephemeris file
        call calceph_close(peph)
        write (*,*) "The ephemeris is already closed"
    else
        write (*,*) "The ephemeris can't be opened"
    endif
stop
end

Functions¶

calceph_open¶

   function calceph_open(filename) BIND(C)¶

   Parameters: filename [CHARACTER(len=1,kind=C_CHAR), intent(in)] ::
   pathname of the file.
   Return: calceph_open [TYPE(C_PTR)] :: ephemeris descriptor. This value
   is C_NULL_PTR if an error occurs, otherwise non-C_NULL_PTR value.

   This function opens the file whose pathname is the string pointed to by
   filename, reads the two header blocks of this file and returns an
   ephemeris descriptor associated to it. This file must be compliant to
   the format specified by the 'original JPL binary' , 'INPOP 2.0 binary'
   or 'SPICE' ephemeris file. At the moment, supported SPICE files are the
   following :

     * text Planetary Constants Kernel (KPL/PCK) files
     * binary PCK (DAF/PCK) files.
     * binary SPK (DAF/SPK) files containing segments of type 1, 2, 3, 5,
       8, 9, 12, 13, 17, 18, 20, 21, 102, 103 and 120.
     * meta kernel (KPL/MK) files.
     * frame kernel (KPL/FK) files. Only a basic support is provided.

   Just after the call of calceph_open(), the function calceph_prefetch()
   should be called to accelerate future computations.

   The function calceph_close() must be called to free allocated memory by
   this function.

   The following example opens the ephemeris file example1.dat
USE, INTRINSIC :: ISO_C_BINDING
use calceph
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

     ! ... computation ...

endif
call calceph_close(peph)

calceph_open_array¶

   function calceph_open_array(n, array_filename, len_filename) BIND(C)¶

   Parameters:
          + n [INTEGER(C_INT), VALUE, intent(in)] :: number of files.
          + array_filename [CHARACTER(len=1,kind=C_CHAR), dimension(*),
            intent(in)] :: array of pathname of the files.
          + len_filename [INTEGER(C_INT), VALUE, intent(in)] :: number of
            characters of each file's name.

            Return:

   calceph_open_array [TYPE(C_PTR)] :: ephemeris descriptor. This value is
   C_NULL_PTR if an error occurs, otherwise non-C_NULL_PTR value.

   This function opens n files whose pathnames are the string pointed to
   by array_filename, reads the header blocks of these files and returns
   an ephemeris descriptor associated to them.

   These files must have the same type (e.g., all files are SPICE files or
   original JPL files). This file must be compliant to the format
   specified by the 'original JPL binary' , 'INPOP 2.0 or 3.0 binary' or
   'SPICE' ephemeris file. At the moment, supported SPICE files are the
   following :

     * text Planetary Constants Kernel (KPL/PCK) files
     * binary PCK (DAF/PCK) files.
     * binary SPK (DAF/SPK) files containing segments of type 1, 2, 3, 5,
       8, 9, 12, 13, 17, 18, 20, 21, 102, 103 and 120.
     * meta kernel (KPL/MK) files.
     * frame kernel (KPL/FK) files. Only a basic support is provided.

   Just after the call of calceph_open_array(), the function
   calceph_prefetch() should be called to accelerate future computations.

   The function calceph_close() must be called to free allocated memory by
   this function.

   The following example opens the ephemeris file example1.bsp and
   example1.tpc
TYPE(C_PTR) :: peph
character(len=256), dimension (2) :: filear
filear(1) = "example1.bsp"//C_NULL_CHAR
filear(2) = "example1.tpc"//C_NULL_CHAR
peph = calceph_open_array(2, filear, 256)
if (C_ASSOCIATED(peph)) then
  res = calceph_prefetch(peph)
  ! ...  computation ...
  call calceph_close(peph)
endif

calceph_prefetch¶

   function calceph_prefetch(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor.
   Return: calceph_prefetch [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function prefetches to the main memory all files associated to the
   ephemeris descriptor eph. This prefetching operation will accelerate
   the further computations performed with calceph_compute(),
   calceph_compute_unit(), calceph_compute_order(), calceph_orient_unit(),
   ... .

   It requires that the file is smaller than the main memory. If multiple
   threads (e.g. threads of openMP or Posix Pthreads) prefetch the data
   for the same ephemeris file, the used memory will remain the same as if
   the prefetch operation was done by a single thread if and if the
   endianess of the file is the same as the computer and if the operating
   system, such as Linux, MacOS X other unix, supports the function mmap.

calceph_isthreadsafe¶

   function calceph_isthreadsafe(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor.
   Return: calceph_isthreadsafe [INTEGER(C_INT)] :: returns 1 if multiple
   threads can access the same ephemeris ephemeris descriptor, otherwise
   0.

   This function returns 1 if multiple threads can access the same
   ephemeris ephemeris descriptor, otherwise 0.

   A previous call to the function calceph_prefetch() is required, and the
   library should becompiled with --enable-thread=yes on Unix-like
   operating system, for the function calceph_isthreadsafe() to return a
   non-zero value.

   If this function returns 1, severals threads may use the same ephemeris
   descriptor for the computational functions calceph_compute(), .... It
   allows to use the same object for parallel loops.

calceph_compute¶

   function calceph_compute(eph, JD0, time, target, center, PV ) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body or
            reference point whose coordinates are required (see the list,
            below).
          + center [INTEGER(C_INT), VALUE, intent(in)] :: The origin of
            the coordinate system (see the list, below). If target is 14,
            15, 16 or 17 (nutation, libration, TT-TDB or TCG-TCB), center
            must be 0.
          + PV [REAL(C_DOUBLE), dimension(1:6), intent(out)] :: Depending
            on the target value, an array to receive the cartesian
            position (x,y,z) and the velocity (xdot, ydot, zdot), or a
            time scale transformation value, or the angles of the
            librations of the Moon and their derivatives, or the nutation
            angles and their derivatives.

            Return:

   calceph_compute [INTEGER(C_INT)] :: 0 if an error occurs, otherwise
   non-zero value.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates a single object, usually the position and velocity of
   one body (target) relative to another (center) for the time JD0+time
   and stores the results to PV. The ephemeris file associated to eph must
   have been previously opened with the function calceph_open().

   The returned array PV has the following properties

     * If the target is TT-TDB, only the first element of this array will
       get the result. The time scale transformation TT-TDB is expressed
       in seconds.
     * If the target is TCG-TCB, only the first element of this array will
       get the result. The time scale transformation TCG-TCB is expressed
       in seconds.
     * If the target is Librations, the array contains the angles of the
       librations of the Moon and their derivatives. The angles of the
       librations of the Moon are expressed in radians and their
       derivatives are expressed in radians per day.
     * If the target is Nutations, the array contains the nutation angles
       and their derivatives. The nutation angles are expressed in radians
       and their derivatives are expressed in radians per day.
     * Otherwise the returned values is the cartesian position (x,y,z),
       expressed in Astronomical Unit (au), and the velocity (xdot, ydot,
       zdot), expressed in Astronomical Unit per day (au/day).

   To get the best numerical precision for the interpolation, the time is
   splitted in two floating-point numbers. The argument JD0 should be an
   integer and time should be a fraction of the day. But you may call this
   function with time=0 and JD0, the desired time, if you don't take care
   about numerical precision.

   The possible values for target and center are :
                 value                       meaning
   1                                  Mercury Barycenter
   2                                  Venus Barycenter
   3                                  Earth
   4                                  Mars Barycenter
   5                                  Jupiter Barycenter
   6                                  Saturn Barycenter
   7                                  Uranus Barycenter
   8                                  Neptune Barycenter
   9                                  Pluto Barycenter
   10                                 Moon
   11                                 Sun
   12                                 Solar Sytem barycenter
   13                                 Earth-moon barycenter
   14                                 Nutation angles
   15                                 Librations
   16                                 TT-TDB
   17                                 TCG-TCB
   asteroid number + CALCEPH_ASTEROID asteroid

   These accepted values by this function are the same as the value for
   the JPL function PLEPH, except for the values TT-TDB, TCG-TCB and
   asteroids.

   For example, the value "CALCEPH_ASTEROID+4" for target or center
   specifies the asteroid Vesta.

   The following example prints the heliocentric coordinates of Mars at
   time=2442457.5 and at 2442457.9
integer*8 peph
integer res
real(8) jd0
real(8) dt1, dt2
real(8) PV(6)
TYPE(C_PTR) :: peph

jd0 = 2442457
dt1 = 0.5D0
dt2 = 0.9D0
peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   ! the heliocentric coordinates of Mars
   res = calceph_compute(peph,jd0, dt1, 4, 11, PV)
   write(*,*) PV

   res = calceph_compute(peph,jd0, dt2, 4, 11, PV)
   write(*,*) PV

    call calceph_close(peph)
 endif

calceph_compute_unit¶

   function calceph_compute_unit(eph, JD0, time, target, center, unit, PV
          ) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body or
            reference point whose coordinates are required. The numbering
            system depends on the parameter unit.
          + center [INTEGER(C_INT), VALUE, intent(in)] :: The origin of
            the coordinate system. The numbering system depends on the
            parameter unit.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PV.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target and the
            center (NAIF identification numbers for the list).
            If the unit doesnot contain CALCEPH_USE_NAIFID, the old number
            system is used for the target and the center (see the list in
            the function calceph_compute()).
          + PV [REAL(C_DOUBLE), dimension(1:6), intent(out)] :: Depending
            on the target value, an array to receive the cartesian
            position (x,y,z) and the velocity (xdot, ydot, zdot), or a
            time scale transformation value, or the angles of the
            librations of the Moon and their derivatives, or the nutation
            angles and their derivatives.

            Return:

   calceph_compute_unit [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function is similar to the function calceph_compute(), except that
   the units of the output are specified.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates a single object, usually the position and velocity of
   one body (target) relative to another (center) for the time JD0+time
   and stores the results to PV. The ephemeris file associated to eph must
   have been previously opened with the function calceph_open(). The
   output values are expressed in the units specified by unit.

   This function checks the units if invalid combinations of units are
   given to the function.

   The returned array PV has the following properties

     * If the target is the time scale transformation TT-TDB, only the
       first element of this array will get the result.
     * If the target is the time scale transformation TCG-TCB, only the
       first element of this array will get the result.
     * If the target is Librations, the array contains the angles of the
       librations of the Moon and their derivatives.
     * If the target is Nutations, the array contains the nutation angles
       and their derivatives.
     * Otherwise the returned value is the cartesian position (x,y,z) and
       the velocity (xdot, ydot, zdot).

   The values stored in the array PV are expressed in the following units

     * The position and velocity are expressed in Astronomical Unit (au)
       if unit contains CALCEPH_UNIT_AU.
     * The position and velocity are expressed in kilometers if unit
       contains CALCEPH_UNIT_KM.
     * The velocity, TT-TDB, TCG-TCB, the derivatives of the angles of the
       nutation, or the derivatives of the librations of the Moon or are
       expressed in days if unit contains CALCEPH_UNIT_DAY.
     * The velocity, TT-TDB, TCG-TCB, the derivatives of the angles of the
       nutation, or the derivatives of the librations of the Moon are
       expressed in seconds if unit contains CALCEPH_UNIT_SEC.
     * The angles of the librations of the Moon or the nutation angles are
       expressed in radians if unit contains CALCEPH_UNIT_RAD.

   For example, to get the position and velocities expressed in kilometers
   and kilometers/seconds, the unit must be set to CALCEPH_UNIT_KM +
   CALCEPH_UNIT_SEC.

   The following example prints the heliocentric coordinates of Mars at
   time=2442457.5
integer res
real(8) jd0
real(8) dt1
real(8) PV(6)
TYPE(C_PTR) :: peph

jd0 = 2442457
dt1 = 0.5D0
peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   ! the heliocentric coordinates of Mars  in km and km/s
   res = calceph_compute_unit(peph,jd0, dt1, 4, 11,
&                            CALCEPH_UNIT_KM+CALCEPH_UNIT_SEC,
&                            PV)
   write(*,*) PV

   ! compute same quantity as the previous call using NAIF ID
   res = calceph_compute_unit(peph,jd0, dt1,
&                            NAIFID_MARS_BARYCENTER, NAIFID_SUN,
&                            CALCEPH_USE_NAIFID+CALCEPH_UNIT_KM+CALCEPH_UNIT_SEC
,
&                            PV)
   write(*,*) PV

    call calceph_close(peph)
 endif

calceph_orient_unit¶

   function calceph_orient_unit(eph, JD0, time, target, unit, PV) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body whose
            orientations are requested. The numbering system depends on
            the parameter unit.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PV.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target (NAIF
            identification numbers for the list).
            If the unit does not contain CALCEPH_USE_NAIFID, the old
            number system is used for the target (see the list in the
            function calceph_compute()).
          + PV [REAL(C_DOUBLE), dimension(1:6), intent(out)] :: An array
            to receive the euler angles, or nutation angles, and their
            derivatives for the orientation of the body.

            Return:

   calceph_orient_unit [INTEGER(C_INT)] :: 0 if an error occurs, otherwise
   non-zero value.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates the orientation of a single body (target) for the time
   JD0+time and stores the results to PV. The ephemeris file associated to
   eph must have been previously opened with the function calceph_open().
   The output values are expressed in the units specified by unit.

   This function checks the units if invalid combinations of units are
   given to the function.

   The returned array PV has the following properties

     * If unit contains CALCEPH_OUTPUT_NUTATIONANGLES, the array contains
       the nutation angles and their derivatives for the orientation of
       the body. At the present moment, only the nutation for the earth
       are supported in the original DE files.
     * If unit contains CALCEPH_OUTPUT_EULERANGLES, or doesnot contain
       CALCEPH_OUTPUT_NUTATIONANGLES, the array contains the euler angles
       and their derivatives for the orientation of the body.

   The values stored in the array PV are expressed in the following units

     * The derivatives of the angles are expressed in days if unit
       contains CALCEPH_UNIT_DAY.
     * The derivatives of the angles are expressed in seconds if unit
       contains CALCEPH_UNIT_SEC.
     * The angles and their derivatives are expressed in radians if unit
       contains CALCEPH_UNIT_RAD.

   For example, to get the nutation angles of the Earth and their
   derivatives expressed in radian and radian/seconds using the NAIF
   identification numbering system, the target must be set to NAIFID_EARTH
   and the unit must be set to CALCEPH_OUTPUT_NUTATIONANGLES +
   CALCEPH_UNIT_RAD + CALCEPH_UNIT_SEC.

   The following example prints the angles of libration of the Moon at
   time=2442457.5
integer res
real(8) jd0
real(8) dt1
real(8) PV(6)
TYPE(C_PTR) :: peph

jd0 = 2442457
dt1 = 0.5D0
peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   res = calceph_orient_unit(peph,jd0, dt1, NAIFID_MOON,
&                            CALCEPH_USE_NAIFID+CALCEPH_UNIT_RAD+CALCEPH_UNIT_SE
C,
&                            PV)
   write(*,*) PV

    call calceph_close(peph)
 endif

calceph_rotangmom_unit¶

   function calceph_rotangmom_unit(eph, JD0, time, target, unit, PV)
          BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body whose
            orientations are requested. The numbering system depends on
            the parameter unit.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PV.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target (NAIF
            identification numbers for the list).
            If the unit does not contain CALCEPH_USE_NAIFID, the old
            number system is used for the target (see the list in the
            function calceph_compute()).
          + PV [REAL(C_DOUBLE), dimension(1:6), intent(out)] :: An array
            to receive the angular momentum due to its rotation, divided
            by the product of the mass and of the square of the radius,
            and the derivatives, of the body.

            Return:

   calceph_rotangmom_unit [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates the angular momentum vector due to the rotation of the
   body, divided by the product of the mass m and of the square of the
   radius R , of a single body (target) for the time JD0+time and stores
   the results to PV. The ephemeris file associated to eph must have been
   previously opened with the function calceph_open(). The angular
   momentum L , due to the rotation of the body, is defined as the product
   of the inertia matrix I by the angular velocity vector {\omega} . So
   the returned value is L/(mR^2)=(I\omega)/(mR^2) The output values are
   expressed in the units specified by unit.

   This function checks the units if invalid combinations of units are
   given to the function.

   The values stored in the array PV are expressed in the following units

     * The angular momentum and its derivative are expressed in days if
       unit contains CALCEPH_UNIT_DAY.
     * The angular momentum and its derivative are expressed in seconds if
       unit contains CALCEPH_UNIT_SEC.

   The following example prints the angular momentum, due to its rotation,
   for the Earth at time=2451419.5
integer res
real(8) jd0
real(8) dt1
real(8) G(6)
TYPE(C_PTR) :: peph

jd0 = 2451419
dt1 = 0.5D0
peph = calceph_open("example2_rotangmom.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   res = calceph_rotangmom_unit(peph,jd0, dt1, NAIFID_EARTH,
&                            CALCEPH_USE_NAIFID+CALCEPH_UNIT_SEC,
&                            G)
   write(*,*) G

    call calceph_close(peph)
 endif

calceph_compute_order¶

   function calceph_compute_order(eph, JD0, time, target, center, unit,
          order, PVAJ ) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body or
            reference point whose coordinates are required (see the list,
            below).
          + center [INTEGER(C_INT), VALUE, intent(in)] :: The origin of
            the coordinate system (see the list, below). If target is 14,
            15, 16 or 17 (nutation, libration, TT-TDB or TCG-TCB), center
            must be 0.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PVAJ.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target and the
            center (NAIF identification numbers for the list).
            If the unit doesnot contain CALCEPH_USE_NAIFID, the old number
            system is used for the target and the center (see the list in
            the function calceph_compute()).
          + order [INTEGER(C_INT), VALUE, intent(in)] ::
            The order of derivatives

               o = 0 , only the position is computed. The first three
                 numbers of PVAJ are valid for the results.
               o = 1 , only the position and velocity are computed. The
                 first six numbers of PVAJ are valid for the results.
               o = 2 , only the position, velocity and acceleration are
                 computed. The first nine numbers of PVAJ are valid for
                 the results.
               o = 3 , the position, velocity and acceleration and jerk
                 are computed. The first twelve numbers of PVAJ are valid
                 for the results.

            If order equals to 1, the behavior of calceph_compute_order()
            is the same as calceph_compute_unit().
          + PVAJ [REAL(C_DOUBLE), dimension(1:12), intent(out)] ::
            Depending on the target value, an array to receive the
            cartesian position (x,y,z), the velocity (xdot, ydot, zdot),
            the acceleration and the jerk, or a time scale transformation
            value, or the angles of the librations of the Moon and their
            successive derivatives, or the nutation angles and their
            successive derivatives.

            Return:

   calceph_compute_order [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function is similar to the function calceph_compute_unit(), except
   that the order of the computed derivatives is specified.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates a single object, usually the position and their
   derivatives of one body (target) relative to another (center) for the
   time JD0+time and stores the results to PVAJ. The ephemeris file
   associated to eph must have been previously opened with the function
   calceph_open(). The order of the derivatives are specified by order.
   The output values are expressed in the units specified by unit.

   The returned array PVAJ has the following properties

     * If the target is the time scale transformation TT-TDB, only the
       first elements of each component will get the result.
     * If the target is the time scale transformation TCG-TCB, only the
       first elements of each component will get the result.
     * If the target is Librations, the array contains the angles of the
       librations of the Moon and their successive derivatives.
     * If the target is Nutations, the array contains the nutation angles
       and their successive derivatives.
     * Otherwise the returned value is the cartesian position (x,y,z), the
       velocity (xdot, ydot, zdot), the jerk and the acceleration.

   The returned array PVAJ must be large enough to store the results.

     * PVAJ[1:3] contain the position (x,y,z) and is always valid.
     * PVAJ[4:6] contain the velocity (dx/dt,dy/dt,dz/dt) and is only
       valid if order is greater or equal to 1.
     * PVAJ[7:9] contain the acceleration (d^2x/dt^2,d^2y/dt^2,d^2z/dt^2)
       and is only valid if order is greater or equal to 2.
     * PVAJ[10:12] contain the jerk (d^3x/dt^3,d^3y/dt^3,d^3z/dt^3) and is
       only valid if order is equal to 3.

   The values stored in the array PVAJ are expressed in the following
   units

     * The position, velocity, acceleration and jerk are expressed in
       Astronomical Unit (au) if unit contains CALCEPH_UNIT_AU.
     * The position, velocity, acceleration and jerk are expressed in
       kilometers if unit contains CALCEPH_UNIT_KM.
     * The velocity, acceleration, jerk, TT-TDB, TCG-TCB or the
       derivatives of the angles of the librations of the Moon are
       expressed in days if unit contains CALCEPH_UNIT_DAY.
     * The velocity, acceleration, jerk, TT-TDB, TCG-TCB or the
       derivatives of the angles of the librations of the Moon are
       expressed in seconds if unit contains CALCEPH_UNIT_SEC.
     * The angles of the librations of the Moon are expressed in radians
       if unit contains CALCEPH_UNIT_RAD.

   For example, to get the positions, velocities, accelerations and jerks
   expressed in kilometers and kilometers/seconds, the unit must be set to
   CALCEPH_UNIT_KM + CALCEPH_UNIT_SEC.

   This function checks the units if invalid combinations of units are
   given to the function.

   The following example prints the heliocentric coordinates of Mars at
   time=2442457.5
integer res
real(8) jd0
real(8) dt1
real(8) P(3)
real(8) PVAJ(12)
TYPE(C_PTR) :: peph

jd0 = 2442457
dt1 = 0.5D0
peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   ! compute only the heliocentric position of Mars in km
   res = calceph_compute_order(peph, jd0, dt1,
&                     NAIFID_MARS_BARYCENTER,
&                     NAIFID_SUN,
&                     CALCEPH_USE_NAIFID+CALCEPH_UNIT_KM+CALCEPH_UNIT_SEC,
&                     0, P);
   write(*,*) P

   ! compute positions, velocities, accelerations and jerks of Mars in km and se
conds
   res = calceph_compute_order(peph, jd0, dt1,
&                     NAIFID_MARS_BARYCENTER,
&                     NAIFID_SUN,
&                     CALCEPH_USE_NAIFID+CALCEPH_UNIT_KM+CALCEPH_UNIT_SEC,
&                     3, PVAJ);
   write(*,*) PVAJ

    call calceph_close(peph)
 endif

calceph_orient_order¶

   function calceph_orient_order(eph, JD0, time, target, unit, order, PVAJ
          ) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body whose
            orientations are requested. The numbering system depends on
            the parameter unit.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PVAJ.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target and the
            center (NAIF identification numbers for the list).
            If the unit doesnot contain CALCEPH_USE_NAIFID, the old number
            system is used for the target and the center (see the list in
            the function calceph_compute()).
          + order [INTEGER(C_INT), VALUE, intent(in)] ::
            The order of derivatives.

               o = 0 , only the angles is computed. The first three
                 numbers of PVAJ are valid for the results.
               o = 1 , only the angles and the first derivative are
                 computed. The first six numbers of PVAJ are valid for the
                 results.
               o = 2 , only the angles and the first and second
                 derivatives are computed. The first nine numbers of PVAJ
                 are valid for the results.
               o = 3 , the angles and the first, second and third
                 derivatives are computed. The first twelve numbers of
                 PVAJ are valid for the results.

            If order equals to 1, the behavior of calceph_orient_order()
            is the same as calceph_orient_unit().
          + PVAJ [REAL(C_DOUBLE), dimension(1:12), intent(out)] :: An
            array to receive the euler angles, or nutation angles, and
            their derivatives for the orientation of the body.

            Return:

   calceph_compute_order [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function is similar to the function calceph_orient_unit(), except
   that the order of the computed derivatives is specified.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates the orientation of a single body (target) for the time
   JD0+time and stores the results to PVAJ. The order of the derivatives
   are specified by order. The ephemeris file associated to eph must have
   been previously opened with the function calceph_open(). The output
   values are expressed in the units specified by unit.

   This function checks the units if invalid combinations of units are
   given to the function.

   The returned array PVAJ has the following properties

     * If unit contains CALCEPH_OUTPUT_NUTATIONANGLES, the array contains
       the nutation angles and their successive derivatives for the
       orientation of the body. At the present moment, only the nutation
       for the earth are supported in the original DE files.
     * If unit contains CALCEPH_OUTPUT_EULERANGLES, or doesnot contain
       CALCEPH_OUTPUT_NUTATIONANGLES, the array contains the euler angles
       and their successive derivatives for the orientation of the body.

   The returned array PVAJ must be large enough to store the results.

     * PVAJ[1:3] contain the angles and is always valid.
     * PVAJ[4:6] contain the first derivative and is only valid if order
       is greater or equal to 1.
     * PVAJ[7:9] contain the second derivative and is only valid if order
       is greater or equal to 2.
     * PVAJ[10:12] contain the third derivative and is only valid if order
       is equal to 3.

   The values stored in the array PVAJ are expressed in the following
   units

     * The derivatives of the angles are expressed in days if unit
       contains CALCEPH_UNIT_DAY.
     * The derivatives of the angles are expressed in seconds if unit
       contains CALCEPH_UNIT_SEC.
     * The angles and their derivatives are expressed in radians if unit
       contains CALCEPH_UNIT_RAD.

   The following example prints only the angles of libration of the Moon
   at time=2442457.5
integer res
real(8) jd0
real(8) dt1
real(8) P(3)
TYPE(C_PTR) :: peph

jd0 = 2442457
dt1 = 0.5D0
peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   res = calceph_orient_order(peph,jd0, dt1, NAIFID_MOON,
&                            CALCEPH_USE_NAIFID+CALCEPH_UNIT_RAD+CALCEPH_UNIT_SE
C,
&                            0, P)
   write(*,*) P

    call calceph_close(peph)
 endif

calceph_rotangmom_order¶

   function calceph_rotangmom_order(eph, JD0, time, target, unit, order,
          PVAJ ) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body whose
            orientations are requested. The numbering system depends on
            the parameter unit.
          + unit [INTEGER(C_INT), VALUE, intent(in)] ::
            The units of PVAJ.
            This integer is a sum of some unit constants
            (CALCEPH_UNIT_???) and/or the constant CALCEPH_USE_NAIFID.
            If the unit contains CALCEPH_USE_NAIFID, the NAIF
            identification numbering system is used for the target and the
            center (NAIF identification numbers for the list).
            If the unit doesnot contain CALCEPH_USE_NAIFID, the old number
            system is used for the target and the center (see the list in
            the function calceph_compute()).
          + order [INTEGER(C_INT), VALUE, intent(in)] ::
            The order of derivatives.

               o = 0 , only the angular momentum is computed. The first
                 three numbers of PVAJ are valid for the results.
               o = 1 , only the angular momentum and the first derivative
                 are computed. The first six numbers of PVAJ are valid for
                 the results.
               o = 2 , only the angular momentum and the first and second
                 derivatives are computed. The first nine numbers of PVAJ
                 are valid for the results.
               o = 3 , the angular momentum and the first, second and
                 third derivatives are computed. The first twelve numbers
                 of PVAJ are valid for the results.

            If order equals to 1, the behavior of
            calceph_rotangmom_order() is the same as
            calceph_rotangmom_unit().
          + PVAJ [REAL(C_DOUBLE), dimension(1:12), intent(out)] :: An
            array to receive the angular momentum due to its rotation,
            divided by the product of the mass and of the square of the
            radius, and their different order of the derivatives, of the
            body.

            Return:

   calceph_rotangmom_order [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function is similar to the function calceph_orient_unit(), except
   that the order of the computed derivatives is specified.

   This function reads, if needed, in the ephemeris file associated to eph
   and interpolates the angular momentum vector due to the rotation of the
   body, divided by the product of the mass m and of the square of the
   radius R , of a single body (target) for the time JD0+time and stores
   the results to PVAJ. The angular momentum L , due to the rotation of
   the body, is defined as the product of the inertia matrix I by the
   angular velocity vector {\omega} . So the returned value is
   L/(mR^2)=(I\omega)/(mR^2) The order of the derivatives are specified by
   order. The ephemeris file associated to eph must have been previously
   opened with the function calceph_open(). The output values are
   expressed in the units specified by unit.

   This function checks the units if invalid combinations of units are
   given to the function.

   The returned array PVAJ must be large enough to store the results.

     * PVAJ[1:3] contain the angular momentum and is always valid.
     * PVAJ[4:6] contain the first derivative and is only valid if order
       is greater or equal to 1.
     * PVAJ[7:9] contain the second derivative and is only valid if order
       is greater or equal to 2.
     * PVAJ[10:12] contain the third derivative and is only valid if order
       is equal to 3.

   The values stored in the array PVAJ are expressed in the following
   units

     * The angular momentum and its derivatives are expressed in days if
       unit contains CALCEPH_UNIT_DAY.
     * The angular momentum and its derivatives are expressed in seconds
       if unit contains CALCEPH_UNIT_SEC.

   The following example prints only the angular momentum, due to its
   rotation, of the Earth at time=2451419.5
integer res
real(8) jd0
real(8) dt1
real(8) G(3)
TYPE(C_PTR) :: peph

jd0 = 2451419
dt1 = 0.5D0
peph = calceph_open("example2_rotangmom.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then

   res = calceph_rotangmom_order(peph,jd0, dt1, NAIFID_EARTH,
&                            CALCEPH_USE_NAIFID+CALCEPH_UNIT_SEC,
&                            G)
   write(*,*) G

    call calceph_close(peph)
 endif

calceph_getconstant¶

   function calceph_getconstant(eph, name, value) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor.
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [REAL(C_DOUBLE), intent(out)] :: first value of the
            constant.

            Return:

   calceph_getconstant [INTEGER(C_INT)] :: returns 0 if an error occurs,
   otherwise the number of values associated to the constant.

   This function returns the value associated to the constant name in the
   header of the ephemeris file associated to eph. Only the first value is
   returned if multiple values are associated to a constant, such as a
   list of values.

   This function is the same function as calceph_getconstantsd().

   The following example prints the value of the astronomical unit stored
   in the ephemeris file
integer res
real(8) AU
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     ! print the value of AU
     if (calceph_getconstant(peph, "AU"//C_NULL_CHAR, AU).eq.1) then
        write (*,*) "AU=", AU
    endif

    call calceph_close(peph)
 endif

calceph_getconstantsd¶

   function calceph_getconstantsd(eph, name, value) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor.
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [REAL(C_DOUBLE), intent(out)] :: first value of the
            constant.

            Return:

   calceph_getconstantsd [INTEGER(C_INT)] :: returns 0 if an error occurs,
   otherwise the number of values associated to the constant.

   This function returns, as a floating-point number, the value associated
   to the constant name in the header of the ephemeris file associated to
   eph. Only the first value is returned if multiple values are associated
   to a constant, such as a list of values. The value must be a
   floating-point or integer number, otherwise an error is reported.

   This function is the same function as calceph_getconstant().

   The following example prints the value of the astronomical unit stored
   in the ephemeris file
integer res
real(8) AU
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     ! print the value of AU
     if (calceph_getconstantsd(peph, "AU"//C_NULL_CHAR, AU).eq.1) then
        write (*,*) "AU=", AU
    endif

    call calceph_close(peph)
 endif

calceph_getconstantvd¶

   function calceph_getconstantvd(eph, name, arrayvalue, nvalue) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor.
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [REAL(C_DOUBLE), dimension(1:nvalue), intent(out)] ::
            array of values for the constant.
          + nvalue [INTEGER(C_INT), VALUE, intent(in)] :: number of
            elements of the array

            Return:

   calceph_getconstantvd [INTEGER(C_INT)] :: returns 0 if an error occurs,
   otherwise the number of values associated to the constant.

   This function stores, to the array arrayvalue as floating-point
   numbers, the nvalue first values associated to the constant name in the
   header of the ephemeris file associated to eph. The integer value
   returned by the function is equal to the number of valid entries in the
   arrayvalue if nvalue is greater or equal to that integer value..

   The required value nvalue to store all values can be determinated with
   the previous call to calceph_getconstantsd.

   The values must be floating-point or integer numbers, otherwise an
   error is reported.

   The following example prints the body radii of the earth stored in the
   ephemeris file
integer res, nvalue
real(8) svalue
real(8), allocatable :: radii
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     ! get the number of values
     nvalue = calceph_getconstantsd(peph, "BODY399_RADII"//C_NULL_CHAR, svalue)
     ! fill the array
     allocate(radii(1:nvalue))
     res = calceph_getconstantvd(peph, "BODY399_RADII"//C_NULL_CHAR, radii, nval
ue)
     write(*,*) radii

    call calceph_close(peph)
 endif

calceph_getconstantss¶

   function calceph_getconstantss(eph, name, value) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor.
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [CHARACTER(len=1,kind=C_CHAR),
            dimension(CALCEPH_MAX_CONSTANTNAME), intent(out)] :: first
            value of the constant.

            Return:

   calceph_getconstantss [INTEGER(C_INT)] :: returns 0 if an error occurs,
   otherwise the number of values associated to the constant.

   This function returns, as a string of character, the value associated
   to the constant name in the header of the ephemeris file associated to
   eph. Only the first value is returned if multiple values are associated
   to a constant, such as a list of values. The value must be a string,
   otherwise an error is reported.

   Trailing blanks are added to each value.

   The following example prints the value of the unit stored in the
   ephemeris file
integer res
character(len=CALCEPH_MAX_CONSTANTVALUE, kind=C_CHAR) UNIT
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
    ! print the value of UNIT
    if (calceph_getconstantss(peph, "UNIT"//C_NULL_CHAR, UNIT).eq.1) then
        write (*,*) "UNIT=", trim(UNIT)
    endif

    call calceph_close(peph)
 endif

calceph_getconstantvs¶

   function calceph_getconstantvs(eph, name, arrayvalue, nvalue) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor.
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [CHARACTER(len=1,kind=C_CHAR), dimension(1:nvalue),
            intent(out)] :: array of values for the constant.
          + nvalue [INTEGER(C_INT), VALUE, intent(in)] :: number of
            elements of the array

            Return:

   calceph_getconstantvs [INTEGER(C_INT)] :: returns 0 if an error occurs,
   otherwise the number of values associated to the constant.

   This function stores, to the array arrayvalue as strings of characters,
   the nvalue first values associated to the constant name in the header
   of the ephemeris file associated to eph. The integer value returned by
   the function is equal to the number of valid entries in the arrayvalue
   if nvalue is greater or equal to that integer value.

   The required value nvalue to store all values can be determinated with
   the previous call to calceph_getconstantss.

   The values must be strings, otherwise an error is reported.

   Trailing blanks are added to each value.

   The following example prints the units of the mission stored in the
   ephemeris file
integer res, nvalue
character(len=CALCEPH_MAX_CONSTANTVALUE, kind=C_CHAR) svalue
character(len=CALCEPH_MAX_CONSTANTVALUE, kind=C_CHAR), allocatable :: mission_un
its
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     ! get the number of values
     nvalue = calceph_getconstantss(peph, "MISSION_UNITS"//C_NULL_CHAR, svalue)
     ! fill the array
     allocate(mission_units(1:nvalue))
     res = calceph_getconstantvs(peph, "MISSION_UNITS"//C_NULL_CHAR, mission_uni
ts, nvalue)
     write(*,*) mission_units
     deallocate(mission_units)

    call calceph_close(peph)
 endif

calceph_getconstantcount¶

   function calceph_getconstantcount(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor
   Return: calceph_getconstantcount [INTEGER(C_INT)] :: number of
   constants. 0 if an error occurs, otherwise non-zero value.

   This function returns the number of constants available in the header
   of the ephemeris file associated to eph.

   The following example prints the number of available constants stored
   in the ephemeris file
integer res
integer n
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
  n = calceph_getconstantcount(peph)
  write (*,*) "number of constants", n
  call calceph_close(peph)
endif

calceph_getconstantindex¶

   function calceph_getconstantindex(eph, index, name, value) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + index [INTEGER(C_INT), VALUE, intent(in)] :: index of the
            constant, between 1 and calceph_getconstantcount()
          + name [CHARACTER(len=1,kind=C_CHAR),
            dimension(CALCEPH_MAX_CONSTANTNAME), intent(out)] :: name of
            the constant.
          + value [REAL(C_DOUBLE), intent(out)] :: first value of the
            constant

            Return:

   calceph_getconstantindex [INTEGER(C_INT)] :: returns 0 if an error
   occurs, otherwise the number of values associated to the constant.

   This function returns the name and its value of the constant available
   at the specified index in the header of the ephemeris file associated
   to eph. The value of index must be between 1 and
   calceph_getconstantcount().

   Only the first value is returned if multiple values are associated to a
   constant, such as a list of values.

   The following example displays the name of the constants, stored in the
   ephemeris file, and their values
   USE, INTRINSIC :: ISO_C_BINDING
   use calceph
   implicit none
   integer res
   integer j
   real(8) valueconstant
   character(len=CALCEPH_MAX_CONSTANTNAME) nameconstant
   TYPE(C_PTR) :: peph

! open the ephemeris file
   peph = calceph_open("example1.dat"//C_NULL_CHAR)
   if (C_ASSOCIATED(peph)) then

! print the list of constants
     do j=1, calceph_getconstantcount(peph)
       res = calceph_getconstantindex(peph,j,nameconstant, valueconstant)
       write (*,*) nameconstant,"=",valueconstant
     enddo

     call calceph_close(peph)
   endif

calceph_getfileversion¶

   function calceph_getfileversion(eph, version) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + version [CHARACTER(len=1,kind=C_CHAR),
            dimension(CALCEPH_MAX_CONSTANTVALUE), intent(out)] :: version
            of the file

            Return:

   calceph_getfileversion [INTEGER(C_INT)] :: returns 0 if the file
   version was not found, otherwise non-zero value.

   This function returns the version of the ephemeris file, as a string.
   For example, the argument version will contain 'INPOP10B', 'EPM2017' or
   'DE405', ... .

   If the file is an original JPL binary planetary ephemeris, then the
   version of the file can always be determined. If the file is a spice
   kernel, the version of the file is retrieved from the constant
   INPOP_PCK_VERSION, EPM_PCK_VERSION, or PCK_VERSION.

   The following example prints the version of the ephemeris file.
integer res
character(len=CALCEPH_MAX_CONSTANTVALUE) version
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     res = calceph_getfileversion(peph, version)
     write (*,*) "The version of the file is ", version

    call calceph_close(peph)
 endif

calceph_gettimescale¶

   function calceph_gettimescale(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor
   Return: calceph_gettimescale [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function returns the timescale of the ephemeris file associated to
          eph :

          + 1 if the quantities of all bodies are expressed in the TDB
            time scale.
          + 2 if the quantities of all bodies are expressed in the TCB
            time scale.

   The following example prints the time scale available in the ephemeris
   file
integer res
integer timescale
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
   ! print the time scale
   timescale = calceph_gettimescale(peph)
   write (*,*) "timescale=", timescale

   call calceph_close(peph)
 endif

calceph_gettimespan¶

   function calceph_gettimespan(eph, firsttime, lasttime, continuous)
          BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + firsttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            first time
          + lasttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            last time
          + continuous [INTEGER(C_INT), intent(out)] :: information about
            the availability of the quantities over the time span

            Return:

   calceph_gettimespan [INTEGER(C_INT)] :: 0 if an error occurs, otherwise
   non-zero value.

   This function returns the first and last time available in the
   ephemeris file associated to eph. The Julian date for the first and
   last time are expressed in the time scale returned by
   calceph_gettimescale() .

   It returns the following value in the parameter continuous :

     * 1 if the quantities of all bodies are available for any time
       between the first and last time.
     * 2 if the quantities of some bodies are available on discontinuous
       time intervals between the first and last time.
     * 3 if the quantities of each body are available on a continuous time
       interval between the first and last time, but not available for any
       time between the first and last time.

   The following example prints the first and last time available in the
   ephemeris file
integer res
integer :: continuous
real(8) :: firsttime, lasttime
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
     if (calceph_gettimespan(peph, firsttime, lasttime, continuous).eq.1) then
        write (*,*) firsttime, lasttime, countinuous
    endif

    call calceph_close(peph)
 endif

calceph_getpositionrecordcount¶

   function calceph_getpositionrecordcount(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor
   Return: calceph_getpositionrecordcount [INTEGER(C_INT)] :: number of
   position's records. 0 if an error occurs, otherwise non-zero value.

   This function returns the number of position's records available in the
   ephemeris file associated to eph. Usually, the number of records is
   equal to the number of bodies in the ephemeris file if the timespan is
   continuous. If the timespan is discontinuous for the target and center
   bodies, then each different timespan is counted as a different record.
   If the ephemeris file contain timescale transformations' records, such
   as TT-TDB or TCG-TCB, then these records are included in the returned
   value.

   The following example prints the number of position's records available
   in the ephemeris file
integer res
integer n
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
  n = calceph_getpositionrecordcount(peph)
  write (*,*) "number of position's record", n
  call calceph_close(peph)
endif

calceph_getpositionrecordindex¶

   function calceph_getpositionrecordindex(eph, index, target, center,
          firsttime, lasttime, frame) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + index [INTEGER(C_INT), intent(int)] :: index of the position's
            record, between 1 and calceph_getpositionrecordcount()
          + target [INTEGER(C_INT), intent(out)] :: The target body
          + center [INTEGER(C_INT), intent(out)] :: The origin body
          + firsttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            first time
          + lasttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            last time
          + frame [INTEGER(C_INT), intent(out)] :: reference frame (see
            the list, below)

            Return:

   calceph_getpositionrecordindex [INTEGER(C_INT)] :: 0 if an error
   occurs, otherwise non-zero value.

   This function returns the target and origin bodies, the first and last
   time, and the reference frame available at the specified index for the
   position's records of the ephemeris file associated to eph. The NAIF
   identification numbering system is used for the target and center
   integers (NAIF identification numbers for the list). The Julian date
   for the first and last time are expressed in the time scale returned by
   calceph_gettimescale().

   It returns the following value in the parameter frame :
   value Name
   1     ICRF

   The following example displays the position's records stored in the
   ephemeris file.
   USE, INTRINSIC :: ISO_C_BINDING
   use calceph
   implicit none
   integer res
   integer j, itarget, icenter, iframe
   real(C_DOUBLE) firsttime, lasttime
   TYPE(C_PTR) :: peph

! open the ephemeris file
   peph = calceph_open("example1.dat"//C_NULL_CHAR)
   if (C_ASSOCIATED(peph)) then

! print the list of positionrecords
     do j=1, calceph_getpositionrecordcount(peph)
       res = calceph_getpositionrecordindex(peph,j,itarget, icenter, firsttime,
lasttime, iframe)
       write (*,*) itarget, icenter, firsttime, lasttime, iframe
     enddo

     call calceph_close(peph)
   endif

calceph_getorientrecordcount¶

   function calceph_getorientrecordcount(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor
   Return: calceph_getorientrecordcount [INTEGER(C_INT)] :: number of
   orientation's records. 0 if an error occurs, otherwise non-zero value.

   This function returns the number of orientation's records available in
   the ephemeris file associated to eph. Usually, the number of records is
   equal to the number of bodies in the ephemeris file if the timespan is
   continuous. If the timespan is discontinuous for the target body, then
   each different timespan is counted as a different record.

   The following example prints the number of orientation's records
   available in the ephemeris file
integer res
integer n
TYPE(C_PTR) :: peph

peph = calceph_open("example1.dat"//C_NULL_CHAR)
if (C_ASSOCIATED(peph)) then
  n = calceph_getorientrecordcount(peph)
  write (*,*) "number of orientation's record", n
  call calceph_close(peph)
endif

calceph_getorientrecordindex¶

   function calceph_getorientrecordindex(eph, index, target, firsttime,
          lasttime, frame) BIND(C)¶

   Parameters:
          + eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris descriptor
          + index [INTEGER(C_INT), intent(int)] :: index of the
            orientation's record, between 1 and
            calceph_getorientrecordcount()
          + target [INTEGER(C_INT), intent(out)] :: The target body
          + firsttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            first time
          + lasttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            last time
          + frame [INTEGER(C_INT), intent(out)] :: reference frame (see
            the list, below)

            Return:

   calceph_getorientrecordindex [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function returns the target body, the first and last time, and the
   reference frame available at the specified index for the orientation's
   records of the ephemeris file associated to eph. The NAIF
   identification numbering system is used for the target body (NAIF
   identification numbers for the list). The Julian date for the first and
   last time are expressed in the time scale returned by
   calceph_gettimescale().

   It returns the following value in the parameter frame :
   value Name
   1     ICRF

   The following example displays the orientation's records stored in the
   ephemeris file.
   USE, INTRINSIC :: ISO_C_BINDING
   use calceph
   implicit none
   integer res
   integer j, itarget, iframe
   real(C_DOUBLE) firsttime, lasttime
   TYPE(C_PTR) :: peph

! open the ephemeris file
   peph = calceph_open("example1.dat"//C_NULL_CHAR)
   if (C_ASSOCIATED(peph)) then

! print the list of orientation records
     do j=1, calceph_getorientrecordcount(peph)
       res = calceph_getorientrecordindex(peph,j,itarget, firsttime, lasttime, i
frame)
       write (*,*) itarget, firsttime, lasttime, iframe
     enddo

     call calceph_close(peph)
   endif

calceph_close¶

   subroutine calceph_close(eph) BIND(C)¶

   Parameters: eph [TYPE(C_PTR), VALUE, intent(in)] :: ephemeris
   descriptor

   This function closes the access associated to the ephemeris descriptor
   eph and frees allocated memory for it.

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Error functions Multiple file access functions

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
     * Single file access functions
          + Thread notes
          + Usage
          + Functions
               o calceph_sopen
               o calceph_scompute
               o calceph_sgetconstant
               o calceph_sgetconstantcount
               o calceph_sgetconstantindex
               o calceph_sgetfileversion
               o calceph_sgettimescale
               o calceph_sgettimespan
               o calceph_sclose
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Single file access functions
     *
     __________________________________________________________________

Single file access functions¶

   This group of functions works on a single ephemeris file at a given
   instant. They use an internal global variable to store information
   about the current opened ephemeris file.

   They are provided to have a similar interface of the fortran PLEPH
   function, supplied with the JPL ephemeris files. So the following call
   to PLEPH
PLEPH(46550D0, 3, 12, PV)

   could be replaced by
calceph_sopen("ephemerisfile.dat")
calceph_scompute(46550D0, 0, 3, 12, PV)
calceph_sclose()

   While the function PLEPH could access only one file in a program, these
   functions could access on multiple files in a program but not at same
   time. To access multiple files at a same time, the functions listed in
   the section Multiple file access functions must be used.

   When an error occurs, these functions execute error handlers according
   to the behavior defined by the function calceph_seterrorhandler().

   The python interface does not provide these functions, the listed in
   the section Multiple file access functions must be used.

Thread notes¶

   If the standard I/O functions such as fread are not reentrant then the
   CALCEPH I/O functions using them will not be reentrant either.

   If the library was configured with the option --enable-thread=yes,
   these functions use an internal global variable per thread. Each thread
   could access to different ephemeris file and compute ephemeris data at
   same time. But each thread must call the function calceph_sopen() to
   open ephemeris file even if all threads work on the same file.

   If the library was configured with the default option
   --enable-thread=no, these functions use an internal global variable per
   process and are not thread-safe. If multiple threads are used in the
   process and call the function calceph_scompute() at the same time, the
   caller thread must surround the call to this function with locking
   primitives, such as pthread_lock/pthread_unlock if POSIX Pthreads are
   used.

Usage¶

   The following examples, that can be found in the directory examples of
   the library sources, show the typical usage of this group of functions.

   The example in Fortran 2003 language is f2003single.f.
USE, INTRINSIC :: ISO_C_BINDING
use calceph
implicit none
integer res
real(8) AU, EMRAT, GM_Mer
real(8) jd0
real(8) dt
real(8) PV(6)
integer j
real(8) valueconstant
character(len=CALCEPH_MAX_CONSTANTNAME) nameconstant

jd0 = 2442457
dt = 0.5E0
! open the ephemeris file
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then
  write (*,*) "The ephemeris is already opened"
  ! print the values of AU, EMRAT and GM_Mer
  if (calceph_sgetconstant("AU"//C_NULL_CHAR, AU).eq.1) then
      write (*,*) "AU=", AU
  endif
  if (calceph_sgetconstant("EMRAT"//C_NULL_CHAR,EMRAT).eq.1) then
      write (*,*) "EMRAT=", EMRAT
  endif
  if (calceph_sgetconstant("GM_Mer"//C_NULL_CHAR,GM_Mer).eq.1) then
      write (*,*) "GM_Mer=", GM_Mer
  endif

  ! compute and print the coordinates
  ! the geocentric moon coordinates
  res = calceph_scompute(jd0, dt, 10, 3, PV)
  call printcoord(PV,"geocentric coordinates of the Moon")
  ! the value TT-TDB
  if (calceph_scompute(jd0, dt, 16, 0, PV).eq.1) then
    write (*,*) "TT-TDB = ", PV(1)
  endif
  ! the heliocentric coordinates of Mars
  res = calceph_scompute(jd0, dt, 4, 11, PV)
  call printcoord(PV,"heliocentric coordinates of Mars")


  ! print the whole list of the constants
  write (*,*) "list of constants"
  do j=1, calceph_sgetconstantcount()
    res = calceph_sgetconstantindex(j,nameconstant, valueconstant)
    write (*,*) nameconstant,"=",valueconstant
  enddo


  ! close the ephemeris file
  call calceph_sclose
  write (*,*) "The ephemeris is already closed"
else
  write (*,*) "The ephemeris can't be opened"
endif

Functions¶

calceph_sopen¶

   function calceph_sopen(filename) BIND(C)¶

   Parameters: filename [CHARACTER(len=1,kind=C_CHAR), intent(in)] ::
   pathname of the file.
   Return: calceph_sopen [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function opens the file whose pathname is the string pointed to by
   filename, reads the header of this file and associates an ephemeris
   descriptor to an internal variable. This file must be an ephemeris
   file.

   This file must be compliant to the format specified by the 'original
   JPL binary' , 'INPOP 2.0 binary' or 'SPICE' ephemeris file. At the
   moment, supported SPICE files are the following :

     * text Planetary Constants Kernel (KPL/PCK) files
     * binary PCK (DAF/PCK) files.
     * binary SPK (DAF/SPK) files containing segments of type 1, 2, 3, 5,
       8, 9, 12, 13, 17, 18, 20, 21, 102, 103 and 120.
     * meta kernel (KPL/MK) files.
     * frame kernel (KPL/FK) files. Only a basic support is provided.

   The function calceph_sclose() must be called to free allocated memory
   by this function.

   The following example opens the ephemeris file example1.dat
integer res
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then
     ! ...  computation ...
endif
call calceph_sclose

calceph_scompute¶

   function calceph_scompute(JD0, time, target, center, PV) BIND(C)¶

   Parameters:
          + JD0 [REAL(C_DOUBLE), VALUE, intent(in)] :: Integer part of the
            Julian date
          + time [REAL(C_DOUBLE), VALUE, intent(in)] :: Fraction part of
            the Julian date
          + target [INTEGER(C_INT), VALUE, intent(in)] :: The body or
            reference point whose coordinates are required (see the list,
            below).
          + center [INTEGER(C_INT), VALUE, intent(in)] :: The origin of
            the coordinate system (see the list, below). If target is 14,
            15, 16 or 17 (nutation, libration, TT-TDB or TCG-TCB), center
            must be 0.
          + PV [REAL(C_DOUBLE), dimension(1:6), intent(out)] :: Depending
            on the target value, an array to receive the cartesian
            position (x,y,z) and the velocity (xdot, ydot, zdot), or a
            time scale transformation value, or the angles of the
            librations of the Moon and their derivatives, or the nutation
            angles and their derivatives.

            Return:

   calceph_scompute [INTEGER(C_INT)] :: 0 if an error occurs, otherwise
   non-zero value.

   This function reads, if needed, and interpolates a single object,
   usually the position and velocity of one body (target) relative to
   another (center), from the ephemeris file, previously opened with the
   function calceph_sopen(), for the time JD0+time and stores the results
   to PV.

   To get the best precision for the interpolation, the time is splitted
   in two floating-point numbers. The argument JD0 should be an integer
   and time should be a fraction of the day. But you may call this
   function with time=0 and JD0, the desired time, if you don't take care
   about precision.

   The possible values for target and center are :
                 value                       meaning
   1                                  Mercury Barycenter
   2                                  Venus Barycenter
   3                                  Earth
   4                                  Mars Barycenter
   5                                  Jupiter Barycenter
   6                                  Saturn Barycenter
   7                                  Uranus Barycenter
   8                                  Neptune Barycenter
   9                                  Pluto Barycenter
   10                                 Moon
   11                                 Sun
   12                                 Solar Sytem barycenter
   13                                 Earth-moon barycenter
   14                                 Nutations
   15                                 Librations
   16                                 TT-TDB
   17                                 TCG-TCB
   asteroid number + CALCEPH_ASTEROID asteroid

   These accepted values by this function are the same as the value for
   the JPL function PLEPH, except for the values TT-TDB, TCG-TCB and
   asteroids.

   For example, the value "CALCEPH_ASTEROID+4" for target or center
   specifies the asteroid Vesta.

   The following example prints the heliocentric coordinates of Mars at
   time=2451624.5 and at 2451624.9
integer res
real(8) jd0
real(8) dt1, dt2
real(8) PV(6)

jd0 = 2442457
dt1 = 0.5D0
dt2 = 0.9D0

res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then
     ! the heliocentric coordinates of Mars
     res = calceph_scompute(jd0, dt1, 4, 11, PV)
     write (*,*) PV

     res = calceph_scompute(jd0, dt2, 4, 11, PV)
     write (*,*) PV

     call calceph_sclose
endif

calceph_sgetconstant¶

   function calceph_sgetconstant(name, value) BIND(C)¶

   Parameters:
          + name [CHARACTER(len=1,kind=C_CHAR), intent(in)] :: name of the
            constant.
          + value [REAL(C_DOUBLE), intent(out)] :: first value of the
            constant.

            Return:

   calceph_getconstant [INTEGER(C_INT)] :: 0 if an error occurs, otherwise
   non-zero value.

   This function returns the value associated to the constant name in the
   header of the ephemeris file.

   Only the first value is returned if multiple values are associated to a
   constant, such as a list of values.

   The function calceph_sopen() must be previously called before.

   The following example prints the value of the astronomical unit stored
   in the ephemeris file
integer res
real(8) AU
! open the ephemeris file
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then
    if (calceph_sgetconstant("AU"//C_NULL_CHAR, AU).eq.1) then
        write (*,*) "AU=", AU
    endif
endif

calceph_sgetconstantcount¶

   function calceph_sgetconstantcount() BIND(C)¶

   Return: calceph_sgetconstantcount [INTEGER(C_INT)] :: 0 if an error
   occurs, otherwise non-zero value.

   This function returns the number of constants available in the header
   of the ephemeris file.

   The function calceph_sopen() must be previously called before.

   The following example prints the number of available constants stored
   in the ephemeris file
integer res
integer n
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then

  n = calceph_sgetconstantcount()
  write (*,*) "number of constants", n

  call calceph_sclose
endif

calceph_sgetconstantindex¶

   function calceph_sgetconstantindex(index, name, value) BIND(C)¶

   Parameters:
          + index [INTEGER(C_INT), VALUE, intent(in)] :: index of the
            constant, between 1 and calceph_getconstantcount()
          + name [CHARACTER(len=1,kind=C_CHAR),
            dimension(CALCEPH_MAX_CONSTANTNAME), intent(out)] :: name of
            the constant.
          + value [REAL(C_DOUBLE), intent(out)] :: first value of the
            constant

            Return:

   calceph_sgetconstantindex [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function returns the name and its value of the constant available
   at the specified index in the header of the ephemeris file. The value
   of index must be between 1 and calceph_sgetconstantcount().

   The function calceph_sopen() must be previously called before.

   The following example displays the name of the constants, stored in the
   ephemeris file, and their values
integer res
integer j
real(8) valueconstant
character(len=CALCEPH_MAX_CONSTANTNAME) nameconstant

res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then

  do j=1, calceph_sgetconstantcount()
    res = calceph_sgetconstantindex(j,nameconstant,valueconstant)
    write (*,*) nameconstant,"=",valueconstant
  enddo

call calceph_sclose

calceph_sgetfileversion¶

   function calceph_sgetfileversion(version) BIND(C)¶

   Parameters: version [CHARACTER(len=1,kind=C_CHAR),
   dimension(CALCEPH_MAX_CONSTANTVALUE), intent(out)] :: version of the
   file
   Return: calceph_sgetfileversion [INTEGER(C_INT)] :: returns 0 if the
   file version was not found, otherwise non-zero value.

   This function returns the version of the ephemeris file, as a string.
   For example, the argument version will contain 'INPOP10B', 'EPM2017' or
   'DE405', ... .

   If the file is an original JPL binary planetary ephemeris, then the
   version of the file can always be determined. If the file is a spice
   kernel, the version of the file is retrieved from the constant
   INPOP_PCK_VERSION, EPM_PCK_VERSION, or PCK_VERSION.

   The function calceph_sopen() must be previously called before.

   The following example prints the version of the ephemeris file.
integer res
character(len=CALCEPH_MAX_CONSTANTVALUE) version
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then

  res = calceph_sgetfileversion(version)
  write (*,*) "The version of the file is ", version

  call calceph_sclose
endif

calceph_sgettimescale¶

   function calceph_sgettimescale() BIND(C)¶

   Return: calceph_sgettimescale [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function returns the timescale of the ephemeris file :

          + 1 if the quantities of all bodies are expressed in the TDB
            time scale.
          + 2 if the quantities of all bodies are expressed in the TCB
            time scale.

   The function calceph_sopen() must be previously called before.

   The following example prints the time scale available in the ephemeris
   file
integer res
integer t
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then

  t = calceph_sgettimescale()
  write (*,*) "timescale ", t

  call calceph_sclose
endif

calceph_sgettimespan¶

   function calceph_sgettimespan(firsttime, lasttime, continuous) BIND(C)¶

   Parameters:
          + firsttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            first time
          + lasttime [REAL(C_DOUBLE), intent(out)] :: Julian date of the
            last time
          + continuous [INTEGER(C_INT), intent(out)] :: information about
            the availability of the quantities over the time span

            Return:

   calceph_sgettimespan [INTEGER(C_INT)] :: 0 if an error occurs,
   otherwise non-zero value.

   This function returns the first and last time available in the
   ephemeris file. The Julian date for the first and last time are
   expressed in the time scale returned by calceph_sgettimescale() .

   It returns the following value in the parameter continuous :

     * 1 if the quantities of all bodies are available for any time
       between the first and last time.
     * 2 if the quantities of some bodies are available on discontinuous
       time intervals between the first and last time.
     * 3 if the quantities of each body are available on a continuous time
       interval between the first and last time, but not available for any
       time between the first and last time.

   The function calceph_sopen() must be previously called before.

   The following example prints the first and last time available in the
   ephemeris file
integer res
integer cont
real(8) jdfirst, jdlast
res = calceph_sopen("example1.dat"//C_NULL_CHAR)
if (res.eq.1) then

  res = calceph_sgettimespan(jdfirst, jdlast, cont)
  write (*,*) "data available between ", jdfirst, "and", jdlast
  write (*,*) "continuous data ", cont

  call calceph_sclose
endif

calceph_sclose¶

   subroutine calceph_sclose()¶

   This function closes the ephemeris data file and frees allocated memory
   by the function calceph_sopen().

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Miscellaneous functions Single file access functions

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
     * Single file access functions
     * Error functions
          + Usage
          + calceph_seterrorhandler
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Error functions
     *
     __________________________________________________________________

Error functions¶

   The following group of functions defines the behavior of the library
   when errors occur during the execution.

Usage¶

   The following examples, that can be found in the directory examples of
   the library sources, show the typical usage of this group of functions.

   The example in Fortran 2003 language is f2003error.f.

   The following example shows how to stop the execution on the error.
program f2003error
    USE, INTRINSIC :: ISO_C_BINDING
    use calceph
    implicit none
    integer res
    real(8) jd0
    real(8) dt
    real(8) PV(6)

 ! set the  error handler to stop on error
     call calceph_seterrorhandler(2, C_NULL_FUNPTR)

 ! open the ephemeris file
    res = calceph_sopen("example1.dat"//C_NULL_CHAR)
    ...

stop
end

   The following example shows how to define a custom error handler
   function.
!/*-----------------------------------------------------------------*/
!/* custom error handler */
!/*-----------------------------------------------------------------*/
     subroutine myhandler(msg, msglen) BIND(C)
        USE, INTRINSIC :: ISO_C_BINDING
        implicit none
        character(kind=C_CHAR), dimension(msglen), intent(in) :: msg
        integer(C_INT), VALUE, intent(in) :: msglen
        write (*,*) "The calceph calls the function myhandler"
        write (*,*) "The message contains ",msglen," characters"
        write(*,*) "The error message is :"
        write(*,*) "----------------------"
        write(*,*) msg
        write(*,*) "----------------------"
        write(*,*) "The error handler returns"
     end

!/*-----------------------------------------------------------------*/
!/* main program */
!/*-----------------------------------------------------------------*/
     program f2003error
         USE, INTRINSIC :: ISO_C_BINDING
         use calceph
         implicit none
         integer res
         real(8) jd0
         real(8) dt
         real(8) PV(6)

         interface
          subroutine myhandler(msg, msglen) BIND(C)
              USE, INTRINSIC :: ISO_C_BINDING
              implicit none
              character(kind=C_CHAR), dimension(msglen), intent(in) &
    &          :: msg
              integer(C_INT), VALUE, intent(in) :: msglen
          end subroutine
         end interface


! set the  error handler to use my own callback
         call calceph_seterrorhandler(3, c_funloc(myhandler))

! open the ephemeris file
        res = calceph_sopen("example1.dat"//C_NULL_CHAR)

   ! ...

     stop
     end

calceph_seterrorhandler¶

   subroutine calceph_seterrorhandler(typehandler, userfunc ) BIND(C)¶

   Parameters:
          + typehandler [TYPE(C_INT), VALUE, intent(in)] :: type of
            handler
          + userfunc [TYPE(C_FUNPTR), VALUE, intent(in)] :: user function

   This function defines the behavior of the library when an error occurs
   during the execution of the library's functions. This function should
   be (not mandatory) called before any other functions of the library.
   The behavior depends on the value of typehandler.

   The possible values for typehandler are :
   value meaning
   1
   The library displays a message and continues the execution.
   The functions return an error code. The python and Octave/Matlab
   interfaces raise
   an exception.
   This is the default behavior of the library.
   2
   The library displays a message
   and terminates the execution with a system call to thefunction exit.
   3
   The library calls the user function userfunc with the message.

   If the function is called with 1 or 2 for typehandler, the parameter
   userfunc must be set to C_NULL_FUNPTR.

   The function userfunc must be defined as
subroutine userfunc (msg, msglen)  BIND(C)
USE, INTRINSIC :: ISO_C_BINDING
implicit none
CHARACTER(kind=C_CHAR), dimension(msglen), intent(in) :: msg
INTEGER(C_INT), VALUE, intent(in) :: msglen

   This function must have an explicit interface.

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation NAIF
   identification numbers Error functions

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
     * Single file access functions
     * Error functions
     * Miscellaneous functions
          + calceph_getversion_str
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Miscellaneous functions
     *
     __________________________________________________________________

Miscellaneous functions¶

calceph_getversion_str¶

   subroutine calceph_getversion_str(version) BIND(C)¶

   Parameters: version [CHARACTER(len=1,kind=C_CHAR),
   dimension(CALCEPH_MAX_CONSTANTNAME), intent(out)] :: version of the
   library

   This function returns the version of the CALCEPH Library, as a string.

   Trailing blanks are added to the name version.
character(len=CALCEPH_MAX_CONSTANTNAME) version

call calceph_getversion_str(version)
write(*,*) 'library version is ', version

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Release notes Miscellaneous functions

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
     * Single file access functions
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
          + Sun and planetary barycenters
          + Coordinate Time ephemerides
          + Planet centers and satellites
          + Comets
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * NAIF identification numbers
     *
     __________________________________________________________________

NAIF identification numbers¶

   The following predefined values must be used as the target body and
   origin of the coordinate system with the functions
   calceph_compute_unit(), calceph_orient_unit() calceph_compute_order()
   or calceph_orient_order() if and only if the value CALCEPH_USE_NAIFID
   has been set in the parameter unit.

   This list is already predefined in the module file calceph.mod.

Sun and planetary barycenters¶

         Predefined Macros        NAIF ID          Name
   NAIFID_SOLAR_SYSTEM_BARYCENTER 0       Solar System Barycenter
   NAIFID_MERCURY_BARYCENTER      1       Mercury Barycenter
   NAIFID_VENUS_BARYCENTER        2       Venus Barycenter
   NAIFID_EARTH_MOON_BARYCENTER   3       Earth-Moon Barycenter
   NAIFID_MARS_BARYCENTER         4       Mars Barycenter
   NAIFID_JUPITER_BARYCENTER      5       Jupiter Barycenter
   NAIFID_SATURN_BARYCENTER       6       Saturn Barycenter
   NAIFID_URANUS_BARYCENTER       7       Uranus Barycenter
   NAIFID_NEPTUNE_BARYCENTER      8       Neptune Barycenter
   NAIFID_PLUTO_BARYCENTER        9       Pluto Barycenter
   NAIFID_SUN                     10      Sun

Coordinate Time ephemerides¶

   Predefined Macros NAIF ID Name
   NAIFID_TIME_CENTER 1000000000 center ID for Coordinate Time ephemerides
   [1]
   NAIFID_TIME_TTMTDB 1000000001 Coordinate Time ephemeride TT-TDB [2]
   NAIFID_TIME_TCGMTCB 1000000002 Coordinate Time ephemeride TCG-TCB [2]
   [1] These values must only be used as a center body.
   [2] (1, 2) These values must only be used as a target body.

Planet centers and satellites¶

   Predefined Macros NAIF ID    Name
   NAIFID_MERCURY    199     Mercury

   NAIFID_VENUS      299     Venus

   NAIFID_EARTH      399     Earth
   NAIFID_MOON       301     Moon

   NAIFID_MARS       499     Mars
   NAIFID_PHOBOS     401     Phobos
   NAIFID_DEIMOS     402     Deimos

   NAIFID_JUPITER    599     Jupiter
   NAIFID_IO         501     Io
   NAIFID_EUROPA     502     Europa
   NAIFID_GANYMEDE   503     Ganymede
   NAIFID_CALLISTO   504     Callisto
   NAIFID_AMALTHEA   505     Amalthea
   NAIFID_HIMALIA    506     Himalia
   NAIFID_ELARA      507     Elara
   NAIFID_PASIPHAE   508     Pasiphae
   NAIFID_SINOPE     509     Sinope
   NAIFID_LYSITHEA   510     Lysithea
   NAIFID_CARME      511     Carme
   NAIFID_ANANKE     512     Ananke
   NAIFID_LEDA       513     Leda
   NAIFID_THEBE      514     Thebe
   NAIFID_ADRASTEA   515     Adrastea
   NAIFID_METIS      516     Metis
   NAIFID_CALLIRRHOE 517     Callirrhoe
   NAIFID_THEMISTO   518     Themisto
   NAIFID_MAGACLITE  519     Magaclite
   NAIFID_TAYGETE    520     Taygete
   NAIFID_CHALDENE   521     Chaldene
   NAIFID_HARPALYKE  522     Harpalyke
   NAIFID_KALYKE     523     Kalyke
   NAIFID_IOCASTE    524     Iocaste
   NAIFID_ERINOME    525     Erinome
   NAIFID_ISONOE     526     Isonoe
   NAIFID_PRAXIDIKE  527     Praxidike
   NAIFID_AUTONOE    528     Autonoe
   NAIFID_THYONE     529     Thyone
   NAIFID_HERMIPPE   530     Hermippe
   NAIFID_AITNE      531     Aitne
   NAIFID_EURYDOME   532     Eurydome
   NAIFID_EUANTHE    533     Euanthe
   NAIFID_EUPORIE    534     Euporie
   NAIFID_ORTHOSIE   535     Orthosie
   NAIFID_SPONDE     536     Sponde
   NAIFID_KALE       537     Kale
   NAIFID_PASITHEE   538     Pasithee
   NAIFID_HEGEMONE   539     Hegemone
   NAIFID_MNEME      540     Mneme
   NAIFID_AOEDE      541     Aoede
   NAIFID_THELXINOE  542     Thelxinoe
   NAIFID_ARCHE      543     Arche
   NAIFID_KALLICHORE 544     Kallichore
   NAIFID_HELIKE     545     Helike
   NAIFID_CARPO      546     Carpo
   NAIFID_EUKELADE   547     Eukelade
   NAIFID_CYLLENE    548     Cyllene
   NAIFID_KORE       549     Kore
   NAIFID_HERSE      550     Herse
   NAIFID_DIA        553     Dia

   NAIFID_SATURN     699     Saturn
   NAIFID_MIMAS      601     Mimas
   NAIFID_ENCELADUS  602     Enceladus
   NAIFID_TETHYS     603     Tethys
   NAIFID_DIONE      604     Dione
   NAIFID_RHEA       605     Rhea
   NAIFID_TITAN      606     Titan
   NAIFID_HYPERION   607     Hyperion
   NAIFID_IAPETUS    608     Iapetus
   NAIFID_PHOEBE     609     Phoebe
   NAIFID_JANUS      610     Janus
   NAIFID_EPIMETHEUS 611     Epimetheus
   NAIFID_HELENE     612     Helene
   NAIFID_TELESTO    613     Telesto
   NAIFID_CALYPSO    614     Calypso
   NAIFID_ATLAS      615     Atlas
   NAIFID_PROMETHEUS 616     Prometheus
   NAIFID_PANDORA    617     Pandora
   NAIFID_PAN        618     Pan
   NAIFID_YMIR       619     Ymir
   NAIFID_PAALIAQ    620     Paaliaq
   NAIFID_TARVOS     621     Tarvos
   NAIFID_IJIRAQ     622     Ijiraq
   NAIFID_SUTTUNGR   623     Suttungr
   NAIFID_KIVIUQ     624     Kiviuq
   NAIFID_MUNDILFARI 625     Mundilfari
   NAIFID_ALBIORIX   626     Albiorix
   NAIFID_SKATHI     627     Skathi
   NAIFID_ERRIAPUS   628     Erriapus
   NAIFID_SIARNAQ    629     Siarnaq
   NAIFID_THRYMR     630     Thrymr
   NAIFID_NARVI      631     Narvi
   NAIFID_METHONE    632     Methone
   NAIFID_PALLENE    633     Pallene
   NAIFID_POLYDEUCES 634     Polydeuces
   NAIFID_DAPHNIS    635     Daphnis
   NAIFID_AEGIR      636     Aegir
   NAIFID_BEBHIONN   637     Bebhionn
   NAIFID_BERGELMIR  638     Bergelmir
   NAIFID_BESTLA     639     Bestla
   NAIFID_FARBAUTI   640     Farbauti
   NAIFID_FENRIR     641     Fenrir
   NAIFID_FORNJOT    642     Fornjot
   NAIFID_HATI       643     Hati
   NAIFID_HYROKKIN   644     Hyrokkin
   NAIFID_KARI       645     Kari
   NAIFID_LOGE       646     Loge
   NAIFID_SKOLL      647     Skoll
   NAIFID_SURTUR     648     Surtur
   NAIFID_ANTHE      649     Anthe
   NAIFID_JARNSAXA   650     Jarnsaxa
   NAIFID_GREIP      651     Greip
   NAIFID_TARQEQ     652     Tarqeq
   NAIFID_AEGAEON    653     Aegaeon

   NAIFID_URANUS     799     Uranus
   NAIFID_ARIEL      701     Ariel
   NAIFID_UMBRIEL    702     Umbriel
   NAIFID_TITANIA    703     Titania
   NAIFID_OBERON     704     Oberon
   NAIFID_MIRANDA    705     Miranda
   NAIFID_CORDELIA   706     Cordelia
   NAIFID_OPHELIA    707     Ophelia
   NAIFID_BIANCA     708     Bianca
   NAIFID_CRESSIDA   709     Cressida
   NAIFID_DESDEMONA  710     Desdemona
   NAIFID_JULIET     711     Juliet
   NAIFID_PORTIA     712     Portia
   NAIFID_ROSALIND   713     Rosalind
   NAIFID_BELINDA    714     Belinda
   NAIFID_PUCK       715     Puck
   NAIFID_CALIBAN    716     Caliban
   NAIFID_SYCORAX    717     Sycorax
   NAIFID_PROSPERO   718     Prospero
   NAIFID_SETEBOS    719     Setebos
   NAIFID_STEPHANO   720     Stephano
   NAIFID_TRINCULO   721     Trinculo
   NAIFID_FRANCISCO  722     Francisco
   NAIFID_MARGARET   723     Margaret
   NAIFID_FERDINAND  724     Ferdinand
   NAIFID_PERDITA    725     Perdita
   NAIFID_MAB        726     Mab
   NAIFID_CUPID      727     Cupid

   NAIFID_NEPTUNE    899     Neptune
   NAIFID_TRITON     801     Triton
   NAIFID_NEREID     802     Nereid
   NAIFID_NAIAD      803     Naiad
   NAIFID_THALASSA   804     Thalassa
   NAIFID_DESPINA    805     Despina
   NAIFID_GALATEA    806     Galatea
   NAIFID_LARISSA    807     Larissa
   NAIFID_PROTEUS    808     Proteus
   NAIFID_HALIMEDE   809     Halimede
   NAIFID_PSAMATHE   810     Psamathe
   NAIFID_SAO        811     Sao
   NAIFID_LAOMEDEIA  812     Laomedeia
   NAIFID_NESO       813     Neso

   NAIFID_PLUTO      999     Pluto
   NAIFID_CHARON     901     Charon
   NAIFID_NIX        902     Nix
   NAIFID_HYDRA      903     Hydra
   NAIFID_KERBEROS   904     Kerberos
   NAIFID_STYX       905     Styx

Comets¶

         Predefined Macros        NAIF ID          Name
   NAIFID_AREND                   1000001 Arend
   NAIFID_AREND_RIGAUX            1000002 Arend-Rigaux
   NAIFID_ASHBROOK_JACKSON        1000003 Ashbrook-Jackson
   NAIFID_BOETHIN                 1000004 Boethin
   NAIFID_BORRELLY                1000005 Borrelly
   NAIFID_BOWELL_SKIFF            1000006 Bowell-Skiff
   NAIFID_BRADFIELD               1000007 Bradfield
   NAIFID_BROOKS_2                1000008 Brooks 2
   NAIFID_BRORSEN_METCALF         1000009 Brorsen-Metcalf
   NAIFID_BUS                     1000010 Bus
   NAIFID_CHERNYKH                1000011 Chernykh
   NAIFID_CHURYUMOV_GERASIMENKO   1000012 Churyumov-Gerasimenko
   NAIFID_CIFFREO                 1000013 Ciffreo
   NAIFID_CLARK                   1000014 Clark
   NAIFID_COMAS_SOLA              1000015 Comas Sola
   NAIFID_CROMMELIN               1000016 Crommelin
   NAIFID_D__ARREST               1000017 D''Drrest
   NAIFID_DANIEL                  1000018 Daniel
   NAIFID_DE_VICO_SWIFT           1000019 De Vico-Swift
   NAIFID_DENNING_FUJIKAWA        1000020 Denning-Fujikawa
   NAIFID_DU_TOIT_1               1000021 Du Toit 1
   NAIFID_DU_TOIT_HARTLEY         1000022 Du Toit-Hartley
   NAIFID_DUTOIT_NEUJMIN_DELPORTE 1000023 Dutoit-Neujmin-Delporte
   NAIFID_DUBIAGO                 1000024 Dubiago
   NAIFID_ENCKE                   1000025 Encke
   NAIFID_FAYE                    1000026 Faye
   NAIFID_FINLAY                  1000027 Finlay
   NAIFID_FORBES                  1000028 Forbes
   NAIFID_GEHRELS_1               1000029 Gehrels 1
   NAIFID_GEHRELS_2               1000030 Gehrels 2
   NAIFID_GEHRELS_3               1000031 Gehrels 3
   NAIFID_GIACOBINI_ZINNER        1000032 Giacobini-Zinner
   NAIFID_GICLAS                  1000033 Giclas
   NAIFID_GRIGG_SKJELLERUP        1000034 Grigg-Skjellerup
   NAIFID_GUNN                    1000035 Gunn
   NAIFID_HALLEY                  1000036 Halley
   NAIFID_HANEDA_CAMPOS           1000037 Haneda-Campos
   NAIFID_HARRINGTON              1000038 Harrington
   NAIFID_HARRINGTON_ABELL        1000039 Harrington-Abell
   NAIFID_HARTLEY_1               1000040 Hartley 1
   NAIFID_HARTLEY_2               1000041 Hartley 2
   NAIFID_HARTLEY_IRAS            1000042 Hartley-Iras
   NAIFID_HERSCHEL_RIGOLLET       1000043 Herschel-Rigollet
   NAIFID_HOLMES                  1000044 Holmes
   NAIFID_HONDA_MRKOS_PAJDUSAKOVA 1000045 Honda-Mrkos-Pajdusakova
   NAIFID_HOWELL                  1000046 Howell
   NAIFID_IRAS                    1000047 Iras
   NAIFID_JACKSON_NEUJMIN         1000048 Jackson-Neujmin
   NAIFID_JOHNSON                 1000049 Johnson
   NAIFID_KEARNS_KWEE             1000050 Kearns-Kwee
   NAIFID_KLEMOLA                 1000051 Klemola
   NAIFID_KOHOUTEK                1000052 Kohoutek
   NAIFID_KOJIMA                  1000053 Kojima
   NAIFID_KOPFF                   1000054 Kopff
   NAIFID_KOWAL_1                 1000055 Kowal 1
   NAIFID_KOWAL_2                 1000056 Kowal 2
   NAIFID_KOWAL_MRKOS             1000057 Kowal-Mrkos
   NAIFID_KOWAL_VAVROVA           1000058 Kowal-Vavrova
   NAIFID_LONGMORE                1000059 Longmore
   NAIFID_LOVAS_1                 1000060 Lovas 1
   NAIFID_MACHHOLZ                1000061 Machholz
   NAIFID_MAURY                   1000062 Maury
   NAIFID_NEUJMIN_1               1000063 Neujmin 1
   NAIFID_NEUJMIN_2               1000064 Neujmin 2
   NAIFID_NEUJMIN_3               1000065 Neujmin 3
   NAIFID_OLBERS                  1000066 Olbers
   NAIFID_PETERS_HARTLEY          1000067 Peters-Hartley
   NAIFID_PONS_BROOKS             1000068 Pons-Brooks
   NAIFID_PONS_WINNECKE           1000069 Pons-Winnecke
   NAIFID_REINMUTH_1              1000070 Reinmuth 1
   NAIFID_REINMUTH_2              1000071 Reinmuth 2
   NAIFID_RUSSELL_1               1000072 Russell 1
   NAIFID_RUSSELL_2               1000073 Russell 2
   NAIFID_RUSSELL_3               1000074 Russell 3
   NAIFID_RUSSELL_4               1000075 Russell 4
   NAIFID_SANGUIN                 1000076 Sanguin
   NAIFID_SCHAUMASSE              1000077 Schaumasse
   NAIFID_SCHUSTER                1000078 Schuster
   NAIFID_SCHWASSMANN_WACHMANN_1  1000079 Schwassmann-Wachmann 1
   NAIFID_SCHWASSMANN_WACHMANN_2  1000080 Schwassmann-Wachmann 2
   NAIFID_SCHWASSMANN_WACHMANN_3  1000081 Schwassmann-Wachmann 3
   NAIFID_SHAJN_SCHALDACH         1000082 Shajn-Schaldach
   NAIFID_SHOEMAKER_1             1000083 Shoemaker 1
   NAIFID_SHOEMAKER_2             1000084 Shoemaker 2
   NAIFID_SHOEMAKER_3             1000085 Shoemaker 3
   NAIFID_SINGER_BREWSTER         1000086 Singer-Brewster
   NAIFID_SLAUGHTER_BURNHAM       1000087 Slaughter-Burnham
   NAIFID_SMIRNOVA_CHERNYKH       1000088 Smirnova-Chernykh
   NAIFID_STEPHAN_OTERMA          1000089 Stephan-Oterma
   NAIFID_SWIFT_GEHRELS           1000090 Swift-Gehrels
   NAIFID_TAKAMIZAWA              1000091 Takamizawa
   NAIFID_TAYLOR                  1000092 Taylor
   NAIFID_TEMPEL_1                1000093 Tempel 1
   NAIFID_TEMPEL_2                1000094 Tempel 2
   NAIFID_TEMPEL_TUTTLE           1000095 Tempel-Tuttle
   NAIFID_TRITTON                 1000096 Tritton
   NAIFID_TSUCHINSHAN_1           1000097 Tsuchinshan 1
   NAIFID_TSUCHINSHAN_2           1000098 Tsuchinshan 2
   NAIFID_TUTTLE                  1000099 Tuttle
   NAIFID_TUTTLE_GIACOBINI_KRESAK 1000100 Tuttle-Giacobini-Kresak
   NAIFID_VAISALA_1               1000101 Vaisala 1
   NAIFID_VAN_BIESBROECK          1000102 Van Biesbroeck
   NAIFID_VAN_HOUTEN              1000103 Van Houten
   NAIFID_WEST_KOHOUTEK_IKEMURA   1000104 West-Kohoutek-Ikemura
   NAIFID_WHIPPLE                 1000105 Whipple
   NAIFID_WILD_1                  1000106 Wild 1
   NAIFID_WILD_2                  1000107 Wild 2
   NAIFID_WILD_3                  1000108 Wild 3
   NAIFID_WIRTANEN                1000109 Wirtanen
   NAIFID_WOLF                    1000110 Wolf
   NAIFID_WOLF_HARRINGTON         1000111 Wolf-Harrington
   NAIFID_LOVAS_2                 1000112 Lovas 2
   NAIFID_URATA_NIIJIMA           1000113 Urata-Niijima
   NAIFID_WISEMAN_SKIFF           1000114 Wiseman-Skiff
   NAIFID_HELIN                   1000115 Helin
   NAIFID_MUELLER                 1000116 Mueller
   NAIFID_SHOEMAKER_HOLT_1        1000117 Shoemaker-Holt 1
   NAIFID_HELIN_ROMAN_CROCKETT    1000118 Helin-Roman-Crockett
   NAIFID_HARTLEY_3               1000119 Hartley 3
   NAIFID_PARKER_HARTLEY          1000120 Parker-Hartley
   NAIFID_HELIN_ROMAN_ALU_1       1000121 Helin-Roman-Alu 1
   NAIFID_WILD_4                  1000122 Wild 4
   NAIFID_MUELLER_2               1000123 Mueller 2
   NAIFID_MUELLER_3               1000124 Mueller 3
   NAIFID_SHOEMAKER_LEVY_1        1000125 Shoemaker-Levy 1
   NAIFID_SHOEMAKER_LEVY_2        1000126 Shoemaker-Levy 2
   NAIFID_HOLT_OLMSTEAD           1000127 Holt-Olmstead
   NAIFID_METCALF_BREWINGTON      1000128 Metcalf-Brewington
   NAIFID_LEVY                    1000129 Levy
   NAIFID_SHOEMAKER_LEVY_9        1000130 Shoemaker-Levy 9
   NAIFID_HYAKUTAKE               1000131 Hyakutake
   NAIFID_HALE_BOPP               1000132 Hale-Bopp
   NAIFID_SIDING_SPRING           1003228 Siding Spring

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Reporting bugs NAIF identification numbers

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
     * Single file access functions
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Release notes
     *
     __________________________________________________________________

Release notes¶

     *

        Version 3.4.0
                Add the function calceph_isthreadsafe.

                Multiple threads can now access the same ephemeris
                descriptor if the function calceph_isthreadsafe returns 1.

                Fortran and C examples (f2003parallel.f, cparallel.c),
                written using OpenMP, are available in the folder
                examples.

                Fix an error if multiple SPICE kernels are loaded for the
                same objects over different time-span.

                Fix the MinGW Makefiles if the variable MAKE contains
                spaces.

                Support the segment 5 and 18 in the SPICE kernel file.

                Support the euler angles for the orientation stored in a
                text PCK files (BODY..._POLE_RA, BODY..._POLE_DE,
                BODY..._POLE_PM, BODY..._NUT_PREC_...).

                Support the frame 17 (ECLIPJ2000) in the SPICE kernel
                file.

                Add the utilities calceph_queryposition and
                calceph_queryorientation.

     *

        Version 3.3.1
                Fix the installation with python 3.7.0 or later.

                Fix the installation with python and pip on Windows
                operating system.

                Add the missing file pythonapi/src/Makefile.mingw for the
                environnment MinGW.

     *

        Version 3.3.0
                Add the functions calceph_getfileversion.

                Fix a regression to open some old JPL DE format files.

                Fix a compiler warning in the file util.c.

                Support the segments 8, 9, 17 and 21 in the SPICE kernel
                file.

                Check the validity of the number of constants in the
                original INPOP/DE files.

                For the Python interface, the functions compute??? and
                orient??? supports now a list or numpy's array for the
                time parameters.

     *

        Version 3.2.0
                Fix the creation of the dynamic library with msys/mingw on
                Windows.

                Fix the returned value of the functions
                f90calceph_getconstantvd and f90calceph_getconstantvs.

                Fix a compilation warning with the GNU C compilers 8.0 or
                later.

                Support the original JPL files with TT-TDB or with a large
                number of constants.

                Support the IAU 1980 Nutation Angles of the JPL files.

                Add the NAIF identification numbers for DIA, KERBEROS,
                STYX and SIDING SPRING.

                Add the option installnodoc to the make command.

     *

        Version 3.1.0
                Add the Mex interface compliant with Octave 4.0+ and
                Matlab 2017+.

                Add the functions calceph_getconstantsd,
                calceph_getconstantvd and calceph_getconstantss and
                calceph_getconstantvs.

                Fix a compilation problem with MinGW if the terminal
                cmd.exe is used.

                Fix a wrong function name open_array instead of open in
                the documentation of the Python interface.

                Fix the return value of the functions calceph_orient_xxx
                when the unit CALCEPH_UNIT_RAD is not provided.

                The return value of the function
                calceph_(s)getconstant(index) is the number of values
                associated to the constant.

                Display a better message for the unsupported old spice
                kernel (NAIF/DAF)

     *

        Version 3.0.0
                Update the license CeCILL v2.0 to CeCILL v2.1.

                Fix a decode error for SPICE kernels with a big-endian
                format.

                Add the function calceph_gettimescale and
                calceph_gettimespan.

                Add the function calceph_getpositionrecordcount and
                calceph_getpositionrecordindex.

                Add the function calceph_getorientrecordcount and
                calceph_getorientrecordindex.

                Add the function calceph_sgettimescale and
                calceph_sgettimespan.

                Support INPOP file format 3.0 (add angular momentum due to
                the rotation in the binary file).

                Use sphinx-doc to produce the documentation.

     *

        Version 2.3.2
                Fix the return value of the function calceph_getconstant
                if the constant name "AU" or "EMRAT" is not available.

                Fix the documentation for the fortran interface of the
                function calceph_prefetch.

                Fix the return value of the function calceph_orient_unit
                if the frame SPICE kernel file is missing.

     *

        Version 2.3.1
                Fix the compilation warnings with the Pelles compiler.

                Fix the compilation warnings with the C89 standard.

                Fix the compilation warnings with the GNU C compilers.

                Fix the documentation for the constant
                CALCEPH_VERSION_STRING.

     *

        Version 2.3.0
                Add the python interface compliant with python 2.6+ and
                python 3.

                Add the preprocessor macro CALCEPH_VERSION_STRING.

                Add the function calceph_getversion_str.

                Add the function calceph_compute_order and
                calceph_orient_order.

                Fix the return value of the functions calceph_compute_xxx
                when the reference frame is not available in the spice
                kernel files.

                The function should produce an error and return 0 (before
                the function performed no computation but it returned 1).

     *

        Version 2.2.5
                Fix an incorrect result if CALCEPH_UNIT_DAY is provided to
                calceph_compute_unit and the target is TCG-TCB or TT-TDB.

                Support the numerical constants declared without
                parenthesis in the text kernel files (.tpc).

                Support the segment 1, 12 and 13 in the SPICE kernel file.

     *

        Version 2.2.4
                Update the version number of the dynamic library.

     *

        Version 2.2.3
                Add the predefined constants for calceph version in the
                fortran interface.

                Fix the build chain if calceph is compiled from another
                folder.

     *

        Version 2.2.2
                Support the compilation in the standard C89.

     *

        Version 2.2.1
                Remove debug informations that are printed when errors
                occur in calceph_?compute_???.

                Support the Portland compilers.

                Fix the info documentation.

                Report an error if no asteroid is available in an
                ephemeris file with the INPOP file format (instead of a
                crash).

     *

        Version 2.2.0
                Support the new segments 20, 102, 103 and 120 in the SPICE
                kernel file.

                Support the NAIF identification numbers.

                Add the functions calceph_orient_unit and
                calceph_prefetch.

     *

        Version 2.1.0
                Fix a bug in calceph_getconstant and calceph_sgetconstant
                with an invalid name

                Remove the null character in the name of the constant
                returned by the function (f90)calceph_(s)getconstantindex
                when the Fortran interface is used.

     *

        Version 2.0.0
                Fix memory leaks in calceph_open when errors occur.

                Support INPOP file format 2.0 (supports TCB ephemeris file
                and add asteroids in the binary file).

                Add the function calceph_open_array and
                calceph_compute_unit.

                Add the tools calceph_inspector to show details about
                ephemeris file.

                Support SPICE kernel file (SPK with segment 2 or 3, text
                and binary PCK, meta kernel, basic frame kernel).

                Improve the performances.

                Correct the Fortran 2003 interface for
                calceph_sgetconstantindex.

                Add the constant 17 to get TCG-TCB from TCB ephemeris
                file.

     *

        Version 1.2.0
                Change the licensing : triple licenses to support
                integration in BSD software.

                Remove explicit dependencies on the record size for DExxx.

     *

        Version 1.1.2
                Fix a compilation warning with oracle studio compiler 12.

                Fix a bug with gcc on solaris in 64 bit mode.

                Fix the copyright statements.

     *

        Version 1.1.1
                Fix a compilation error in util.h and a warning with the
                sun studio compilers.

     *

        Version 1.1.0
                Add the function calceph_seterrorhandler for the custom
                error handlers.

     *

        Version 1.0.3
                Support the JPL ephemeris file DE423.

     *

        Version 1.0.2
                Fix memory leaks in the fortran-90 interface.

     *

        Version 1.0.1
                Support the large ephemeris files (>2GB) on 32-bit
                operating systems.

                Fix the documentation of the function f90calceph_sopen.

                Fix an invalid open mode on Windows operating systems.

                Report accurately the I/O errors.

     *

        Version 1.0.0
                Initial release.

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   CALCEPH Library Copying conditions Release notes

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
     * Single file access functions
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * Reporting bugs
     *
     __________________________________________________________________

Reporting bugs¶

   If you think you have found a bug in the CALCEPH Library, first have a
   look on the CALCEPH Library web page http://www.imcce.fr/inpop, in
   which case you may find there a workaround for it. Otherwise, please
   investigate and report it. We have made this library available to you,
   and it seems very important for us, to ask you to report the bugs that
   you find.

   There are a few things you should think about when you put your bug
   report together. You have to send us a test case that makes it possible
   for us to reproduce the bug. Include instructions on the way to run the
   test case.

   You also have to explain what is wrong; if you get a crash, or if the
   results printed are incorrect and in that case, in what way.

   Please include compiler version information in your bug report. This
   can be extracted using cc -V on some machines, or, if you're using gcc,
   gcc -v. Also, include the output from uname -a and the CALCEPH version.

   Send your bug report to: inpop.imcce@obspm.fr. If you think something
   in this manual is unclear, or downright incorrect, or if the language
   needs to be improved, please send a note to the same address.

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Fortran 2003 language 3.4.0 documentation
   Reporting bugs

   CALCEPH - Fortran 2003 language
   3.4.0
   ____________________
     * Introduction
     * Installation
     * Library interface
     * Multiple file access functions
     * Single file access functions
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Fortran 2003 language
     * Docs »
     * CALCEPH Library Copying conditions
     *
     __________________________________________________________________

CALCEPH Library Copying conditions¶

   Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019,

   CNRS, Observatoire de Paris, Observatoire de la Côte d'Azur

   Contributed by

   Gastineau M. , Laskar J., Manche H., Astronomie et Systèmes Dynamiques,
   IMCCE, CNRS, Observatoire de Paris, UPMC

   Fienga A. , Observatoire de la Côte d'Azur

   inpop.imcce@obspm.fr

   This library is governed by the CeCILL-C,CeCILL-B or CeCILL version 2
   license under French law and abiding by the rules of distribution of
   free software. You can use, modify and/ or redistribute the software
   under the terms of the CeCILL-C,CeCILL-B or CeCILL version 2 license as
   circulated by CEA, CNRS and INRIA at the following URL
   "http://www.cecill.info".

   As a counterpart to the access to the source code and rights to copy,
   modify and redistribute granted by the license, users are provided only
   with a limited warranty and the software's author, the holder of the
   economic rights, and the successive licensors have only limited
   liability.

   In this respect, the user's attention is drawn to the risks associated
   with loading, using, modifying and/or developing or reproducing the
   software by the user in light of its specific status of free software,
   that may mean that it is complicated to manipulate, and that also
   therefore means that it is reserved for developers and experienced
   professionals having in-depth computer knowledge. Users are therefore
   encouraged to load and test the software's suitability as regards their
   requirements in conditions enabling the security of their systems
   and/or data to be ensured and, more generally, to use and operate it in
   the same conditions as regards security.

   The fact that you are presently reading this means that you have had
   knowledge of the CeCILL-C,CeCILL-B or CeCILL version 2 license and that
   you accept its terms.

   Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
    #Index Search CALCEPH - Python language 3.4.0 documentation Library
   interface Introduction

   CALCEPH - Python language
   3.4.0
   ____________________
     * Introduction
     * Installation
          + Quick instructions for installing on a Unix-like system
            (Linux, Mac OS X, BSD, Cygwin, ...)
          + Detailed instructions for installing on a Unix-like system
            (Linux, Mac OS X, BSD, Cygwin, ...)
               o Other make Targets
          + Installation on Windows system
               o Using the Microsoft Visual C++ compiler
               o Using the MinGW
     * Library interface
     * Multiple file access functions
     * Error functions
     * Miscellaneous functions
     * NAIF identification numbers
     * Release notes
     * Reporting bugs
     * CALCEPH Library Copying conditions

   Index

   CALCEPH - Python language
     * Docs »
     * Installation
     *
     __________________________________________________________________

Installation¶

Quick instructions for installing on a Unix-like system (Linux, Mac OS X,
BSD, Cygwin, ...)¶

   Here are the quick steps needed to install the library on Unix systems.
   In the following instructions, you must replace /home/mylogin/mydir by
   the directory location where you want to install calceph.

   If you use the python interface of the library and the pip package
   management system, the steps are :

     * Install the requirements

pip install Cython setuptools numpy

     * Install the library

pip install calcephpy

   If you use the python interface of the library, it requires that the
   packages cython, setuptools and numpy are already installed and the
   steps are :

tar xzf calceph-3.4.0.tar.gz
cd calceph-3.4.0
./configure --enable-python=yes --enable-python-package-user=yes --prefix=/home/
mylogin/mydir
make check && make install

   If you use the gcc and gfortran compilers, the steps are :

tar xzf calceph-3.4.0.tar.gz
cd calceph-3.4.0
./configure --disable-shared CC=gcc FC=gfortran --prefix=/home/mylogin/mydir
make check && make install

   If you use the Intel c++ and fortran compilers, the steps are :

tar xzf calceph-3.4.0.tar.gz
cd calceph-3.4.0
./configure --disable-shared CC=icc FC=ifort --prefix=/home/mylogin/mydir
make check && make install

Detailed instructions for installing on a Unix-like system (Linux, Mac OS X,
BSD, Cygwin, ...)¶

   You need a C compiler, such as gcc.

   A fortran compiler, compliant with the ANSI Fortran 77 specifications,
   is required to compile the fortran-77/90/95 interface of the library.

   A fortran compiler, compliant with the Fortran 2003 specifications, is
   required to compile the fortran-2003 interface of the library.

   A python interpreter, compliant at least with with the Python 2.6 or
   Python 3.0 specifications, and the package Cython, setuptools and numpy
   are required to compile the python interface of the library.

   And you need a standard Unix make program, plus some other standard
   Unix utility programs.

   Here are the detailed steps needed to install the library on Unix
   systems:
     * tar xzf calceph-3.4.0.tar.gz
     * cd calceph-3.4.0
     * ./configure

     Running configure might take a while. While running, it prints some
     messages telling which features it is checking for.
     configure recognizes the following options to control how it
     operates.
          + --enable-fortran={yes|no}
            Enable or disable the fortran-77 and fortran-2003 interface.
            The default is yes.
          + --enable-python={yes|no}
            Enable or disable the python interface. The default is no.
          + --enable-python-package-system={yes|no}
            Enable or disable the installation of the python package to
            the system site-packages directory (e.g.,
            /usr/lib/python3.4/sites-packages/) . The default is no.
          + --enable-python-package-user={yes|no}
            Enable or disable the installation of the python package to
            the user site-packages directory (e.g.,
            ~/.local/lib/python3.4/site-packages/) . The default is no.
          + --enable-thread={yes|no}
            Enable or disable the thread-safe version of the functions
            calcephpy.CalcephBin.sopen() and
            calcephpy.CalcephBin.scompute(), ... and concurrent access to
            the function calcephpy.CalcephBin.compute(), .... The default
            is no.
          + --disable-shared
            Disable shared library.
          + --disable-static
            Disable static library.
          + --help
            Print a summary of all of the options to configure, and exit.
          + --prefix= dir
            Use dir as the installation prefix. See the command make
            install for the installation names.

     The default compilers could be changed using the variable CC for C
     compiler, FC for the Fortran compiler and PYTHON for the python
     interpreter. The default compiler flags could be changed using the
     variable CFLAGS for C compiler and FCFLAGS for the Fortran compiler.
     If --enable-python=yes, we recommend to set
     --enable-python-package-user=yes ( or
     --enable-python-package-system=yes if you have administrative right
     on the system directory) in order to that the python interpreter
     finds the CALCEPH python package.

     * make

     This compiles the CALCEPH Library in the working directory.
     * make check

     This will make sure that the CALCEPH Library was built correctly.
     If you get error messages, please report them to
     inpop.imcce@obspm.fr (see Reporting bugs, for information on what to
     include in useful bug reports).
     * make install

     This will copy the files calceph.h, calceph.mod and f90calceph.h to
     the directory /usr/local/include, the file libcalceph.a,
     libcalceph.so to the directory /usr/local/lib, and the
     documentations files to the directory /usr/local/doc/calceph/ (or if
     you passed the --prefix option to configure, using the prefix
     directory given as argument to --prefix instead of /usr/local).
     Note: you need write permissions on these directories.
     If the python interface is enabled and
     enable-python-package-system=yes or enable-python-package-user=yes,
     the python package will be copied to system or user python
     site-package.
     * If you want to enable the mex interface

          + If you don't install in a standard path, add dir/lib to the
            environment variables LD_LIBRARY_PATH or DYLD_LIBRARY_PATH.
          + Add the path /usr/local/libexec/calceph/mex to the environment
            variable MATLABPATH
          + If you use Matlab, start Matlab and execute the following
            command in order to compile the Mex interface:

calceph_compilemex()

          + If you use Octave, start Octave and execute the following
            command in order to compile the Mex interface:

addpath('/usr/local/libexec/calceph/mex')
calceph_compilemex()

Other make Targets¶

   There are some other useful make targets:
     * clean

     Delete all object files and archive files, but not the configuration
     files.
     * distclean

     Delete all files not included in the distribution.
     * installnodoc

     Same as install, except that the documentation is not installed.
     * uninstall

     Delete all files copied by make install.

Installation on Windows system¶

Using the Microsoft Visual C++ compiler¶

   You need the Microsoft Visual C++ compiler, such as cl.exe, and the
   Universal CRT SDK or a Windows SDK. A fortran compiler, compliant with
   the ANSI Fortran 77 specifications, is required to compile the
   fortran-77/90/95 interface of the library. A fortran compiler,
   compliant with the Fortran 2003 specifications, is required to compile
   the fortran-2003 interface of the library.

   The "Universal CRT (C runtime) SDK" or a "Windows SDK" are now provided
   with the Microsoft Visual Studio. You should verify that "Universal CRT
   (C runtime) SDK" or a "Windows SDK" is selected in the "Visual Studio
   Installer".

   If you use the python interface of the library and the pip package
   management system, the steps are :

     * Execute the script 'vcvars32.bat' or vcvars64.bat' depending on the
       Windows version.
       Theses scripts are located in the directory
       "C:\Program Files (x86)\Microsoft Visual Studio..."
       They are usually located in

     "C:\Program Files (x86)\Microsoft Visual
     Studio\2017\Community\VC\Auxiliary\Build"
     or
     "C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC".
       Depending on your Python version, the Microsoft Visual C++ compiler
       must be the same version of the compiler that was used to build
       Python itself should be used.
     * Install the requirements

pip install Cython setuptools numpy

     * Install the library

pip install calcephpy

   If you use the C, Fortran, or mex interface, the steps are :
     * Expand the file calceph-3.4.0.tar.gz
     * Execute the command :cmd.exe from the menu Start / Execute...

     This will open a console window
     * cd dir\calceph-3.4.0

     Go to the directory dir where CALCEPH Library has been expanded.
     * nmake /f Makefile.vc

     This compiles CALCEPH Library in the working directory. This command
     line accepts several options :
          + CC= xx

     specifies the name of the C compiler. The defaut value is cl.exe
          + FC= xx

     specifies the name of the Fortran compiler. The defaut value is
     gfortran.exe
          + F77FUNC= naming

     specifies the naming convention of the fortran 77 compiler.
     The possible value are: x, X, x##_ , X##_.
          + ENABLEF2003={0|1}

     specifies if it must compile the fortran 2003 interface. The defaut
     value is 0.
          + ENABLEF77={0|1}

     specifies if it must compile the fortran 77/90/95 interface. The
     defaut value is 0.

     * nmake /f Makefile.vc check

     This will make sure that the CALCEPH Library was built correctly.
     If you get error messages, please report them to
     inpop.imcce@obspm.fr (see Reporting bugs, for information on what to
     include in useful bug reports).
     This command line accepts several options :
          + CC= xx

     specifies the name of the C compiler. The defaut value is cl.exe
          + FC= xx

     specifies the name of the Fortran compiler. The defaut value is
     gfortran.exe
          + F77FUNC= naming

     specifies the naming convention of the fortran 77 compiler.
     The possible value are: x, X, x##_ , X##_.
          + ENABLEF2003={0|1}

     specifies if it must compile the fortran 2003 interface. The defaut
     value is 0.
          + ENABLEF77={0|1}

     specifies if it must compile the fortran 77/90/95 interface. The
     defaut value is 0.

     * nmake /f Makefile.vc install DESTDIR= dir

     This will copy the file calceph.h, calceph.mod and f90calceph.h to
     the directory dir, the file libcalceph.lib to the directory dir
     \lib, the documentation files to the directory dir \doc. Note: you
     need write permissions on these directories.

   This command line accepts several options :

     * CC= xx

     specifies the name of the C compiler. The defaut value is cl.exe
     * FC= xx

     specifies the name of the Fortran compiler. The defaut value is
     gfortran.exe
     * F77FUNC= naming

     specifies the naming convention of the fortran 77 compiler.
     The possible value are: x, X, x##_ , X##_.
     * ENABLEF2003={0|1}

     specifies if it must compile the fortran 2003 interface. The defaut
     value is 0.
     * ENABLEF77={0|1}

     specifies if it must compile the fortran 77/90/95 interface. The
     defaut value is 0.

     * If you want to enable the mex interface

          + If you don't install in a standard path, add dir \lib to the
            environment variables LD_LIBRARY_PATH or DYLD_LIBRARY_PATH.
          + Add the path dir \libexec\calceph\mex to the environment
            variable MATLABPATH
          + Start Matlab or Octave and execute the following command in
            order to compile the Mex interface:

addpath('dir \libexec\calceph\mex')
calceph_compilemex()

Using the MinGW¶

   You need a C compiler, such as gcc.exe.

   A fortran compiler, compliant with the ANSI Fortran 77 specifications,
   is required to compile the fortran-77/90/95 interface of the library.

   A fortran compiler, such as gfortran.exe, compliant with the Fortran
   2003 specifications, is required to compile the fortran-2003 interface
   of the library.

   A python interpreter, compliant at least with the Python 2.6 or Python
   3.0 specifications, and the package Cython, setuptools and numpy are
   required to compile the python interface of the library.

   If you use the python interface of the library and the pip package
   management system, the steps are :

     * Install the requirements

pip install Cython setuptools numpy

     * Install the library

pip install calcephpy

   If you use the C, Fortran, or mex interface, the steps are :
     * Expand the file calceph-3.4.0.tar.gz
     * Execute the command MinGW Shell from the menu Start.

     This will open a MinGW Shell console window.
     * cd dir\calceph-3.4.0

     Go to the directory dir where CALCEPH Library has been expanded.
     * make -f Makefile.mingw

     This compiles CALCEPH Library in the working directory.
     This command line accepts several options :
          + CC= xx

     specifies the name of the C compiler. The defaut value is gcc.exe
          + FC= xx

     specifies the name of the Fortran compiler. The defaut value is
     gfortran.exe
          + PYTHON= xx

     specifies the name of the Python interpreter. The defaut value is
     python.exe
          + F77FUNC= naming

     specifies the naming convention of the fortran 77 compiler.
     The possible value are: x, X, x##_ , X##_.
          + ENABLEF2003={0|1}

     specifies if it must compile the fortran 2003 interface. The defaut
     value is 0.
          + ENABLEF77={0|1}

     specifies if it must compile the fortran 77/90/95 interface. The
     defaut value is 0.
          + ENABLEPYTHON={0|1}

     specifies if it must compile the python interface. The defaut value
     is 0.
     * make -f Makefile.mingw check

     This will make sure that the CALCEPH Library was built correctly.
     If you get error messages, please report them to
     inpop.imcce@obspm.fr (see Reporting bugs , for information on what
     to include in useful bug reports).
     This command line accepts several options :
          + CC= xx

     specifies the name of the C compiler. The defaut value is gcc.exe
          + FC= xx

     specifies the name of the Fortran compiler. The defaut value is
     gfortran.exe
          + PYTHON= xx

     specifies the name of the Python interpreter. The defaut value is
     python.exe
          + F77FUNC= naming

     specifies the naming convention of the fortran 77 compiler.
     The possible value are: x, X, x##_ , X##_.
          + ENABLEF2003={0|1}

     specifies if it must compile the fortran 2003 interface. The defaut
     value is 0.
          + ENABLEF77={0|1}

     specifies if it must compile the fortran 77/90/95 interface. The
     defaut value is 0.
          + ENABLEPYTHON={0|1}

     specifies if it must compile the python interface. The defaut value
     is 0.
     * make -f Makefile.mingw install DESTDIR= dir

     This will copy the file calceph.h, calceph.mod and f90calceph.h to
     the directory dir, the file libcalceph.lib to the directory dir
     \lib, the documentation files to the directory dir \doc.

   If ENABLEPYTHON=1, the installation will copy the of the CALCEPH python
   package to the system python site package (e.g.,
   C:\Python27\Lib\sites-packages\) in order to that the python
   interpreter finds the CALCEPH module.

   Note: you need write permissions on these directories.

   This command line accepts several options :

     * CC= xx

     specifies the name of the C compiler. The defaut value is gcc.exe
     * FC= xx

     specifies the name of the Fortran compiler. The defaut value is
     gfortran.exe
     * PYTHON= xx

   specifies the name of the Python interpreter. The defaut value is
   python.exe
     * F77FUNC= naming

     specifies the naming convention of the fortran 77 compiler.
     The possible value are: x, X, x##_ , X##_.
     * ENABLEF2003={0|1}

     specifies if it must compile the fortran 2003 interface. The defaut
     value is 0.
     * ENABLEF77={0|1}

     specifies if it must compile the fortran 77/90/95 interface. The
     defaut value is 0.
     * ENABLEPYTHON={0|1}

   specifies if it must compile the python interface. The defaut value is
   0.

     * If you want to enable the mex interface

          + If you don't install in a standard path, add dir \lib to the
            environment variables LD_LIBRARY_PATH or DYLD_LIBRARY_PATH.
          + Add the path dir \libexec\calceph\mex to the environment
            variable MATLABPATH
          + Start Matlab or Octave and execute the following command in
            order to compile the Mex interface:

addpath('dir \libexec\calceph\mex')
calceph_compilemex()

   Next Previous
     __________________________________________________________________

   © Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
   2018, 2019, CNRS, Observatoire de Paris, Observatoire de la Côte
   d'Azur.
